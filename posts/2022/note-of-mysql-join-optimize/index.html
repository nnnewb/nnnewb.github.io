<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>记一次MySQL JOIN优化</title><meta content="记一次MySQL JOIN优化" name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2022/note-of-mysql-join-optimize/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content="记一次MySQL JOIN优化" property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2022/note-of-mysql-join-optimize/ property=twitter:url><meta content="记一次MySQL JOIN优化" property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2022/note-of-mysql-join-optimize/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>记一次MySQL JOIN优化</h1><p class=author-line>作于：2022-03-14 12:30 ，预计阅读时间 11 分钟<article><h2 id=qian-yan>前言</h2><p>长话短说，这个性能问题是上周修一个bug的时候企图偷懒引入的。因为 xorm 在连接查询的时候模型结构必须是和 <code>join</code> 的顺序保持一致，中间还不能有遗漏，不然查询结果填充到结构里的时候就会错位。<p>而业务里这个条件又是可选的——用户不传的时候不需要 <code>INNER JOIN</code>；但为了让 xorm 开心，同时尽量别把整个函数签名和返回类型都改了把影响范围搞太大，所以就偷了个懒：既然 xorm 要 <code>JOIN</code> ，那就 <code>LEFT JOIN</code>加个恒假的条件呗。于是就顺手写下了下面的代码。<pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>LEFT JOIN</span><span> tbl ON </span><span style=color:#d3869b>1 </span><span style=color:#fe8019>&lt;> </span><span style=color:#d3869b>1
</span></code></pre><p>没啥问题对吧？我当时也这么想的。<h2 id=wen-ti>问题</h2><p>好了，问题来了。先把整个 SQL写下来。<pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>SELECT </span><span style=color:#fdf4c1>*
</span><span style=color:#fa5c4b>FROM</span><span> a
</span><span style=color:#fa5c4b>INNER JOIN</span><span> b ON </span><span style=color:#b8bb26>a</span><span>.</span><span style=color:#b8bb26>resource_id </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>b</span><span>.</span><span style=color:#b8bb26>id
</span><span style=color:#fa5c4b>LEFT JOIN</span><span> c ON </span><span style=color:#d3869b>1 </span><span style=color:#fe8019>&lt;> </span><span style=color:#d3869b>1
</span><span style=color:#fa5c4b>LEFT JOIN</span><span> d ON </span><span style=color:#b8bb26>d</span><span>.</span><span style=color:#b8bb26>resource_id </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>a</span><span>.</span><span style=color:#b8bb26>resource_id
</span><span style=color:#fa5c4b>LEFT JOIN</span><span> e ON </span><span style=color:#b8bb26>e</span><span>.</span><span style=color:#b8bb26>resource_id </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>a</span><span>.</span><span style=color:#b8bb26>resource_id
</span><span style=color:#fa5c4b>WHERE
</span><span>	</span><span style=color:#b8bb26>a</span><span>.</span><span style=color:#b8bb26>result </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>4
</span><span>	</span><span style=color:#fe8019>AND </span><span style=color:#b8bb26>b</span><span>.</span><span style=color:#b8bb26>resource_type </span><span style=color:#fe8019>= </span><span style=color:#d3869b>2
</span><span style=color:#fa5c4b>limit </span><span style=color:#d3869b>10</span><span> offset </span><span style=color:#d3869b>0</span><span>;
</span></code></pre><p>整个查询的实际耗时是 <strong>919ms</strong>。<p><em>why ?</em><h2 id=xing-neng-fen-xi>性能分析</h2><p>查询慢了第一反应还是是不是没索引，于是先看看 <code>explain</code> 的结果。<table><thead><tr><th>id<th>select_type<th>table<th>partitions<th>type<th>possible_keys<th>key<th>key_len<th>ref<th>rows<tbody><tr><td>1<td>SIMPLE<td>a<td><td>ALL<td>IDX_a_resource_id<td><td><td><td>456<tr><td>1<td>SIMPLE<td>b<td><td>eq_ref<td>PRIMARY<td>PRIMARY<td>8<td>a.resource_id<td>1<tr><td>1<td>SIMPLE<td>d<td><td>ref<td>IDX_d_resource_id<td>IDX_d_resource_id<td>8<td>a.resource_id<td>1<tr><td>1<td>SIMPLE<td>e<td><td>ref<td>IDX_e_resource_id<td>IDX_e_resource_id<td>9<td>a.resource_id<td>1<tr><td>1<td>SIMPLE<td>c<td><td>ALL<td><td><td><td><td>6405</table><p>驱动表是 <code>a</code>，做了全表扫描，但数据量很小，只有400多行。但这个表是只增的，全表扫描还是不太对劲，于是看了眼索引，发现 <code>result</code> 没有索引——但这个字段区分度不算很高，只有4个枚举值。<p>网上随便搜的博客看到列区分度计算可以用 <code>SELECT count(distinct col)/count(*) FROM tbl</code> 来计算，区分度越接近 1 则索引效果越好。<code>result</code>的区分度只有<code>0.0088</code>，个人感觉区别不大。这种情况下使用result索引滤出来的结果集会比较大，回表查询次数过多的话还不如就遍历一遍原表。<p>想归想，但还是老实加上了 <code>result</code> 索引，再 <code>explain</code> 了一次，结果是 <code>possible keys</code> 里多了 <code>IDX_a_result</code>，但最 <code>type</code> 还是 <code>ALL</code>，说明确实和 <code>result</code> 字段有没有索引没关系。<p>再接着看下面，其他表基本不是主键就是二级索引，唯独 <code>c</code> 表特立独行——也是<code>ALL</code>。但这个表的 <code>JOIN</code> 子句是这样的。<pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>LEFT JOIN</span><span> c ON </span><span style=color:#d3869b>1 </span><span style=color:#fe8019>&lt;> </span><span style=color:#d3869b>1
</span></code></pre><p>这为啥要遍历？<p><img alt=执行计划 src=https://nnnewb.github.io/posts/2022/note-of-mysql-join-optimize/image-20220314135914892.webp><p>但看到 cost 只有 87.68，又松了口气，可能只是 <code>explain</code> 输出不对吧，怎么想 <code>ON 1 &lt;> 1</code> 这样的条件也应该是常数时间内完成。<p>到这里，思路已经完全走歪了，开始觉得是不是磁盘 IO 或者网络 IO 上有瓶颈？<h3 id=sysstat-gong-ju>sysstat 工具</h3><p>这里介绍下一个很好用的 Linux 下性能分析工具，<a href=https://github.com/sysstat/sysstat>sysstat</a>。大部分发行版都可以直接用内置包管理器安装，如 Debian/Ubuntu 可以用 <code>apt-get install sysstat</code> 安装。<p><code>sysstat</code> 包含了各种在Unix、Linux环境下通用的工具，来监视系统性能和使用情况。这里面有很多好用的工具比如 <code>sar</code>、<code>iostat</code>、<code>pidstat</code>。<p>安装<code>sysstat</code>之后还需要配置。<pre class=language-bash data-lang=bash style=color:#fdf4c1aa;background-color:#282828><code class=language-bash data-lang=bash><span style=color:#fdf4c1>sudo dpkg-reconfigure sysstat
</span></code></pre><p>然后选 <code>yes</code> 来启用定时任务自动收集数据到 <code>/var/log/sysstat</code> ，这样 <code>sar</code> 就可以导出报告了。<p><code>sar</code> 是一个综合性的工具，可以收集、导出、保存系统活动数据，收集的数据包括：I/O、CPU、物理内存/Hugepage/Swap、虚拟内存、进程创建、中断、网络接口、socket、等等...非常全面，基本能想到的都有。<p>放在这个场景里，用 <code>sar</code> 可以看到运行查询时的磁盘使用情况：<code>sudo sar -bd 1</code><pre style=color:#fdf4c1aa;background-color:#282828><code><span>14时48分14秒       tps      rtps      wtps      dtps   bread/s   bwrtn/s   bdscd/s
</span><span>14时48分15秒     40.00      1.00     39.00      0.00      8.00    312.00      0.00
</span><span>
</span><span>14时48分14秒       DEV       tps     rkB/s     wkB/s     dkB/s   areq-sz    aqu-sz     await     %util
</span><span>14时48分15秒    dev7-0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
</span><span>14时48分15秒    dev7-1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
</span><span>14时48分15秒    dev7-2      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
</span><span>14时48分15秒    dev7-3      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
</span><span>14时48分15秒    dev7-4      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
</span><span>14时48分15秒    dev7-5      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
</span><span>14时48分15秒    dev7-6      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
</span><span>14时48分15秒    dev7-7      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
</span><span>14时48分15秒    dev8-0     40.00      4.00    156.00      0.00      4.00      0.00      0.20      2.00
</span><span>14时48分15秒  dev253-0     42.00      4.00    156.00      0.00      3.81      0.00      0.00      2.00
</span><span>14时48分15秒    dev7-8      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
</span><span>14时48分15秒    dev7-9      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
</span></code></pre><p>不能说毫无波动，但显然和瓶颈应该扯不上关系了。但出于谨慎考虑，还是用 <code>pidstat</code> 指定了 <code>mysqld</code> 进程的 PID 来观察。这里多嘴一句，MySQL 是用 kubernetes 部署在办公室的服务器上的，我得提一嘴 <code>sysstat</code> 是在宿主机上直接运行而不是容器里——这得说到容器隔离的原理，<code>namespace</code>和<code>cgroup</code>，在外层<code>namespace</code>下是可以看到内层<code>namespace</code>的进程的，但内层的<code>namespace</code>看不到外层，是单向的隔离。所以可以直接在宿主机上用 <code>ps</code> 看到 <code>pause</code> 容器的进程以及 <code>mysqld</code> 这种容器里的进程，也可以收集到各种使用率信息——因为共享宿主机的内核嘛。<pre class=language-bash data-lang=bash style=color:#fdf4c1aa;background-color:#282828><code class=language-bash data-lang=bash><span style=color:#fdf4c1>pidstat -d -p 11404 1
</span></code></pre><pre style=color:#fdf4c1aa;background-color:#282828><code><span>14时57分19秒   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command
</span><span>14时57分20秒   999     11404     -1.00     -1.00     -1.00       0  mysqld
</span><span>14时57分21秒   999     11404     -1.00     -1.00     -1.00       0  mysqld
</span><span>14时57分22秒   999     11404     -1.00     -1.00     -1.00       0  mysqld
</span><span>14时57分23秒   999     11404     -1.00     -1.00     -1.00       0  mysqld
</span><span>14时57分24秒   999     11404     -1.00     -1.00     -1.00       0  mysqld
</span></code></pre><p>这就只能说毫无波动了，说那么多，并没有卵用。<h2 id=zhuan-zhe>转折</h2><p>一上午几乎都花费在这个查询上，终于在一次胡乱分析中注意到 CPU 使用率不同寻常：<code>pidstat  -p 11404 -d 1</code><pre style=color:#fdf4c1aa;background-color:#282828><code><span>15时01分01秒   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
</span><span>15时01分02秒   999     11404    0.00    0.00    0.00    0.00    0.00     1  mysqld
</span><span>15时01分03秒   999     11404    0.00    0.00    0.00    0.00    0.00     1  mysqld
</span><span>15时01分04秒   999     11404    0.00    0.00    0.00    0.00    0.00     1  mysqld
</span><span>15时01分05秒   999     11404    0.00    0.00    0.00    0.00    0.00     1  mysqld
</span><span>15时01分06秒   999     11404    6.00    0.00    0.00    0.00    6.00     1  mysqld
</span><span>15时01分07秒   999     11404   39.00    0.00    0.00    0.00   39.00     1  mysqld
</span><span>15时01分08秒   999     11404   52.00    0.00    0.00    0.00   52.00     1  mysqld
</span><span>15时01分09秒   999     11404   65.00    0.00    0.00    0.00   65.00     1  mysqld
</span><span>15时01分10秒   999     11404   53.00    0.00    0.00    0.00   53.00     1  mysqld
</span><span>15时01分11秒   999     11404   66.00    0.00    0.00    0.00   66.00     6  mysqld
</span><span>15时01分12秒   999     11404   85.00    0.00    0.00    0.00   85.00     6  mysqld
</span><span>15时01分13秒   999     11404    5.00    0.00    0.00    0.00    5.00     6  mysqld
</span><span>15时01分14秒   999     11404    0.00    0.00    0.00    0.00    0.00     6  mysqld
</span></code></pre><p><img alt=这彩色输出是真舒服 src=https://nnnewb.github.io/posts/2022/note-of-mysql-join-optimize/image-20220314150141759.webp><p>在运行查询时，CPU使用率飙升到了50%~85%，一个简单的查询几乎跑满了一个核心？如果 ctrl+enter 按得稍微勤快一点，这个使用率最高能跑到 105% ——这还是因为我在 kubernetes 只给了 1 CPU 的配额的缘故。于是瓶颈终于暴露了出来：CPU。这谁能想到呢。<p>再回过头分析查询，结合一下脑子里沉睡已久的记忆+谷歌一下，问题终于浮出水面。<p><img alt=执行计划 src=https://nnnewb.github.io/posts/2022/note-of-mysql-join-optimize/image-20220314135914892.webp><p>对，<code>nested_loop#5</code>，MySQL 的执行计划忠实反映了实际做的事情。MySQL 真就，对着 <code>LEFT JOIN ... ON 1 &lt;> 1</code> 这个条件，在嵌套循环里，做了个全表扫描......<p>所谓<code>nested_loop</code>，就是<code>for range { for range {}}</code> 这样的执行路径，简单地把 <code>Rows</code> 乘一下就能得到实际处理了多少行：<code>6450*456=2920680</code>，一共 292 万行，难怪 CPU 使用率会如此之高，难怪数据量这么小的两个表做查询居然会花费接近1s的时间。<h2 id=jie-jue>解决</h2><p>知道了瓶颈，找到了造成瓶颈的代码，那么应该就好解决了——话虽如此，要我给出解决办法的话确实就是一句话的事情，但为了找出这个解决办法反而浪费了不少时间。<p>回顾造成问题的 <code>JOIN</code> 子句，<code>LEFT JOIN ... ON 1 &lt;> 1</code>，<code>1 &lt;> 1</code> 是恒假条件，但 MySQL 对这个条件选择了全表扫描这种完全无法理解的处理方式。<p>行，那我直接改成 <code>ON FALSE</code>，总不至于连 <code>FALSE</code> 也能给个全表扫描的执行计划吧？对，还真能，MySQL 真有你的...<p>随后还试了 <code>0 > 1</code>、<code>1 &lt; 0</code>、<code>1=2</code>、<code>1 is null</code> 等等条件，无一例外 MySQL 的执行计划都是 nested_loop + 全表扫描，就在快放弃的时候偶然想到既然说什么都要扫表，那我让 MySQL 扫就是了，给个有索引的字段让 MySQL 不要全表扫描，也能改善很多吧？然后就随手写下 <code>c.id=-1</code>。<p>然后 MySQL 的执行计划就从全表扫描变成了常数时间...真有你的啊 MySQL！<p>又试了下 <code>c.id is null</code> 同样也是常数时间，所以MySQL犯傻的原因是优化器没考虑到有我这样的 <strong>聪（臭）明（傻）人（B）</strong> 会往条件里写个 FALSE 是吧...真有你的啊 MySQL！<h2 id=zong-jie>总结</h2><ol start=0><li>不要忽略 explain 给出的线索。<li>注意 <code>nested_loop</code>，<code>join</code> 的条件不能太宽泛，否则遍历的数据量会爆炸性增长，后果就是查询时间随随便便翻几百倍。 <ol><li>最高效的 <code>join</code> 当然是直接走主键，查一个元素，聚簇索引，不用回表，查询时间复杂度不变。<li>次一级的走二级索引，查一个元素，回表一次也就完了，查询时间复杂度不变。<li>再次一级的索引区分度不足1，查找出来多个元素，回表多次，嵌套循环的话会成倍放大驱动表的时间复杂度。<li>最差的情况，索引区分度太差或者没索引，被迫嵌套循环+全表扫描，也就是我碰到的情况，生产下负载提上来一点就大概率要GG。</ol><li>MySQL 的优化器需要在条件里给个列，就算是恒真或者恒假的条件，也一定要给个列，不然MySQL就会跟个傻逼一样选择全表扫描。 <ol><li>我的环境是 MySQL 5.7.33，InnoDB 5.7.33，MySQL Community Server，新版本 MySQL 不知道有没有解决。</ol><li><code>sysstat</code> 这套工具很好用，如果没把可观测性的基础设施(各种<code>reporter</code>+<code>prometheus</code>+<code>grafana</code>)搞好的话，<code>sysstat</code> 值得拥有。</ol></article><p class=tags-data><a href=/tags/mysql>/mysql/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>