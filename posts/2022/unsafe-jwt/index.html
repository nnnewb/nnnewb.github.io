<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>不安全的 jwt</title><meta content="不安全的 jwt" name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2022/unsafe-jwt/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content="不安全的 jwt" property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2022/unsafe-jwt/ property=twitter:url><meta content="不安全的 jwt" property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2022/unsafe-jwt/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>不安全的 jwt</h1><p class=author-line>作于：2022-04-11 13:00 ，预计阅读时间 9 分钟<article><h2 id=qian-yan>前言</h2><p>今早翻到<a href=https://www.leavesongs.com/PENETRATION/the-collision-of-containers-and-the-cloud-pentesting-a-MinIO.html>p神挖MinIO CVE的文章</a>，注意到几句话：<blockquote><p>jwt常见的攻击方法主要有下面这几种：<ul><li>将alg设置为None，告诉服务器不进行签名校验<li>如果alg为RSA，可以尝试修改为HS256，即告诉服务器使用公钥进行签名的校验<li>爆破签名密钥</ul></blockquote><p>虽然早早在项目里用上了jwt（大概是16~17年，在另一家公司的登陆系统里），但在目前任职的公司用上jwt的时候还真没从安全的角度考虑过如何编写 <strong>正确、安全</strong> 的 jwt 验证代码。<small>悄悄哔哔一句我也不是搞安全的啊（</small><p>既然翻博客的时候看到了，就没法当没看见。正好翻翻看自己写的垃圾代码是不是有洞。<h2 id=kai-shi-review>开始 review</h2><p>因为这项目后端是微服务架构，身份验证实际上分成了两种情况：<ol><li>提供验证的服务，从 redis/mysql 校验身份<li>其他服务，通过 rpc 请求验证服务来校验身份</ol><p>jwt 本身通过签名机制保证发放出来的 token 不被篡改，所以在最初编写的时候主要考虑的还是解决用户账户的封禁、登陆互斥问题，jwt 对解决这方面问题的帮助有限，就没怎么深究。<p>验证流程很简单：<p>incoming request -> gRPC interceptor (<code>rpc_authneticate()</code>) -> <code>auth.Authenticate(ctx, req)</code><p><code>auth.Authenticate</code> 是验证业务的实现，分几个步骤：<ol><li>解析输入token，<code>func ParseToken(token string) (*jwt.Token, *CustomJWTClaims, error)</code><li>同平台登陆互斥，限制同一平台仅一个有效登陆。通过比较 redis 里保存的 token 实现。<li>账户状态检查，因为缓存设计的问题导致这一步需要查数据库，实现稀烂。</ol><p>p神博客原文提到的方法里，修改 <code>ALG</code> 来跳过校验无疑是最可能出现的坑，然后我就看了下自己写的：<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#928374;font-style:italic>// ParseToken 解析 jwt token，返回 token,claims,error
</span><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>ParseToken</span><span>(</span><span style=color:#fdf4c1>token </span><span style=color:#fabd2f>string</span><span>) (</span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>jwt</span><span>.</span><span style=color:#fa5c4b>Token</span><span>, </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>CustomJWTClaims</span><span>, </span><span style=color:#fabd2f>error</span><span>) {
</span><span>	</span><span style=color:#fdf4c1>claims </span><span style=color:#fe8019>:= &</span><span style=color:#fdf4c1>CustomJWTClaims</span><span>{}
</span><span>	</span><span style=color:#fdf4c1>t</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>jwt</span><span>.</span><span style=color:#fdf4c1>ParseWithClaims</span><span>(</span><span style=color:#fdf4c1>token</span><span>, </span><span style=color:#fdf4c1>claims</span><span>, </span><span style=color:#fa5c4b>func</span><span>(</span><span style=color:#fdf4c1>t </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>jwt</span><span>.</span><span style=color:#fa5c4b>Token</span><span>) (</span><span style=color:#fa5c4b>interface</span><span>{}, </span><span style=color:#fabd2f>error</span><span>) { </span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>JWTSecret</span><span>, </span><span style=color:#d3869b>nil </span><span>})
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>nil</span><span>, </span><span style=color:#d3869b>nil</span><span>, </span><span style=color:#fdf4c1>errors</span><span>.</span><span style=color:#fdf4c1>Wrap</span><span>(</span><span style=color:#fdf4c1>err</span><span>, </span><span style=color:#b8bb26>"parse jwt token with claims fail"</span><span>)
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>t</span><span>, </span><span style=color:#fdf4c1>claims</span><span>, </span><span style=color:#d3869b>nil
</span><span>}
</span></code></pre><p>...<p>好，我寄了！<h2 id=yan-zheng-lou-dong>验证漏洞</h2><p>事到如今已经没有退路，洞肯定是要补的，补之前出于好奇，再尝试一次利用，也作为洞存在的验证。<h3 id=alg-none>ALG none</h3><p>jwt 产生的签名字符串分成3个部分：HEADER、PAYLOAD、SIGNATURE，均使用 base64 编码，用 . 分隔。以官网的例子来分析如下：<p><img alt=JWT格式 src=https://nnnewb.github.io/posts/2022/unsafe-jwt/image-20220411103235343.webp><p>其中 header 和 payload 部分会编码成 url 安全的 base64，可以在命令行 <code>echo &lt;jwt.header> | base64 -d</code> 来看到 header 实际包含的内容，payload 同理。signature 的算法由 header 里的 alg 指定，比如 alg 是 <code>HS256</code> 的时候签名就是 <code>HMACSHA256(base64(header)+"."+base64(payload))</code>。<p>攻击方式1里提到的把 <code>ALG</code> 改成 <code>none</code>，就是告诉服务器不做签名验证，如果服务器信了你的邪，那就可以伪造出任意身份。<p>接下来尝试构造一个无签名的 jwt 请求：<pre class=language-bash data-lang=bash style=color:#fdf4c1aa;background-color:#282828><code class=language-bash data-lang=bash><span style=color:#fabd2f>echo </span><span style=color:#b8bb26>'{"alg": "none", "typ":"JWT"}' </span><span style=color:#fe8019>| </span><span style=color:#fdf4c1>base64
</span><span style=color:#928374;font-style:italic># eyJhbGciOiAibm9uZSIsICJ0eXAiOiJKV1QifQo=
</span><span style=color:#fabd2f>echo </span><span style=color:#b8bb26>'{"iat": 1649645013, "user_id": 1, "device_category": 0, "device_code": "233", "landing_platform":"PC"}' </span><span style=color:#fe8019>| </span><span style=color:#fdf4c1>base64
</span><span style=color:#928374;font-style:italic># eyJpYXQiOiAxNjQ5NjQ1MDEzLCAidXNlcl9pZCI6IDEsICJkZXZpY2VfY2F0ZWdvcnkiOiAwLCAi
</span><span style=color:#928374;font-style:italic># ZGV2aWNlX2NvZGUiOiAiMjMzIiwgImxhbmRpbmdfcGxhdGZvcm0iOiJQQyJ9Cg==
</span></code></pre><p>需要注意的是<code>=</code>是 base64 编码中的占位符，在构造签名字符串的时候要去掉。<p>最后用<code>.</code>连接，校验合法性。<pre style=color:#fdf4c1aa;background-color:#282828><code><span>eyJhbGciOiAibm9uZSIsICJ0eXAiOiJKV1QifQo.eyJpYXQiOiAxNjQ5NjQ1MDEzLCAidXNlcl9pZCI6IDEsICJkZXZpY2VfY2F0ZWdvcnkiOiAwLCAiZGV2aWNlX2NvZGUiOiAiMjMzIiwgImxhbmRpbmdfcGxhdGZvcm0iOiJQQyJ9Cg.
</span></code></pre><p><img alt="invalid signature" src=https://nnnewb.github.io/posts/2022/unsafe-jwt/image-20220411104759489.webp><p>... 得，直接试一下。<pre class=language-bash data-lang=bash style=color:#fdf4c1aa;background-color:#282828><code class=language-bash data-lang=bash><span style=color:#fdf4c1>curl -v -X GET -H </span><span style=color:#b8bb26>'grpc-metadata-sessionkey: eyJhbGciOiAibm9uZSIsICJ0eXAiOiJKV1QifQo.eyJpYXQiOiAxNjQ5NjQ1MDEzLCAidXNlcl9pZCI6IDEsICJkZXZpY2VfY2F0ZWdvcnkiOiAwLCAiZGV2aWNlX2NvZGUiOiAiMjMzIiwgImxhbmRpbmdfcGxhdGZvcm0iOiJQQyJ9Cg.' "localhost/v4/user/get_userinfo"
</span></code></pre><p><img alt="'none' signature type is not allowed" src=https://nnnewb.github.io/posts/2022/unsafe-jwt/image-20220411110837870.webp><p>惊喜！<p>看了眼使用的 jwt 库，<code>github.com/dgrijalva/jwt-go v3.2.0+incompatible</code>，目前迁移到了 <code>github.com/golang-jwt/jwt</code>，最新版本 4.x ，感谢这库给我挡了一枪。<h3 id=alg-rs256>ALG RS256</h3><p>另一个坑，HS256 => RS256 攻击，倒是没踩上。<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fdf4c1>token </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>jwt</span><span>.</span><span style=color:#fdf4c1>NewWithClaims</span><span>(</span><span style=color:#fdf4c1>jwt</span><span>.</span><span style=color:#fdf4c1>SigningMethodHS256</span><span>, </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>CustomJWTClaims</span><span>{
</span><span>    </span><span style=color:#928374;font-style:italic>// ...
</span><span>})
</span></code></pre><p>HS256 攻击没有 ALG none 攻击那么简单直白了，特地去搜了下 HS256 攻击方法和原理。<p>参考文章：<ul><li><a href="https://infosecwriteups.com/attacks-on-json-web-token-jwt-278a49a1ad2e?gi=11514f6199e8">Attacks on JSON Web Token</a><li><a href=https://anubhav-singh.medium.com/get-a-feel-of-jwt-json-web-token-8ee9c16ce5ce>Get a Feel of JWT (JSON Web Token)</a></ul><p>RS256签名的算法可以这样表示：<code>base64(rsa256(sha256(base64(header)+"."+base64(payload)+secret)))</code>，其中需要关注的是 <code>rsa256</code> 是如何签名的。<p>关于不对称加密套件的加解密/签名一句话概括就是：公钥加密，私约解密；私钥签名，公钥验签。RS256=>HS256攻击的原理就是服务器验证签名的时使用的是公钥——顾名思义，“公”指的是公开的，如果服务器所使用的的秘钥对在其他地方复用（比如使用的是域名的公钥），那公钥就唾手可得。<p>仅仅拿到了公钥还不够，因为签名只能由私钥产生。这里就涉及一个 JWT 实现的漏洞：<ul><li><a href=https://nvd.nist.gov/vuln/detail/CVE-2015-9235>CVE-2015-9235</a><li><a href=https://nvd.nist.gov/vuln/detail/CVE-2016-10555>CVE-2016-10555</a></ul><p>服务端使假设签名是 RS256 ，用公钥验签时，客户端可以构造一个恶意的 jwt 签名，把HEADER里的 ALG 指定为 HS256，服务端就会把 RS256 验证的公钥当成 HS256 的私钥来验证签名。<p>满足下面三个条件：<ul><li>服务器签发、接受 RS256 私钥签名的JWT<li>拿到公钥<li>使用有漏洞的 jwt 库</ul><p>就能自由构造任意 JWT PAYLOAD。<h3 id=bao-li-qiong-ju>暴力穷举</h3><p>既 brute-force 大法，对弱密码加上好点的字典也是可行的。不过我这服务HS256 秘钥是随机生成的，大小写字母+特殊字符。<p>不过即使是这样还是有考虑定期轮换秘钥，验证的阶段根据 iat/exp 来选择秘钥，即使攻击者舍得花时间碰运气也很难瞎猫碰上死耗子了。但因为种种原因，多少感觉有点过度设计的意思吧。就暂且没管。<h2 id=xiu-fu>修复</h2><p>已知 jwt 库已经解决了 ALG none 的问题，采用的签名算法也不是 RS256，随机秘钥熵也够，那就没啥可修复的了。非要说的话可以在 <code>ParseToken</code> 阶段限制下 ALG 的选择，强制选择一个比较坚挺的哈希算法。再把秘钥轮换做起来。<p>可以先列入计划，优先级不用太高吧。<h2 id=zong-jie>总结</h2><p>显然没有银弹这句话很对，jwt 并不是解决一切问题的良药，甚至是一把可能砸在自己小拇指上的锤子。<p>对 jwt 的三种常规攻击方式，两种是操纵 header 的 alg 实现的，alg none 的方式尝试跳过签名验证，alg rs256 转 hs256 则是利用库漏洞加上窃取公钥来伪造签名，利用难度更大。<p>暴力穷举法就没什么可说的了，或许在代码审计的时候需要考虑下秘钥面对暴力穷举时的安全性。</article><p class=tags-data><a href=/tags/golang>/golang/</a> <a href=/tags/jwt>/jwt/</a> <a href=/tags/an-quan>/安全/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>