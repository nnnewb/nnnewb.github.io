<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>gokit 架构之我见</title><meta content="gokit 架构之我见" name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2022/my-opinion-of-gokit-architecture/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content="gokit 架构之我见" property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2022/my-opinion-of-gokit-architecture/ property=twitter:url><meta content="gokit 架构之我见" property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2022/my-opinion-of-gokit-architecture/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>gokit 架构之我见</h1><p class=author-line>作于：2022-03-02 12:30 ，预计阅读时间 9 分钟<article><h2 id=qian-yan>前言</h2><p>这是看了 <a href=https://github.com/go-kit/kit/issues/843>Go kit: the road ahead</a> 之后，对 go kit 这套抽象的一些想法。主要是关于 endpoint 是否有必要、generic 会如何影响 go kit 的架构、go kit 的代码生成这些问题。<h2 id=endpoint-chou-xiang-ceng-shi-fou-bi-yao-cun-zai>endpoint 抽象层是否必要存在</h2><p>我的看法是需要。原因下面分析。<p>一个没有额外功能的 Endpoint 其实是起到了把请求类型适配到 Go 函数签名的作用。<a href=http://gokit.io/examples/stringsvc.html#endpoints>stringsvc</a> 实现如下。<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>import </span><span>(
</span><span>	</span><span style=color:#b8bb26>"context"
</span><span>	</span><span style=color:#b8bb26>"github.com/go-kit/kit/endpoint"
</span><span>)
</span><span>
</span><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>makeUppercaseEndpoint</span><span>(</span><span style=color:#fdf4c1>svc </span><span style=color:#fa5c4b>StringService</span><span>) </span><span style=color:#fdf4c1>endpoint</span><span>.</span><span style=color:#fa5c4b>Endpoint </span><span>{
</span><span>	</span><span style=color:#fa5c4b>return func</span><span>(</span><span style=color:#fdf4c1>_ context</span><span>.</span><span style=color:#fa5c4b>Context</span><span>, </span><span style=color:#fdf4c1>request </span><span style=color:#fa5c4b>interface</span><span>{}) (</span><span style=color:#fa5c4b>interface</span><span>{}, </span><span style=color:#fabd2f>error</span><span>) {
</span><span>		</span><span style=color:#fdf4c1>req </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>request</span><span>.(</span><span style=color:#fa5c4b>uppercaseRequest</span><span>)
</span><span>		</span><span style=color:#fdf4c1>v</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>svc</span><span>.</span><span style=color:#fdf4c1>Uppercase</span><span>(</span><span style=color:#fdf4c1>req</span><span>.</span><span style=color:#fdf4c1>S</span><span>)
</span><span>		</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>			</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>uppercaseResponse</span><span>{</span><span style=color:#fdf4c1>v</span><span>, </span><span style=color:#fdf4c1>err</span><span>.</span><span style=color:#fdf4c1>Error</span><span>()}, </span><span style=color:#d3869b>nil
</span><span>		}
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>uppercaseResponse</span><span>{</span><span style=color:#fdf4c1>v</span><span>, </span><span style=color:#b8bb26>""</span><span>}, </span><span style=color:#d3869b>nil
</span><span>	}
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>makeCountEndpoint</span><span>(</span><span style=color:#fdf4c1>svc </span><span style=color:#fa5c4b>StringService</span><span>) </span><span style=color:#fdf4c1>endpoint</span><span>.</span><span style=color:#fa5c4b>Endpoint </span><span>{
</span><span>	</span><span style=color:#fa5c4b>return func</span><span>(</span><span style=color:#fdf4c1>_ context</span><span>.</span><span style=color:#fa5c4b>Context</span><span>, </span><span style=color:#fdf4c1>request </span><span style=color:#fa5c4b>interface</span><span>{}) (</span><span style=color:#fa5c4b>interface</span><span>{}, </span><span style=color:#fabd2f>error</span><span>) {
</span><span>		</span><span style=color:#fdf4c1>req </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>request</span><span>.(</span><span style=color:#fa5c4b>countRequest</span><span>)
</span><span>		</span><span style=color:#fdf4c1>v </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>svc</span><span>.</span><span style=color:#fdf4c1>Count</span><span>(</span><span style=color:#fdf4c1>req</span><span>.</span><span style=color:#fdf4c1>S</span><span>)
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>countResponse</span><span>{</span><span style=color:#fdf4c1>v</span><span>}, </span><span style=color:#d3869b>nil
</span><span>	}
</span><span>}
</span></code></pre><p>对于写过 rpcx 或者 gRPC 的朋友来说，Endpoint 更像是个脱裤子放屁的封装。只要把接口参数约定成 <code>func (ctx context.Context, req interface{}) (interface{}, error)</code> 不就完了？传输层收到的请求解码成本地数据类型，然后按约定传入，就万事大吉了。<p>空口无凭，不如看看如果不要 endpoint，实际编写的代码会变成什么样。<p>像是 go kit 提供的这种帮助函数：<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fdf4c1>uppercaseHandler </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>httptransport</span><span>.</span><span style=color:#fdf4c1>NewServer</span><span>(
</span><span>    </span><span style=color:#fdf4c1>makeUppercaseEndpoint</span><span>(</span><span style=color:#fdf4c1>svc</span><span>),
</span><span>    </span><span style=color:#fdf4c1>decodeUppercaseRequest</span><span>,
</span><span>    </span><span style=color:#fdf4c1>encodeResponse</span><span>,
</span><span>)
</span><span>
</span><span style=color:#fdf4c1>countHandler </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>httptransport</span><span>.</span><span style=color:#fdf4c1>NewServer</span><span>(
</span><span>    </span><span style=color:#fdf4c1>makeCountEndpoint</span><span>(</span><span style=color:#fdf4c1>svc</span><span>),
</span><span>    </span><span style=color:#fdf4c1>decodeCountRequest</span><span>,
</span><span>    </span><span style=color:#fdf4c1>encodeResponse</span><span>,
</span><span>)
</span></code></pre><p>可能就会变成这样：<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fdf4c1>uppercaseHandler </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>httptransport</span><span>.</span><span style=color:#fdf4c1>NewServer</span><span>(
</span><span>    </span><span style=color:#fdf4c1>svc</span><span>.</span><span style=color:#fdf4c1>Uppercase</span><span>,
</span><span>    </span><span style=color:#fdf4c1>decodeUppercaseRequest</span><span>,
</span><span>    </span><span style=color:#fdf4c1>encodeResponse</span><span>,
</span><span>)
</span><span>
</span><span style=color:#fdf4c1>countHandler </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>httptransport</span><span>.</span><span style=color:#fdf4c1>NewServer</span><span>(
</span><span>    </span><span style=color:#fdf4c1>svc</span><span>.</span><span style=color:#fdf4c1>Count</span><span>,
</span><span>    </span><span style=color:#fdf4c1>decodeCountRequest</span><span>,
</span><span>    </span><span style=color:#fdf4c1>encodeResponse</span><span>,
</span><span>)
</span></code></pre><p>当然，为了让 Go 语言的类型系统开心，这里的 <code>svc.Uppercase</code> 和 <code>svc.Count</code> 得是一样的签名，或者用 <code>interface{}</code> 做形参，又或者考虑还没有发布的泛型能不能支持。<p>看起来是舒服了很多对吧？Endpoint 没了。但还有个问题：中间件。要怎么实现通用的中间件，应用在每个原本应该是 Endpoint 的地方？<p>例如在微服务系统里很常见的分布式跟踪、metrics收集，无论最终采用的是 opentracing、opencecus、opentelemetry 还是 zipkin、prometheus，跟踪调用链路是一个很基本的可观测性要求。当然，你可以说用 linkerd 一类的 service mesh 解决方案（虽然我觉得不能替代上面提到的这些东西），但也应该有所警惕：我们是不是还有需要在每个接口上都执行、和传输层无关的代码？对，还有身份验证和鉴权工作。还有吗？<p>当然，也不是脱离了 Endpoint 就别无他法，只是在需要的时候，我想总还是会有意无意抽象出一个类似 endpoint 的层级——可能隐藏在 service 中间件里，也可能交给了传输层。可能写得更好，也可能又是在堆屎山。经验告诉我在一个需要长期支持的系统里，人是靠不住的，但规范可以。endpoint 并没有牺牲多少编码上的自由度，但一定程度上避免了潜在的堆屎可能，我觉得完全可以接受。<h2 id=generic-hui-ru-he-ying-xiang-go-kit-jia-gou>generic 会如何影响 go kit 架构</h2><p>我直说，Go 的泛型（beta1）就是一泡狗屎，我向来不喜欢 Go 团队的品味，从 slice 和 interface{} 泄露语言的实现细节到其他更离谱的东西。但现在 Go 泛型还没有正式公布（预期就在本月），现在我也没什么好评论的。<p>generic 会影响 go kit 的架构吗？我的看法是不会。泛型也许能极大帮助各种容器类型、迭代器之类饱受 <code>interface{}</code> 折磨的组件，但是 go kit 用得上泛型的地方其实不多。少数常见的 <code>interface{}</code> 场合，都是在从一个类型适配到另一个类型，代码编写者清楚自己要处理的两个类型，但 go kit 不知道。<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>makeUppercaseEndpoint</span><span>(</span><span style=color:#fdf4c1>svc </span><span style=color:#fa5c4b>StringService</span><span>) </span><span style=color:#fdf4c1>endpoint</span><span>.</span><span style=color:#fa5c4b>Endpoint </span><span>{
</span><span>	</span><span style=color:#fa5c4b>return func</span><span>(</span><span style=color:#fdf4c1>_ context</span><span>.</span><span style=color:#fa5c4b>Context</span><span>, </span><span style=color:#fdf4c1>request </span><span style=color:#fa5c4b>interface</span><span>{}) (</span><span style=color:#fa5c4b>interface</span><span>{}, </span><span style=color:#fabd2f>error</span><span>) {
</span><span>		</span><span style=color:#fdf4c1>req </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>request</span><span>.(</span><span style=color:#fa5c4b>uppercaseRequest</span><span>)
</span><span>		</span><span style=color:#fdf4c1>v</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>svc</span><span>.</span><span style=color:#fdf4c1>Uppercase</span><span>(</span><span style=color:#fdf4c1>req</span><span>.</span><span style=color:#fdf4c1>S</span><span>)
</span><span>		</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>			</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>uppercaseResponse</span><span>{</span><span style=color:#fdf4c1>v</span><span>, </span><span style=color:#fdf4c1>err</span><span>.</span><span style=color:#fdf4c1>Error</span><span>()}, </span><span style=color:#d3869b>nil
</span><span>		}
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>uppercaseResponse</span><span>{</span><span style=color:#fdf4c1>v</span><span>, </span><span style=color:#b8bb26>""</span><span>}, </span><span style=color:#d3869b>nil
</span><span>	}
</span><span>}
</span></code></pre><p>这部分适配代码如果把 <code>interface{}</code> 替换成具体的 <code>uppercaseRequest</code> 和 <code>uppercaseResponse</code> 的话，就需要 go kit 提供泛型形式的 Endpoint 接口了，像是这样：<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>Endpoint</span><span>[</span><span style=color:#fdf4c1>RequestType</span><span>,</span><span style=color:#fdf4c1>ResponseType</span><span>] </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>func</span><span>(</span><span style=color:#fdf4c1>context</span><span>.</span><span style=color:#fa5c4b>Context</span><span>, </span><span style=color:#fa5c4b>RequestType</span><span>) (</span><span style=color:#fa5c4b>ResponseType</span><span>, </span><span style=color:#fabd2f>error</span><span>)
</span></code></pre><p>上面的代码有效无效先不说，我记得在 beta1 尝试泛型的时候发现 Go 在推断类型的时候存在问题，这个 <code>RequestType</code> 和 <code>ResponseType</code> 在实际用的时候怕是要写不止一次。又是 Go 特色的啰嗦。<p>可即便是这样恐怕还有问题，如果修改了 <code>Endpoint</code> 的签名，那么 <code>endpoint.Middleware</code> 恐怕也要泛型化，原来的所有中间件库，<code>trace</code>、<code>auth</code>、<code>metrics</code> 可能也得做泛型化改造。对一个已经深度开发过的系统来说，为了这一点类型检查的好处付出如此代价恐怕是不能接受的。<p>总而言之，我的观点是 Generic 可能带来变化，但根本上的几个抽象不大可能跟着重构，这是由 go kit 性质决定的。<h2 id=go-kit-dai-ma-sheng-cheng>go kit 代码生成</h2><p>但凡跟着 go kit 写过一个 stringsvc 的人都会感觉到 go kit 有多少样板代码，适配传输层需要编写 encode/decode，本地结构转函数签名所需的参数又要一次转换，传输层协议监听、注册<code>Handler</code>、客户端连接都要自己编写代码，构造和注册 <code>Endpoint</code> 复杂性无非是从 <code>func main</code> 移动到 <code>transport</code> 或者反过来，尽管很烦，但又无法根本上消除。<p>如果是 C++ 恐怕会有模板元编程大佬晒自己的 <code>template</code>，但 Go 基本没有编译时和运行时的元编程能力。唯一比较擅长的就只有个代码生成了。Go 提供的 <code>ast/parser</code> 包很赞，别的语言少有提供这么方便的接口的。<p>go kit 的代码生成，从目前体验中感受来看，主要是需要下面的功能：<ol><li>从 <code>interface</code> 定义生成对应的 <code>makeEndpoint</code> 函数和请求/响应结构体。这部分代码基本没什么特别的。<li>从 <code>interface</code> 定义生成对应的 <code>transport</code> 包，可以自己选择协议。主要解决 encode/decode 手写麻烦的问题。<li>从 <code>interface</code> 定义生成服务构造和启动代码，应用可以自己构造，但 <code>endpoint</code> 的构造和 <code>middleware</code> 的应用就可以不用自己写了。</ol><p>这三处的样板代码最多，而且代码本身并不特别，都是简单地对类型进行适配，手写完全是浪费时间，还会引入人为的不确定性，不如让机器搞定。目前考察过的 <a href=https://github.com/GrantZheng/kit>kit</a> 实现了其中一大部分，但 transport 支持太少，也没有生成注册 endpoint 的代码，依然存在很多手写的样板代码。我简单看了下实现，用 <a href=https://github.com/dave/jennifer>jennifer</a> 生成代码好是挺好，就是 go 代码显得有点乱 ...<p>我寻思对 generator 简单重构下实现关注点分离的话，还是能满足上面提到的这些东西的。最好的情况是定义好 interface 之后，生成代码，编写主函数，就能直接运行了。同时又不伤害 go kit 架构本身的扩展性和可定制性。<h2 id=zong-jie>总结</h2><p><img alt="go kit架构的服务" src=https://nnnewb.github.io/posts/2022/my-opinion-of-gokit-architecture/image-20220302154943857.webp><p>蛮喜欢 go kit 项目作者的一句话：<p><img alt=issue截图 src=https://nnnewb.github.io/posts/2022/my-opinion-of-gokit-architecture/image-20220302155216922.webp><blockquote><p>Honestly the best way to "use" Go kit is to cop it's architectural model and not actually import any of its packages at all 😉</blockquote><p>其实我也想把这套架构搬进项目里，可惜条件不允许，还有更严重的问题要处理，只能先眼馋一下，吸收下精神。</article><p class=tags-data><a href=/tags/go-kit>/go-kit/</a> <a href=/tags/golang>/golang/</a> <a href=/tags/wei-fu-wu>/微服务/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>