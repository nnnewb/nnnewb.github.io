<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>codegen 利器 go/types</title><meta content="codegen 利器 go/types" name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2022/gotypes-for-codegen/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content="codegen 利器 go/types" property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2022/gotypes-for-codegen/ property=twitter:url><meta content="codegen 利器 go/types" property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2022/gotypes-for-codegen/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>codegen 利器 go/types</h1><p class=author-line>作于：2022-04-11 13:00 ，预计阅读时间 6 分钟<article><h2 id=qian-yan>前言</h2><p>本篇博客主要想介绍下 <code>go/types</code> 这个包。<p>目前关于 go 代码生成比较常见的是利用 <code>go/ast</code> ，结合 <code>text/template</code> 生成代码。这种生成方式显然是有局限性的：<code>go/ast</code> 这个包只能拿到语法树结构，但没有类型信息。比如 <code>var ctx context.Context</code> 可以解析成语法树节点 <code>ast.GenDecl</code>，但<code>context.Context</code> 只能解析出 <code>ast.SelectorExpr</code>，并不知道 <code>context.Context</code> 是一个 <code>struct</code>、<code>interface</code>还是<code>alias</code>。<p>在面对简单的代码生成时<code>go/ast</code>还能顶一下，但更复杂一点的需求，比如说根据 <code>struct</code> 生成 <code>thrift</code> 或者 <code>protobuf</code> 定义，<code>go/ast</code> 就有点吃力不讨好了。<h2 id=ru-men>入门</h2><p>注意这块没照搬官方的 example，因为官方的 example 主要注重在怎么用 <code>go/types</code> 做类型检查，关注 <code>types.Config</code> 和 <code>types.Checker</code>，但我不是很想管 <code>checker</code> 怎么样，我们的目的是写个 codegen，想办法拿到更丰富的类型信息。<p>因此 <code>go/types</code> 的使用更关注的是其中的数据结构。<h3 id=lei-xing-xi-tong>类型系统</h3><p>先来个基本的例子。<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>package </span><span style=color:#fdf4c1>main
</span><span>
</span><span style=color:#fa5c4b>import </span><span>(
</span><span>	</span><span style=color:#b8bb26>"flag"
</span><span>	</span><span style=color:#b8bb26>"fmt"
</span><span>	</span><span style=color:#b8bb26>"go/importer"
</span><span>	</span><span style=color:#b8bb26>"go/token"
</span><span>	</span><span style=color:#b8bb26>"go/types"
</span><span>	</span><span style=color:#b8bb26>"log"
</span><span>)
</span><span>
</span><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>main</span><span>() {
</span><span>	</span><span style=color:#fa5c4b>var </span><span style=color:#fdf4c1>pkgPath </span><span style=color:#fabd2f>string
</span><span>	</span><span style=color:#fa5c4b>var </span><span style=color:#fdf4c1>typ </span><span style=color:#fabd2f>string
</span><span>	</span><span style=color:#fdf4c1>flag</span><span>.</span><span style=color:#fdf4c1>StringVar</span><span>(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>pkgPath</span><span>, </span><span style=color:#b8bb26>"package"</span><span>, </span><span style=color:#b8bb26>""</span><span>, </span><span style=color:#b8bb26>"package path"</span><span>)
</span><span>	</span><span style=color:#fdf4c1>flag</span><span>.</span><span style=color:#fdf4c1>StringVar</span><span>(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>typ</span><span>, </span><span style=color:#b8bb26>"type"</span><span>, </span><span style=color:#b8bb26>""</span><span>, </span><span style=color:#b8bb26>"type name"</span><span>)
</span><span>	</span><span style=color:#fdf4c1>flag</span><span>.</span><span style=color:#fdf4c1>Parse</span><span>()
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>pkgPath </span><span style=color:#fe8019>== </span><span style=color:#b8bb26>"" </span><span>{
</span><span>		</span><span style=color:#fabd2f>println</span><span>(</span><span style=color:#b8bb26>"-package is required"</span><span>)
</span><span>		</span><span style=color:#fdf4c1>flag</span><span>.</span><span style=color:#fdf4c1>Usage</span><span>()
</span><span>		</span><span style=color:#fa5c4b>return
</span><span>	}
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>typ </span><span style=color:#fe8019>== </span><span style=color:#b8bb26>"" </span><span>{
</span><span>		</span><span style=color:#fabd2f>println</span><span>(</span><span style=color:#b8bb26>"-type is required"</span><span>)
</span><span>		</span><span style=color:#fdf4c1>flag</span><span>.</span><span style=color:#fdf4c1>Usage</span><span>()
</span><span>		</span><span style=color:#fa5c4b>return
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#fdf4c1>fst </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>token</span><span>.</span><span style=color:#fdf4c1>NewFileSet</span><span>()
</span><span>	</span><span style=color:#fdf4c1>imp </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>importer</span><span>.</span><span style=color:#fdf4c1>ForCompiler</span><span>(</span><span style=color:#fdf4c1>fst</span><span>, </span><span style=color:#b8bb26>"source"</span><span>, </span><span style=color:#d3869b>nil</span><span>)
</span><span>	</span><span style=color:#fdf4c1>pkg</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>imp</span><span>.</span><span style=color:#fdf4c1>Import</span><span>(</span><span style=color:#fdf4c1>pkgPath</span><span>)
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>		</span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>Fatal</span><span>(</span><span style=color:#fdf4c1>err</span><span>)
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#fdf4c1>typename </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>pkg</span><span>.</span><span style=color:#fdf4c1>Scope</span><span>().</span><span style=color:#fdf4c1>Lookup</span><span>(</span><span style=color:#fdf4c1>typ</span><span>)
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>typename </span><span style=color:#fe8019>== </span><span style=color:#d3869b>nil </span><span>{
</span><span>		</span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>Fatalf</span><span>(</span><span style=color:#b8bb26>"type </span><span style=color:#fdf4c1>%s</span><span style=color:#b8bb26> not found"</span><span>, </span><span style=color:#fdf4c1>typ</span><span>)
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>named</span><span>, </span><span style=color:#fdf4c1>ok </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>typename</span><span>.</span><span style=color:#fdf4c1>Type</span><span>().(</span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>types</span><span>.</span><span style=color:#fa5c4b>Named</span><span>); </span><span style=color:#fdf4c1>ok </span><span>{
</span><span>		</span><span style=color:#fa5c4b>switch </span><span style=color:#fdf4c1>named</span><span>.</span><span style=color:#fdf4c1>Underlying</span><span>().(</span><span style=color:#fa5c4b>type</span><span>) {
</span><span>		</span><span style=color:#fa5c4b>case </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>types</span><span>.</span><span style=color:#fdf4c1>Basic</span><span>:
</span><span>			</span><span style=color:#fabd2f>println</span><span>(</span><span style=color:#b8bb26>"primitive type"</span><span>)
</span><span>		</span><span style=color:#fa5c4b>case </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>types</span><span>.</span><span style=color:#fdf4c1>Interface</span><span>:
</span><span>			</span><span style=color:#fabd2f>println</span><span>(</span><span style=color:#b8bb26>"interface type"</span><span>)
</span><span>		</span><span style=color:#fa5c4b>case </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>types</span><span>.</span><span style=color:#fdf4c1>Struct</span><span>:
</span><span>			</span><span style=color:#fabd2f>println</span><span>(</span><span style=color:#b8bb26>"struct type"</span><span>)
</span><span>		</span><span style=color:#fa5c4b>default</span><span>:
</span><span>			</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>named</span><span>.</span><span style=color:#fdf4c1>Obj</span><span>().</span><span style=color:#fdf4c1>IsAlias</span><span>() {
</span><span>				</span><span style=color:#fabd2f>println</span><span>(</span><span style=color:#b8bb26>"is alias type"</span><span>)
</span><span>				</span><span style=color:#fa5c4b>return
</span><span>			}
</span><span>			</span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Printf</span><span>(</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>%v</span><span style=color:#b8bb26>"</span><span>, </span><span style=color:#fdf4c1>named</span><span>)
</span><span>		}
</span><span>	}
</span><span>}
</span><span>
</span></code></pre><p>很短，注意几个新出现的包和API：<code>go/importer</code>、<code>go/types</code>。<p><code>go/importer</code>顾名思义是一个管理<code>import</code>功能的包，go 不是 python 这样解释执行或 Java 那样可以热加载代码的模型，<code>importer</code>基本是编译期才会用到。我们用<code>importer.ForCompiler</code>的目的是构造一个 <code>Importer</code>， <strong>从源代码</strong> 拿到类型信息。<p>从<code>Import</code>调用拿到一个 <code>*types.Package</code> 类型的返回值后，又使用 <code>Scope().Lookup()</code>从这个包作用域下查找指定的类型——这里提一嘴，<code>type xxx struct{}</code>这样的语句可以是块作用域的，<code>Scope().Lookup()</code>查找的是 <strong>包内的全局类型定义</strong> ，查找结果是一个 <code>types.Object</code>，可以理解成一个有类型的对象——比如全局 <code>var v int</code> 这样声明的 <code>v</code>。对于查找的是类型的情况，需要关注的就是 <code>.Type()</code>这个方法了。<p>顾名思义<code>.Type()</code>返回对象的类型，代码里的 type switch 应该很好地展示了整个过程。<p>另外还要注意到 <code>.(*types.Named)</code>，这里涉及一个 <code>named type</code>概念。所谓的 <code>Named</code> 在 <a href=https://go.dev/ref/spec#Types>Go Specification 里是这样解释的</a>：<blockquote><p><strong>Predeclared types</strong>, <strong>defined types</strong>, and <strong>type parameters</strong> are called <em>named types</em>. An alias denotes a named type if the type given in the alias declaration is a named type.</blockquote><p>什么意思呢？<code>predeclared types</code> 指的是内置的类型，如 <code>int</code>、<code>byte</code>、<code>rune</code>，参考链接 <a href=https://go.dev/ref/spec#Predeclared_identifiers>predeclares</a> 。而 <code>defined types</code> 指的是形如 <code>type Sample struct {}</code> 的类型定义，<code>type parameters</code> 则是 go 1.18 引入的泛型语法，例如 <code>type Sample[T any] struct {t T}</code> ，其中的<code>T</code>也是 <code>named type</code>。<p>那什么样的不是 <code>named type</code>呢？比如<code>type Sample = struct {}</code>，这里的 <code>Sample</code> 就不是 <code>named type</code>。注意前面引文的后半句：<blockquote><p>An alias denotes a named type if the type given in the alias declaration is a named type.</blockquote><p>只有<code>named type</code>的别名才被视为<code>named type</code>，所以 <code>type Sample = int</code> 是 <code>named type</code>，但 <code>type Sample = struct{}</code> 或者 <code>type Sample = map[string]string</code> 都不是 <code>named type</code>。<p>好了，绕晕了就可以继续下一阶段了，开始了解 <code>Field</code> 和 <code>Method</code>。<h3 id=field>Field</h3><p>我们稍微改一下上面的代码，在 <code>case *types.Struct</code> 下加入几行循环。记得 <code>switch</code>也改成<code>switch tp := named.Underlying().(type)</code><pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>i </span><span style=color:#fe8019>:= </span><span style=color:#d3869b>0</span><span>; </span><span style=color:#fdf4c1>i </span><span style=color:#fe8019>&lt; </span><span style=color:#fdf4c1>tp</span><span>.</span><span style=color:#fdf4c1>NumFields</span><span>(); </span><span style=color:#fdf4c1>i</span><span style=color:#fe8019>++ </span><span>{
</span><span>    </span><span style=color:#fdf4c1>field </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>tp</span><span>.</span><span style=color:#fdf4c1>Field</span><span>(</span><span style=color:#fdf4c1>i</span><span>)
</span><span>    </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Printf</span><span>(</span><span style=color:#b8bb26>"field </span><span style=color:#fdf4c1>%s %v</span><span style=color:#b8bb26>\n"</span><span>, </span><span style=color:#fdf4c1>field</span><span>.</span><span style=color:#fdf4c1>Name</span><span>(), </span><span style=color:#fdf4c1>field</span><span>.</span><span style=color:#fdf4c1>Type</span><span>())
</span><span>}
</span></code></pre><p>又一个惯用法：<code>NumFields</code> 和 <code>Field</code>。注意<code>Field</code>拿到的是一个 <code>*types.Var</code>，可以认为表示一个变量，而<code>field.Type()</code>得到的就是这个变量的类型。<p>有了类型数据，我们就可以有的放矢，决定如何生成 <code>field</code> 对应的代码了。<h3 id=method>Method</h3><p>另一种常见的情况是基于 <code>interface</code> 生成实现，比如 <code>go-kit</code> 那海量的样板代码。<p>我们稍微改下上面的代码。<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>i </span><span style=color:#fe8019>:= </span><span style=color:#d3869b>0</span><span>; </span><span style=color:#fdf4c1>i </span><span style=color:#fe8019>&lt; </span><span style=color:#fdf4c1>tp</span><span>.</span><span style=color:#fdf4c1>NumMethods</span><span>(); </span><span style=color:#fdf4c1>i</span><span style=color:#fe8019>++ </span><span>{
</span><span>    </span><span style=color:#fdf4c1>method </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>tp</span><span>.</span><span style=color:#fdf4c1>Method</span><span>(</span><span style=color:#fdf4c1>i</span><span>)
</span><span>    </span><span style=color:#fdf4c1>signature </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>method</span><span>.</span><span style=color:#fdf4c1>Type</span><span>().(</span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>types</span><span>.</span><span style=color:#fa5c4b>Signature</span><span>)
</span><span>    </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Printf</span><span>(</span><span style=color:#b8bb26>"func (r Sample) </span><span style=color:#fdf4c1>%s</span><span style=color:#b8bb26>("</span><span>, </span><span style=color:#fdf4c1>method</span><span>.</span><span style=color:#fdf4c1>Name</span><span>())
</span><span>    </span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>i </span><span style=color:#fe8019>:= </span><span style=color:#d3869b>0</span><span>; </span><span style=color:#fdf4c1>i </span><span style=color:#fe8019>&lt; </span><span style=color:#fdf4c1>signature</span><span>.</span><span style=color:#fdf4c1>Params</span><span>().</span><span style=color:#fdf4c1>Len</span><span>(); </span><span style=color:#fdf4c1>i</span><span style=color:#fe8019>++ </span><span>{
</span><span>        </span><span style=color:#fdf4c1>param </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>signature</span><span>.</span><span style=color:#fdf4c1>Params</span><span>().</span><span style=color:#fdf4c1>At</span><span>(</span><span style=color:#fdf4c1>i</span><span>)
</span><span>        </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Printf</span><span>(</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>%s %v</span><span style=color:#b8bb26>,"</span><span>, </span><span style=color:#fdf4c1>param</span><span>.</span><span style=color:#fdf4c1>Name</span><span>(), </span><span style=color:#fdf4c1>param</span><span>.</span><span style=color:#fdf4c1>Type</span><span>())
</span><span>    }
</span><span>    </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Print</span><span>(</span><span style=color:#b8bb26>")"</span><span>)
</span><span>    </span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>signature</span><span>.</span><span style=color:#fdf4c1>Results</span><span>().</span><span style=color:#fdf4c1>Len</span><span>() </span><span style=color:#fe8019>> </span><span style=color:#d3869b>1 </span><span>{
</span><span>        </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Print</span><span>(</span><span style=color:#b8bb26>" ("</span><span>)
</span><span>    }
</span><span>    </span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>i </span><span style=color:#fe8019>:= </span><span style=color:#d3869b>0</span><span>; </span><span style=color:#fdf4c1>i </span><span style=color:#fe8019>&lt; </span><span style=color:#fdf4c1>signature</span><span>.</span><span style=color:#fdf4c1>Results</span><span>().</span><span style=color:#fdf4c1>Len</span><span>(); </span><span style=color:#fdf4c1>i</span><span style=color:#fe8019>++ </span><span>{
</span><span>        </span><span style=color:#fdf4c1>result </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>signature</span><span>.</span><span style=color:#fdf4c1>Results</span><span>().</span><span style=color:#fdf4c1>At</span><span>(</span><span style=color:#fdf4c1>i</span><span>)
</span><span>        </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Printf</span><span>(</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>%s %v</span><span style=color:#b8bb26>"</span><span>, </span><span style=color:#fdf4c1>result</span><span>.</span><span style=color:#fdf4c1>Name</span><span>(), </span><span style=color:#fdf4c1>result</span><span>.</span><span style=color:#fdf4c1>Type</span><span>())
</span><span>        </span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>i</span><span style=color:#fe8019>+</span><span style=color:#d3869b>1 </span><span style=color:#fe8019>&lt; </span><span style=color:#fdf4c1>signature</span><span>.</span><span style=color:#fdf4c1>Params</span><span>().</span><span style=color:#fdf4c1>Len</span><span>() {
</span><span>            </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Print</span><span>(</span><span style=color:#b8bb26>","</span><span>)
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>signature</span><span>.</span><span style=color:#fdf4c1>Results</span><span>().</span><span style=color:#fdf4c1>Len</span><span>() </span><span style=color:#fe8019>> </span><span style=color:#d3869b>1 </span><span>{
</span><span>        </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Print</span><span>(</span><span style=color:#b8bb26>" )"</span><span>)
</span><span>    }
</span><span>    </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Print</span><span>(</span><span style=color:#b8bb26>" {\n\tpanic(errors.New(\"Not implemented!\"))\n}\n\n"</span><span>)
</span><span>}
</span></code></pre><p>并不复杂！<p>遍历 interface 下的所有方法，然后把 <code>Params</code> 和 <code>Results</code> 挨个打印出来，函数体里放一个 <code>panic(errors.New("Not implemented!"))</code>，就是这样！<p>最后输出像是这样：<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>r </span><span style=color:#fa5c4b>Sample</span><span>) </span><span style=color:#8ec07c>FirstName</span><span>() </span><span style=color:#fabd2f>string </span><span>{
</span><span>        </span><span style=color:#fabd2f>panic</span><span>(</span><span style=color:#fdf4c1>errors</span><span>.</span><span style=color:#fdf4c1>New</span><span>(</span><span style=color:#b8bb26>"Not implemented!"</span><span>))
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>r </span><span style=color:#fa5c4b>Sample</span><span>) </span><span style=color:#8ec07c>LastName</span><span>() </span><span style=color:#fabd2f>string </span><span>{
</span><span>        </span><span style=color:#fabd2f>panic</span><span>(</span><span style=color:#fdf4c1>errors</span><span>.</span><span style=color:#fdf4c1>New</span><span>(</span><span style=color:#b8bb26>"Not implemented!"</span><span>))
</span><span>}
</span></code></pre><p>值得注意的是，<code>Method</code>返回的是 <code>*types.Func</code>，但 <code>Params</code>和<code>Results</code>并不是<code>types.Func</code>上的方法，而是 <code>types.Signature</code>。官方文档说 <code>Func</code>的<code>Type()</code>返回的必然是 <code>*types.Signature</code>，所以直接断言也是安全的。<h2 id=zong-jie>总结</h2><p>参考官方的文档 <a href=https://github.com/golang/example/tree/master/gotypes>gotypes</a><p>重点就一个：不要用 <code>go/types</code> 下的 <code>Config</code> 和 <code>Checker</code>，用 <code>importer.ForCompiler</code> 从源码获取类型数据。<code>types</code>用起来个人感觉比 <code>go/ast</code> 方便，缺点是因为引入类型会导致解析源码各方面的消耗增加，算是一个我个人比较偏好的 trade-off 吧。在 codegen 的输入类型比较复杂敏感的时候，拿 <code>go/types</code> 替代 <code>go/ast</code> 可以省下很多工作量。</article><p class=tags-data><a href=/tags/golang>/golang/</a> <a href=/tags/codegen>/codegen/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>