<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>gRPC-Gateway 用作多个 gRPC 服务的网关</title><meta content="gRPC-Gateway 用作多个 gRPC 服务的网关" name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2022/grpc-gateway-used-as-multiple-grpc-server-gateway/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content="gRPC-Gateway 用作多个 gRPC 服务的网关" property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2022/grpc-gateway-used-as-multiple-grpc-server-gateway/ property=twitter:url><meta content="gRPC-Gateway 用作多个 gRPC 服务的网关" property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2022/grpc-gateway-used-as-multiple-grpc-server-gateway/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>gRPC-Gateway 用作多个 gRPC 服务的网关</h1><p class=author-line>作于：2022-02-23 17:30 ，预计阅读时间 7 分钟<article><h2 id=qian-yan>前言</h2><p>众所周知，API网关是微服务架构的重要组件，起到一个整流过滤的作用。虽然 gRPC-Gateway 要啥没啥，和 API 网关的模式也扯不上太多关系，但总之先起个高调。<p>然后就是真正遇到的问题了。在旧的架构里，gRPC-Gateway 的用法，是对每个需要暴露 HTTP 服务的 gRPC 服务都起一个对应的 gRPC-Gateway 。最早的做法是 gRPC-Gateway 服务单独作为一个 POD ，gRPC 服务实现也单独一个 POD 。后来我改成了 Gateway 和 服务在同一个 POD 内，起两个 container 。<p>之前的做法都存在一个问题，就是 gRPC-Gateway 要分配少量的 CPU 和内存配额，虽然每个 gRPC-Gateway 服务分到的内存和CPU都很少，但架不住服务多，内存和 CPU 的配额都占用了不少，实际用到的少得可怜，大部分配额都是浪费。<p>下面具体分析下怎么把 gateway 单独提取成一个 POD，给所有 gRPC 服务当网关，同时保持负载均衡发挥作用，提供无缝扩容。<h2 id=shi-xian-wang-guan>实现网关</h2><h3 id=guan-fang-demo>官方demo</h3><pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#928374;font-style:italic>// Create a client connection to the gRPC server we just started
</span><span style=color:#928374;font-style:italic>// This is where the gRPC-Gateway proxies the requests
</span><span style=color:#fdf4c1>conn</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>grpc</span><span>.</span><span style=color:#fdf4c1>DialContext</span><span>(
</span><span>    </span><span style=color:#fdf4c1>context</span><span>.</span><span style=color:#fdf4c1>Background</span><span>(),
</span><span>    </span><span style=color:#b8bb26>"0.0.0.0:8080"</span><span>,
</span><span>    </span><span style=color:#fdf4c1>grpc</span><span>.</span><span style=color:#fdf4c1>WithBlock</span><span>(),
</span><span>    </span><span style=color:#fdf4c1>grpc</span><span>.</span><span style=color:#fdf4c1>WithTransportCredentials</span><span>(</span><span style=color:#fdf4c1>insecure</span><span>.</span><span style=color:#fdf4c1>NewCredentials</span><span>()),
</span><span>)
</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>    </span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>Fatalln</span><span>(</span><span style=color:#b8bb26>"Failed to dial server:"</span><span>, </span><span style=color:#fdf4c1>err</span><span>)
</span><span>}
</span><span>
</span><span style=color:#fdf4c1>gwmux </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>runtime</span><span>.</span><span style=color:#fdf4c1>NewServeMux</span><span>()
</span><span style=color:#928374;font-style:italic>// Register Greeter
</span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>helloworldpb</span><span>.</span><span style=color:#fdf4c1>RegisterGreeterHandler</span><span>(</span><span style=color:#fdf4c1>context</span><span>.</span><span style=color:#fdf4c1>Background</span><span>(), </span><span style=color:#fdf4c1>gwmux</span><span>, </span><span style=color:#fdf4c1>conn</span><span>)
</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>    </span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>Fatalln</span><span>(</span><span style=color:#b8bb26>"Failed to register gateway:"</span><span>, </span><span style=color:#fdf4c1>err</span><span>)
</span><span>}
</span><span>
</span><span style=color:#fdf4c1>gwServer </span><span style=color:#fe8019>:= &</span><span style=color:#fdf4c1>http</span><span>.</span><span style=color:#fdf4c1>Server</span><span>{
</span><span>    </span><span style=color:#fdf4c1>Addr</span><span>:    </span><span style=color:#b8bb26>":8090"</span><span>,
</span><span>    </span><span style=color:#fdf4c1>Handler</span><span>: </span><span style=color:#fdf4c1>gwmux</span><span>,
</span><span>}
</span><span>
</span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>Println</span><span>(</span><span style=color:#b8bb26>"Serving gRPC-Gateway on http://0.0.0.0:8090"</span><span>)
</span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>Fatalln</span><span>(</span><span style=color:#fdf4c1>gwServer</span><span>.</span><span style=color:#fdf4c1>ListenAndServe</span><span>())
</span></code></pre><p>核心逻辑在这两行：<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fdf4c1>gwmux </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>runtime</span><span>.</span><span style=color:#fdf4c1>NewServeMux</span><span>()
</span><span style=color:#928374;font-style:italic>// Register Greeter
</span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>helloworldpb</span><span>.</span><span style=color:#fdf4c1>RegisterGreeterHandler</span><span>(</span><span style=color:#fdf4c1>context</span><span>.</span><span style=color:#fdf4c1>Background</span><span>(), </span><span style=color:#fdf4c1>gwmux</span><span>, </span><span style=color:#fdf4c1>conn</span><span>)
</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>    </span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>Fatalln</span><span>(</span><span style=color:#b8bb26>"Failed to register gateway:"</span><span>, </span><span style=color:#fdf4c1>err</span><span>)
</span><span>}
</span></code></pre><p><code>gwmux</code>是 gRPC-Gateway 的运行时 <code>mux</code> 实例，可以理解成路由。 标准库的 <code>http</code> 包也有自己的 <code>mux</code> ，但 gRPC-Gateway 项目自己实现了一个。看到 <code>gwmux</code>应该就能想到这肯定是注册路由，理论上来说——如果你有多个 gRPC 服务，而且 url 没有冲突的话，注册多个服务到路由上应该是没有问题的。<p>所以剩下的问题就是这个 <code>RegisterGreeterHandler</code> 内是不是我们预期的那样，类似 <code>mux</code> 注册路由的用法？<h3 id=registerxxxhandlerclient-shi-xian>RegisterXXXHandlerClient 实现</h3><p><img alt=RegisterXXXHandlerClient实现 src=https://nnnewb.github.io/posts/2022/grpc-gateway-used-as-multiple-grpc-server-gateway/image-20220222154718918.webp><p>顺着 <code>RegisterXXXHandler</code>很快就能找到实现，<code>RegisterXXXHandlerClient</code>。<code>Handle</code>的用法正如预期的那样，是一个类似 <code>http.ServeMux</code> 的对象。处理函数里的逻辑很清晰。<p><img alt=HandleFunc src=https://nnnewb.github.io/posts/2022/grpc-gateway-used-as-multiple-grpc-server-gateway/image-20220222155630463.webp><p>函数体可以简单划分成两部分：<ul><li>构造和发送请求 <ul><li>根据请求的 <code>Content-Type</code> 选择 <code>Marshaler</code> 。<li>构造请求上下文，从HTTP请求里提取<code>grpc-metadata</code>开头的元数据到 <code>context</code> 里。<li><code>request_XXX_0</code> 反序列化 HTTP 请求体到 protobuf 生成的结构，并发送请求。</ul><li>构造和返回响应 <ul><li>从响应元数据里构造上下文<li>构造和返回 HTTP 响应</ul></ul><p>整个流程是无状态也和 <code>gwmux</code> 本身无绑定的。换言之，理论上来说完全可以把所有 gRPC-Gateway 生成的 <code>Register</code> 函数注册到同一个 <code>gwmux</code> 上。<h3 id=backendhe-zhu-ce>Backend和注册</h3><p>出于清晰化的考虑，Gateway 服务的构造过程我写成了 Builder 模式。<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>registerHandlerFn </span><span style=color:#fa5c4b>func</span><span>(</span><span style=color:#fdf4c1>ctx context</span><span>.</span><span style=color:#fa5c4b>Context</span><span>, </span><span style=color:#fdf4c1>mux </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>runtime</span><span>.</span><span style=color:#fa5c4b>ServeMux</span><span>, </span><span style=color:#fdf4c1>conn </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>grpc</span><span>.</span><span style=color:#fa5c4b>ClientConn</span><span>) (</span><span style=color:#fdf4c1>err </span><span style=color:#fabd2f>error</span><span>)
</span><span>
</span><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>GRPCBackend </span><span style=color:#fa5c4b>struct </span><span>{
</span><span>	</span><span style=color:#fdf4c1>RegisterHandlerFunc </span><span style=color:#fa5c4b>registerHandlerFn
</span><span>	</span><span style=color:#fdf4c1>BackendAddr         </span><span style=color:#fabd2f>string
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>s </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>DonviewGRPCGatewayServer</span><span>) </span><span style=color:#8ec07c>Serve</span><span>() </span><span style=color:#fabd2f>error </span><span>{
</span><span>	</span><span style=color:#fdf4c1>mux </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>runtime</span><span>.</span><span style=color:#fdf4c1>NewServeMux</span><span>(</span><span style=color:#fdf4c1>s</span><span>.</span><span style=color:#fdf4c1>muxOptions</span><span style=color:#fe8019>...</span><span>)
</span><span>
</span><span>	</span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>_</span><span>, </span><span style=color:#fdf4c1>backend </span><span style=color:#fe8019>:= </span><span style=color:#fa5c4b>range </span><span style=color:#fdf4c1>s</span><span>.</span><span style=color:#fdf4c1>backends </span><span>{
</span><span>		</span><span style=color:#fdf4c1>conn</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>grpc</span><span>.</span><span style=color:#fdf4c1>DialContext</span><span>(</span><span style=color:#fdf4c1>context</span><span>.</span><span style=color:#fdf4c1>TODO</span><span>(), </span><span style=color:#fdf4c1>backend</span><span>.</span><span style=color:#fdf4c1>BackendAddr</span><span>, </span><span style=color:#fdf4c1>s</span><span>.</span><span style=color:#fdf4c1>dialOptions</span><span style=color:#fe8019>...</span><span>)
</span><span>		</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>			</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>err
</span><span>		}
</span><span>
</span><span>		</span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>backend</span><span>.</span><span style=color:#fdf4c1>RegisterHandlerFunc</span><span>(</span><span style=color:#fdf4c1>context</span><span>.</span><span style=color:#fdf4c1>TODO</span><span>(), </span><span style=color:#fdf4c1>mux</span><span>, </span><span style=color:#fdf4c1>conn</span><span>)
</span><span>		</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>			</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>err
</span><span>		}
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#fa5c4b>var </span><span style=color:#fdf4c1>handler http</span><span>.</span><span style=color:#fa5c4b>Handler </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>mux
</span><span>	</span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>_</span><span>, </span><span style=color:#fdf4c1>wrapperFn </span><span style=color:#fe8019>:= </span><span style=color:#fa5c4b>range </span><span style=color:#fdf4c1>s</span><span>.</span><span style=color:#fdf4c1>httpHandlerWrappers </span><span>{
</span><span>		</span><span style=color:#fdf4c1>handler </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>wrapperFn</span><span>(</span><span style=color:#fdf4c1>handler</span><span>)
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>http</span><span>.</span><span style=color:#fdf4c1>ListenAndServe</span><span>(</span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Sprintf</span><span>(</span><span style=color:#b8bb26>"0.0.0.0:</span><span style=color:#fdf4c1>%d</span><span style=color:#b8bb26>"</span><span>, </span><span style=color:#fdf4c1>s</span><span>.</span><span style=color:#fdf4c1>port</span><span>), </span><span style=color:#fdf4c1>handler</span><span>)
</span><span>}
</span><span>
</span></code></pre><p>所有 gRPC 后端被注册到 <code>s.backends</code> ，在开始服务的时候调用 <code>Serve</code> 函数，把 gRPC 服务注册到 <code>mux</code> 里。因为事前确保了服务路由不会重叠，理论上来说注册完就能用。<h2 id=fu-zai-jun-heng>负载均衡</h2><p>最初的架构里，一个 gRPC-Gateway 服务对应一个 gRPC 服务，请求进入服务的过程是从云服务提供商的 LB => kubernetes service (load balancer) => gateway => ClusterIP => gRPC Server 。<p>后来改成一个 POD 包含 gateway 和 gRPC 两个 container 后，gateway 访问 gRPC 服务就不在经过 ClusterIP 这一层代理了，路径变成云服务商的 LB => kubernetes service (load balancer) => gateway => gRPC Server 。<p>最后是现在的版本，网关统一成一个容器，路径和上述一样。<p>三者的区别在于负载均衡的时机。Kubernetes 的 ClusterIP 是同样具备负载均衡能力的，最初架构中负载均衡一共进行了三次，从云服务商的LB到主机端口（kubernetes），kubernetes再次负载均衡，转发到 gateway。gateway再经由 ClusterIP 转发至 gRPC 服务，每一次转发都经历一次负载均衡，分别提供了虚拟主机的扩容能力、gateway服务的扩容能力、gRPC服务的扩容能力。<p>第二版修改去掉了 gateway 到 gRPC 服务的负载均衡，变成了直连，延迟表现上理论上来说会有改善，但我没做过基准测试，所以这个“理论上”也只是凭感觉说。但可以明确的是 gateway 会额外占据资源配额，造成浪费，不好说值不值，个人感觉没太大意义。<p>第三版，统一了 gateway，还是三次负载均衡。不过Gateway对资源配额的使用效率会更好一点，依然保持了主机、gateway、gRPC 服务的可伸缩性。<p><img alt=三次LB src=https://nnnewb.github.io/posts/2022/grpc-gateway-used-as-multiple-grpc-server-gateway/image-20220222165344894.webp><h2 id=zong-jie>总结</h2><p>单从理论上来说这样设计应该是 OK 的，但是 gRPC-Gateway 官方对负载均衡没有说法，对能不能注册多个 gRPC 服务到一个 <code>mux</code> 上也没有官方的文档说明，很难说这帮人能不能保证向后兼容，万一之后的版本不支持注册到一个 <code>mux</code> 上了，到时候改起来就麻烦了，比较坏的情况就是你得自己写一个 <code>protoc-gen-gateway</code> 这样的玩意儿来生成一个自己的网关。<p>此外还有一个缺陷，gRPC-Gateway 到 gRPC Server 的负载均衡由 Kubernetes ClusterIP 提供，但是 <a href=https://stackoverflow.com/questions/49888133/kubernetes-service-cluster-ip-how-is-this-internally-load-balanced-across-diffe>ClusterIP 的负载均衡算法是 Round Robin/Random</a> ，并不支持根据负载或其他维度的测量数据来决定如何均衡负载，未来如果需要根据负载情况分发请求，可能还得在网关到 gRPC 服务之间加个负载均衡组件，再提供一个服务发现/注册中心来帮助调度。</article><p class=tags-data><a href=/tags/golang>/golang/</a> <a href=/tags/kubernetes>/kubernetes/</a> <a href=/tags/microservice>/microservice/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>