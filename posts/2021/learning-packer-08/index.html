<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>加壳原理08：混淆技术入门</title><meta content=加壳原理08：混淆技术入门 name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2021/learning-packer-08/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content=加壳原理08：混淆技术入门 property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2021/learning-packer-08/ property=twitter:url><meta content=加壳原理08：混淆技术入门 property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2021/learning-packer-08/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>加壳原理08：混淆技术入门</h1><p class=author-line>作于：2021-11-03 16:54 ，预计阅读时间 15 分钟<article><h2 id=qian-yan>前言</h2><p>本篇尝试学习通过动手写一个 LLVM Pass 来学习编译阶段进行代码混淆的技术。<h2 id=0x01-huan-jing-she-zhi>0x01 环境设置</h2><p>LLVM 是个相当大的项目，做好环境设置是首先要做的事情。这里选择 msys2 作为首要开发环境，不然光是 MSVC 把 LLVM 源码编译一遍就够呛了。<p>安装好MSYS2之后安装 clang 工具链（2021年11月3日，clang32工具链默认不在msys2的源里，需要手动改 <code>pacman.conf</code> 加入 <code>clang32</code> 源，这里以 x86_64 的 LLVM 工具链进行实践）。<pre class=language-bash data-lang=bash style=color:#fdf4c1aa;background-color:#282828><code class=language-bash data-lang=bash><span style=color:#fdf4c1>pacman -Sy mingw-w64-clang-x86_64-toolchain
</span></code></pre><p>完成后添加环境变量，把 msys2 安装目录下的 <code>clang64/bin</code> 加入环境变量，方便 VSCode + CMake 找到工具链。另外注意装一个 Ninja，同样加入 Path。<p>VSCode 里装上微软的 C/C++ 和 clangd，禁用微软 C/C++ 的 Intellisense，实在太慢。<p>手动编译整个LLVM源码树实在是太费时间了，我选择用MSYS2的工具链。参考这篇文档去配置一个 LLVM 源码树外的 Pass 工程：<a href=https://llvm.org/docs/CMake.html#cmake-out-of-source-pass>CMake out of source pass - LLVM</a> 。写一个简单的 CMakeLists.txt ，跟着 <a href=https://llvm.org/docs/WritingAnLLVMPass.html>Writing an LLVM Pass - LLVM</a> 这篇文档快速实现一个遍历函数的 Pass 。<p>下面是 <code>CMakeLists.txt</code> 的内容<pre class=language-cmake data-lang=cmake style=color:#fdf4c1aa;background-color:#282828><code class=language-cmake data-lang=cmake><span style=color:#fabd2f>cmake_minimum_required</span><span style=color:#fdf4c1>(VERSION 3.13.4)
</span><span style=color:#fabd2f>project</span><span style=color:#fdf4c1>(Hello)
</span><span style=color:#fabd2f>find_package</span><span style=color:#fdf4c1>(LLVM REQUIRED CONFIG)
</span><span>
</span><span style=color:#fabd2f>message</span><span style=color:#fdf4c1>(STATUS </span><span style=color:#b8bb26>"Found LLVM ${</span><span style=color:#fdf4c1>LLVM_PACKAGE_VERSION</span><span style=color:#b8bb26>}"</span><span style=color:#fdf4c1>)
</span><span style=color:#fabd2f>message</span><span style=color:#fdf4c1>(STATUS </span><span style=color:#b8bb26>"Using LLVMConfig.cmake in: ${</span><span style=color:#fdf4c1>LLVM_DIR</span><span style=color:#b8bb26>}"</span><span style=color:#fdf4c1>)
</span><span>
</span><span style=color:#fabd2f>include_directories</span><span style=color:#fdf4c1>(${LLVM_INCLUDE_DIRS})
</span><span style=color:#fabd2f>separate_arguments</span><span style=color:#fdf4c1>(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DEFINITIONS})
</span><span style=color:#fabd2f>add_definitions</span><span style=color:#fdf4c1>(${LLVM_DEFINITIONS_LIST})
</span><span>
</span><span style=color:#fabd2f>list</span><span style=color:#fdf4c1>(APPEND CMAKE_MODULE_PATH </span><span style=color:#b8bb26>"${</span><span style=color:#fdf4c1>LLVM_CMAKE_DIR</span><span style=color:#b8bb26>}"</span><span style=color:#fdf4c1>)
</span><span style=color:#fa5c4b>include</span><span style=color:#fdf4c1>(AddLLVM)
</span><span style=color:#fdf4c1>add_llvm_library(Hello MODULE hello.cpp PLUGIN_TOOL opt)
</span></code></pre><p>然后是实现 pass 的源码，源码的详细解释直接读 LLVM 给的文档。<pre class=language-c++ data-lang=c++ style=color:#fdf4c1aa;background-color:#282828><code class=language-c++ data-lang=c++><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>"llvm/IR/Function.h"
</span><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>"llvm/IR/LegacyPassManager.h"
</span><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>"llvm/Pass.h"
</span><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>"llvm/Support/raw_ostream.h"
</span><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>"llvm/Transforms/IPO/PassManagerBuilder.h"
</span><span>
</span><span style=color:#fa5c4b>using namespace</span><span> llvm;
</span><span>
</span><span style=color:#fa5c4b>namespace </span><span>{
</span><span>  </span><span style=color:#fa5c4b>struct </span><span style=color:#8ec07c>Hello </span><span>: </span><span style=color:#fa5c4b>public </span><span style=color:#8ec07c>FunctionPass </span><span>{
</span><span>    </span><span style=color:#fa5c4b>static char</span><span> ID;
</span><span>    </span><span style=color:#8ec07c>Hello</span><span>() : </span><span style=color:#fdf4c1>FunctionPass</span><span>(ID) {}
</span><span>    </span><span style=color:#fa5c4b>bool </span><span style=color:#8ec07c>runOnFunction</span><span>(Function </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>F</span><span>) </span><span style=color:#fa5c4b>override </span><span>{
</span><span>      </span><span style=color:#fdf4c1>errs() </span><span style=color:#fe8019>&lt;&lt; </span><span style=color:#b8bb26>"Hello:"</span><span>;
</span><span>      </span><span style=color:#fdf4c1>errs()</span><span>.</span><span style=color:#fdf4c1>write_escaped</span><span>(F.</span><span style=color:#fdf4c1>getName</span><span>()) </span><span style=color:#fe8019>&lt;&lt; </span><span style=color:#b8bb26>"\n"</span><span>;
</span><span>      </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>false</span><span>;
</span><span>    }
</span><span>  };
</span><span>} </span><span style=color:#928374;font-style:italic>// namespace
</span><span>
</span><span style=color:#fa5c4b>char</span><span> Hello::ID </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>;
</span><span>
</span><span style=color:#fa5c4b>static</span><span> RegisterPass&lt;Hello> </span><span style=color:#8ec07c>X</span><span>(</span><span style=color:#b8bb26>"hello"</span><span>, </span><span style=color:#b8bb26>"hello world pass"</span><span>, </span><span style=color:#fdf4c1>false</span><span>, </span><span style=color:#fdf4c1>false</span><span>);
</span><span>
</span><span style=color:#fa5c4b>static</span><span> RegisterStandardPasses </span><span style=color:#8ec07c>Y</span><span>(PassManagerBuilder::</span><span style=color:#fdf4c1>EP_EarlyAsPossible</span><span>,
</span><span>                                [](</span><span style=color:#fa5c4b>const</span><span> PassManagerBuilder </span><span style=color:#fe8019>&</span><span>builder, legacy::PassManagerBase </span><span style=color:#fe8019>&</span><span>pm) {
</span><span>                                  pm.</span><span style=color:#fdf4c1>add</span><span>(</span><span style=color:#fa5c4b>new </span><span style=color:#fdf4c1>Hello()</span><span>);
</span><span>                                });
</span></code></pre><p>再准备一个简单的样本，用来实验 Pass 的效果。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>&lt;stdio.h>
</span><span>
</span><span style=color:#fa5c4b>int </span><span style=color:#8ec07c>main</span><span>(</span><span style=color:#fa5c4b>void</span><span>) {
</span><span>  </span><span style=color:#fabd2f>printf</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"hello world"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>  </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>0</span><span>;
</span><span>}
</span></code></pre><p>接着是实验步骤：<pre class=language-bash data-lang=bash style=color:#fdf4c1aa;background-color:#282828><code class=language-bash data-lang=bash><span style=color:#fdf4c1>clang -O3 -emit-llvm sample.c -c -o sample.bc
</span><span style=color:#fdf4c1>opt -enable-new-pm</span><span style=color:#fe8019>=</span><span style=color:#fdf4c1>0 -load build/hello.dll -hello sample.bc -o sample.exe
</span></code></pre><p>如果一切顺利，输出如下：<pre style=color:#fdf4c1aa;background-color:#282828><code><span>Hello:main
</span></code></pre><p>不顺利的话只能自己谷歌。<h2 id=0x02-ollvm-bcf-hun-yao-chu-kui>0x02 OLLVM bcf 混淆初窥</h2><p>这部分先看看知名的 OLLVM 项目是怎么做的，先看 <em>bcf</em> 混淆，源码在 <code>llvm/lib/Transforms/Obfuscation/BogusControlFlow.cpp</code>， 入口在 <code>runOnFunction</code> 函数。<h3 id=2-1-runonfunction>2.1 runOnFunction</h3><pre class=language-cpp data-lang=cpp style=color:#fdf4c1aa;background-color:#282828><code class=language-cpp data-lang=cpp><span>    </span><span style=color:#928374;font-style:italic>/* runOnFunction
</span><span style=color:#928374;font-style:italic>     *
</span><span style=color:#928374;font-style:italic>     * Overwrite FunctionPass method to apply the transformation
</span><span style=color:#928374;font-style:italic>     * to the function. See header for more details.
</span><span style=color:#928374;font-style:italic>     */
</span><span>    </span><span style=color:#fa5c4b>virtual bool </span><span style=color:#8ec07c>runOnFunction</span><span>(Function </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>F</span><span>){
</span><span>      </span><span style=color:#928374;font-style:italic>// Check if the percentage is correct
</span><span>      </span><span style=color:#fa5c4b>if </span><span>(ObfTimes </span><span style=color:#fe8019>&lt;= </span><span style=color:#d3869b>0</span><span>) {
</span><span>        </span><span style=color:#fdf4c1>errs()</span><span style=color:#fe8019>&lt;&lt;</span><span style=color:#b8bb26>"BogusControlFlow application number -bcf_loop=x must be x > 0"</span><span>;
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>false</span><span>;
</span><span>      }
</span><span>
</span><span>      </span><span style=color:#928374;font-style:italic>// Check if the number of applications is correct
</span><span>      </span><span style=color:#fa5c4b>if </span><span>( </span><span style=color:#fe8019>!</span><span>((ObfProbRate </span><span style=color:#fe8019>> </span><span style=color:#d3869b>0</span><span>) </span><span style=color:#fe8019>&& </span><span>(ObfProbRate </span><span style=color:#fe8019>&lt;= </span><span style=color:#d3869b>100</span><span>)) ) {
</span><span>        </span><span style=color:#fdf4c1>errs()</span><span style=color:#fe8019>&lt;&lt;</span><span style=color:#b8bb26>"BogusControlFlow application basic blocks percentage -bcf_prob=x must be 0 &lt; x &lt;= 100"</span><span>;
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>false</span><span>;
</span><span>      }
</span><span>      </span><span style=color:#928374;font-style:italic>// If fla annotations
</span><span>      </span><span style=color:#fa5c4b>if</span><span>(</span><span style=color:#fdf4c1>toObfuscate(flag,</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>F,</span><span style=color:#b8bb26>"bcf"</span><span style=color:#fdf4c1>)</span><span>) {
</span><span>        </span><span style=color:#fa5c4b>if </span><span>(</span><span style=color:#fdf4c1>isInvoke(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>F)</span><span>) {
</span><span>          </span><span style=color:#fdf4c1>bogus(F)</span><span>;
</span><span>          </span><span style=color:#fdf4c1>doF(</span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>F.getParent())</span><span>;
</span><span>          </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>true</span><span>;
</span><span>        }
</span><span>      }
</span><span>
</span><span>      </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>false</span><span>;
</span><span>    } </span><span style=color:#928374;font-style:italic>// end of runOnFunction()
</span></code></pre><p>前两个 <code>if</code> 都是在判断参数，先忽略。<code>if(toObfuscate(flag,&F,"bcf"))</code> 判断是否是否需要混淆，<code>if (isInvoke(&F))</code> 判断能否混淆。<p>真正的混淆逻辑在 <code>bogus(F)</code> 里。<h3 id=2-2-bogus>2.2 bogus</h3><p>裁剪掉了调试输出后的 <code>bogus</code> 函数内容。<pre class=language-c++ data-lang=c++ style=color:#fdf4c1aa;background-color:#282828><code class=language-c++ data-lang=c++><span style=color:#fa5c4b>void </span><span style=color:#8ec07c>bogus</span><span>(Function </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>F</span><span>) {
</span><span>  </span><span style=color:#928374;font-style:italic>// For statistics and debug
</span><span>  </span><span style=color:#fe8019>++</span><span>NumFunction;
</span><span>  </span><span style=color:#fa5c4b>int</span><span> NumBasicBlocks </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>;
</span><span>  </span><span style=color:#fa5c4b>bool</span><span> firstTime </span><span style=color:#fe8019>= </span><span style=color:#d3869b>true</span><span>; </span><span style=color:#928374;font-style:italic>// First time we do the loop in this function
</span><span>
</span><span>  NumTimesOnFunctions </span><span style=color:#fe8019>=</span><span> ObfTimes;
</span><span>  </span><span style=color:#fa5c4b>int</span><span> NumObfTimes </span><span style=color:#fe8019>=</span><span> ObfTimes;
</span><span>
</span><span>  </span><span style=color:#928374;font-style:italic>// Real begining of the pass
</span><span>  </span><span style=color:#928374;font-style:italic>// Loop for the number of time we run the pass on the function
</span><span>  </span><span style=color:#fa5c4b>do </span><span>{
</span><span>    </span><span style=color:#928374;font-style:italic>// Put all the function's block in a list
</span><span>    std::list</span><span style=color:#fe8019>&lt;</span><span>BasicBlock </span><span style=color:#fe8019>*></span><span> basicBlocks;
</span><span>    </span><span style=color:#fa5c4b>for </span><span>(Function::iterator i </span><span style=color:#fe8019>=</span><span> F.</span><span style=color:#fdf4c1>begin</span><span>(); i </span><span style=color:#fe8019>!=</span><span> F.</span><span style=color:#fdf4c1>end</span><span>(); </span><span style=color:#fe8019>++</span><span>i) {
</span><span>      basicBlocks.</span><span style=color:#fdf4c1>push_back</span><span>(</span><span style=color:#fe8019>&*</span><span>i);
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa5c4b>while </span><span>(</span><span style=color:#fe8019>!</span><span>basicBlocks.</span><span style=color:#fdf4c1>empty</span><span>()) {
</span><span>      NumBasicBlocks</span><span style=color:#fe8019>++</span><span>;
</span><span>      </span><span style=color:#928374;font-style:italic>// Basic Blocks' selection
</span><span>      </span><span style=color:#fa5c4b>if </span><span>((</span><span style=color:#fa5c4b>int</span><span>)llvm::cryptoutils-></span><span style=color:#fdf4c1>get_range</span><span>(</span><span style=color:#d3869b>100</span><span>) </span><span style=color:#fe8019>&lt;=</span><span> ObfProbRate) {
</span><span>        </span><span style=color:#fe8019>++</span><span>NumModifiedBasicBlocks;
</span><span>        NumAddedBasicBlocks </span><span style=color:#fe8019>+= </span><span style=color:#d3869b>3</span><span>;
</span><span>        FinalNumBasicBlocks </span><span style=color:#fe8019>+= </span><span style=color:#d3869b>3</span><span>;
</span><span>        </span><span style=color:#928374;font-style:italic>// Add bogus flow to the given Basic Block (see description)
</span><span>        BasicBlock </span><span style=color:#fe8019>*</span><span>basicBlock </span><span style=color:#fe8019>=</span><span> basicBlocks.</span><span style=color:#fdf4c1>front</span><span>();
</span><span>        </span><span style=color:#fdf4c1>addBogusFlow(basicBlock, F)</span><span>;
</span><span>      }
</span><span>      </span><span style=color:#928374;font-style:italic>// remove the block from the list
</span><span>      basicBlocks.</span><span style=color:#fdf4c1>pop_front</span><span>();
</span><span>
</span><span>      </span><span style=color:#fa5c4b>if </span><span>(firstTime) { </span><span style=color:#928374;font-style:italic>// first time we iterate on this function
</span><span>        </span><span style=color:#fe8019>++</span><span>InitNumBasicBlocks;
</span><span>        </span><span style=color:#fe8019>++</span><span>FinalNumBasicBlocks;
</span><span>      }
</span><span>    } </span><span style=color:#928374;font-style:italic>// end of while(!basicBlocks.empty())
</span><span>
</span><span>    firstTime </span><span style=color:#fe8019>= </span><span style=color:#d3869b>false</span><span>;
</span><span>  } </span><span style=color:#fa5c4b>while </span><span>(</span><span style=color:#fe8019>--</span><span>NumObfTimes </span><span style=color:#fe8019>> </span><span style=color:#d3869b>0</span><span>);
</span><span>}
</span></code></pre><p>尝试分析上面的函数逻辑：<ol><li>循环混淆一定次数（<code>NumObfTimes</code>） <ol><li>遍历原函数基本块（<code>basicBlocks</code>） <ol><li>选择基本块（<code>cryptoutils->get_range(100) &lt;= ObfProbRate</code>） <ol><li>各种计数自增<li>添加伪造控制流（<code>addBogusFlow(basicBlock, F)</code>）</ol></ol></ol></ol><p>混淆次数和基本块遍历没什么好说的，选择基本块这里，<code>get_range(100)</code> 实际上是一个安全的随机数生成器，<code>ObfProbRate</code> 是基本块被混淆的机率。也就是说一个函数内的基本块是随机被混淆的，加上混淆次数的设计，会出现有的基本块被混淆多次有的没有被混淆的情况。<h3 id=2-2-addbogusflow>2.2 addBogusFlow</h3><p>接着继续看添加伪造控制流的逻辑，同样裁剪掉了调试输出。<pre class=language-c++ data-lang=c++ style=color:#fdf4c1aa;background-color:#282828><code class=language-c++ data-lang=c++><span style=color:#928374;font-style:italic>/* addBogusFlow
</span><span style=color:#928374;font-style:italic>  *
</span><span style=color:#928374;font-style:italic>  * Add bogus flow to a given basic block, according to the header's description
</span><span style=color:#928374;font-style:italic>  */
</span><span style=color:#fa5c4b>virtual void </span><span style=color:#8ec07c>addBogusFlow</span><span>(BasicBlock </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>basicBlock</span><span>, Function </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>F</span><span>) {
</span><span>      </span><span style=color:#928374;font-style:italic>// Split the block: first part with only the phi nodes and debug info and terminator
</span><span>      </span><span style=color:#928374;font-style:italic>//                  created by splitBasicBlock. (-> No instruction)
</span><span>      </span><span style=color:#928374;font-style:italic>//                  Second part with every instructions from the original block
</span><span>      </span><span style=color:#928374;font-style:italic>// We do this way, so we don't have to adjust all the phi nodes, metadatas and so on
</span><span>      </span><span style=color:#928374;font-style:italic>// for the first block. We have to let the phi nodes in the first part, because they
</span><span>      </span><span style=color:#928374;font-style:italic>// actually are updated in the second part according to them.
</span><span>      BasicBlock::iterator i1 </span><span style=color:#fe8019>=</span><span> basicBlock-></span><span style=color:#fdf4c1>begin</span><span>();
</span><span>      </span><span style=color:#fa5c4b>if </span><span>(basicBlock-></span><span style=color:#fdf4c1>getFirstNonPHIOrDbgOrLifetime</span><span>())
</span><span>        i1 </span><span style=color:#fe8019>= </span><span>(BasicBlock::iterator)basicBlock-></span><span style=color:#fdf4c1>getFirstNonPHIOrDbgOrLifetime</span><span>();
</span><span>      Twine </span><span style=color:#fe8019>*</span><span>var;
</span><span>      var </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>new </span><span style=color:#fdf4c1>Twine(</span><span style=color:#b8bb26>"originalBB"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>      BasicBlock </span><span style=color:#fe8019>*</span><span>originalBB </span><span style=color:#fe8019>=</span><span> basicBlock-></span><span style=color:#fdf4c1>splitBasicBlock</span><span>(i1, </span><span style=color:#fe8019>*</span><span>var);
</span><span>
</span><span>      </span><span style=color:#928374;font-style:italic>// Creating the altered basic block on which the first basicBlock will jump
</span><span>      Twine </span><span style=color:#fe8019>*</span><span>var3 </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>new </span><span style=color:#fdf4c1>Twine(</span><span style=color:#b8bb26>"alteredBB"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>      BasicBlock </span><span style=color:#fe8019>*</span><span>alteredBB </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>createAlteredBasicBlock(originalBB, </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>var3, </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>F)</span><span>;
</span><span>
</span><span>      </span><span style=color:#928374;font-style:italic>// Now that all the blocks are created,
</span><span>      </span><span style=color:#928374;font-style:italic>// we modify the terminators to adjust the control flow.
</span><span>      alteredBB-></span><span style=color:#fdf4c1>getTerminator</span><span>()-></span><span style=color:#fdf4c1>eraseFromParent</span><span>();
</span><span>      basicBlock-></span><span style=color:#fdf4c1>getTerminator</span><span>()-></span><span style=color:#fdf4c1>eraseFromParent</span><span>();
</span><span>
</span><span>      </span><span style=color:#928374;font-style:italic>// Preparing a condition..
</span><span>      </span><span style=color:#928374;font-style:italic>// For now, the condition is an always true comparaison between 2 float
</span><span>      </span><span style=color:#928374;font-style:italic>// This will be complicated after the pass (in doFinalization())
</span><span>      Value </span><span style=color:#fe8019>*</span><span>LHS </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>ConstantFP::get(Type::getFloatTy(F.getContext()), </span><span style=color:#d3869b>1.0</span><span style=color:#fdf4c1>)</span><span>;
</span><span>      Value </span><span style=color:#fe8019>*</span><span>RHS </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>ConstantFP::get(Type::getFloatTy(F.getContext()), </span><span style=color:#d3869b>1.0</span><span style=color:#fdf4c1>)</span><span>;
</span><span>
</span><span>      </span><span style=color:#928374;font-style:italic>// The always true condition. End of the first block
</span><span>      Twine </span><span style=color:#fe8019>*</span><span>var4 </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>new </span><span style=color:#fdf4c1>Twine(</span><span style=color:#b8bb26>"condition"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>      FCmpInst </span><span style=color:#fe8019>*</span><span>condition </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>new </span><span style=color:#fdf4c1>FCmpInst(</span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>basicBlock, FCmpInst::FCMP_TRUE, LHS, RHS, </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>var4)</span><span>;
</span><span>
</span><span>      </span><span style=color:#928374;font-style:italic>// Jump to the original basic block if the condition is true or
</span><span>      </span><span style=color:#928374;font-style:italic>// to the altered block if false.
</span><span>      </span><span style=color:#fdf4c1>BranchInst::Create(originalBB, alteredBB, (Value </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>)condition, basicBlock)</span><span>;
</span><span>
</span><span>      </span><span style=color:#928374;font-style:italic>// The altered block loop back on the original one.
</span><span>      </span><span style=color:#fdf4c1>BranchInst::Create(originalBB, alteredBB)</span><span>;
</span><span>
</span><span>      </span><span style=color:#928374;font-style:italic>// The end of the originalBB is modified to give the impression that sometimes
</span><span>      </span><span style=color:#928374;font-style:italic>// it continues in the loop, and sometimes it return the desired value
</span><span>      </span><span style=color:#928374;font-style:italic>// (of course it's always true, so it always use the original terminator..
</span><span>      </span><span style=color:#928374;font-style:italic>//  but this will be obfuscated too;) )
</span><span>
</span><span>      </span><span style=color:#928374;font-style:italic>// iterate on instruction just before the terminator of the originalBB
</span><span>      BasicBlock::iterator i </span><span style=color:#fe8019>=</span><span> originalBB-></span><span style=color:#fdf4c1>end</span><span>();
</span><span>
</span><span>      </span><span style=color:#928374;font-style:italic>// Split at this point (we only want the terminator in the second part)
</span><span>      Twine </span><span style=color:#fe8019>*</span><span>var5 </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>new </span><span style=color:#fdf4c1>Twine(</span><span style=color:#b8bb26>"originalBBpart2"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>      BasicBlock </span><span style=color:#fe8019>*</span><span>originalBBpart2 </span><span style=color:#fe8019>=</span><span> originalBB-></span><span style=color:#fdf4c1>splitBasicBlock</span><span>(</span><span style=color:#fe8019>--</span><span>i, </span><span style=color:#fe8019>*</span><span>var5);
</span><span>      </span><span style=color:#928374;font-style:italic>// the first part go either on the return statement or on the begining
</span><span>      </span><span style=color:#928374;font-style:italic>// of the altered block.. So we erase the terminator created when splitting.
</span><span>      originalBB-></span><span style=color:#fdf4c1>getTerminator</span><span>()-></span><span style=color:#fdf4c1>eraseFromParent</span><span>();
</span><span>      </span><span style=color:#928374;font-style:italic>// We add at the end a new always true condition
</span><span>      Twine </span><span style=color:#fe8019>*</span><span>var6 </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>new </span><span style=color:#fdf4c1>Twine(</span><span style=color:#b8bb26>"condition2"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>      FCmpInst </span><span style=color:#fe8019>*</span><span>condition2 </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>new </span><span style=color:#fdf4c1>FCmpInst(</span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>originalBB, CmpInst::FCMP_TRUE, LHS, RHS, </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>var6)</span><span>;
</span><span>      </span><span style=color:#fdf4c1>BranchInst::Create(originalBBpart2, alteredBB, (Value </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>)condition2, originalBB)</span><span>;
</span><span>} </span><span style=color:#928374;font-style:italic>// end of addBogusFlow()
</span></code></pre><p>尝试分析上面的函数逻辑：<ol><li>分割基本块，把 <code>phinode</code> 和调试信息之类的分割到原始块，新创建出来的块不包含 <code>phinode</code> 之类的东西。（<code>entry</code>）<li>创建伪造分支。（<code>altered</code>）<li>创建恒真条件，这里是利用浮点比较 <code>FCMP_TRUE</code>。（<code>condition</code>）<li>创建分支指令，真跳转原始块，假跳转伪造块，伪造块的末尾又跳回原始块。<li>在原始块的结束部分再次分割基本块，分割后的块包含原始块的 terminator （<code>terminator</code>）<li>创建一个恒真条件，跳转到原始块的 terminator，假则跳转到伪造块 （<code>condition2</code>）</ol><p><img alt=image-20211102160422737 src=https://nnnewb.github.io/posts/2021/learning-packer-08/image-20211102160422737.webp><p>混淆后的控制流长这样，两个 condition 都是恒真条件，原始块被分成了三个部分，<code>entry</code>、<code>origin</code>、<code>terminator</code> 。图中红色的部分是伪造块，包含垃圾指令，绿色的条件块都是恒真条件，只有绿色箭头的控制流能走通。蓝色节点是从原始基本块上分割出来的部分。<h3 id=2-3-createalteredbasicblock>2.3 createAlteredBasicBlock</h3><p>再看伪造块是如何生成的。<pre class=language-c++ data-lang=c++ style=color:#fdf4c1aa;background-color:#282828><code class=language-c++ data-lang=c++><span>    </span><span style=color:#928374;font-style:italic>/* createAlteredBasicBlock
</span><span style=color:#928374;font-style:italic>     *
</span><span style=color:#928374;font-style:italic>     * This function return a basic block similar to a given one.
</span><span style=color:#928374;font-style:italic>     * It's inserted just after the given basic block.
</span><span style=color:#928374;font-style:italic>     * The instructions are similar but junk instructions are added between
</span><span style=color:#928374;font-style:italic>     * the cloned one. The cloned instructions' phi nodes, metadatas, uses and
</span><span style=color:#928374;font-style:italic>     * debug locations are adjusted to fit in the cloned basic block and
</span><span style=color:#928374;font-style:italic>     * behave nicely.
</span><span style=color:#928374;font-style:italic>     */
</span><span>    </span><span style=color:#fa5c4b>virtual</span><span> BasicBlock </span><span style=color:#fe8019>*</span><span style=color:#8ec07c>createAlteredBasicBlock</span><span>(BasicBlock </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>basicBlock</span><span>, </span><span style=color:#fa5c4b>const</span><span> Twine </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>Name </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>"gen"</span><span>, Function </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>F </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>) {
</span><span>      </span><span style=color:#928374;font-style:italic>// Useful to remap the informations concerning instructions.
</span><span>      ValueToValueMapTy VMap;
</span><span>      BasicBlock </span><span style=color:#fe8019>*</span><span>alteredBB </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>llvm::CloneBasicBlock(basicBlock, VMap, Name, F)</span><span>;
</span><span>      </span><span style=color:#928374;font-style:italic>// Remap operands.
</span><span>      BasicBlock::iterator ji </span><span style=color:#fe8019>=</span><span> basicBlock-></span><span style=color:#fdf4c1>begin</span><span>();
</span><span>      </span><span style=color:#fa5c4b>for </span><span>(BasicBlock::iterator i </span><span style=color:#fe8019>=</span><span> alteredBB-></span><span style=color:#fdf4c1>begin</span><span>(), e </span><span style=color:#fe8019>=</span><span> alteredBB-></span><span style=color:#fdf4c1>end</span><span>(); i </span><span style=color:#fe8019>!=</span><span> e; </span><span style=color:#fe8019>++</span><span>i) {
</span><span>        </span><span style=color:#928374;font-style:italic>// Loop over the operands of the instruction
</span><span>        </span><span style=color:#fa5c4b>for </span><span>(User::op_iterator opi </span><span style=color:#fe8019>=</span><span> i-></span><span style=color:#fdf4c1>op_begin</span><span>(), ope </span><span style=color:#fe8019>=</span><span> i-></span><span style=color:#fdf4c1>op_end</span><span>(); opi </span><span style=color:#fe8019>!=</span><span> ope; </span><span style=color:#fe8019>++</span><span>opi) {
</span><span>          </span><span style=color:#928374;font-style:italic>// get the value for the operand
</span><span>          Value </span><span style=color:#fe8019>*</span><span>v </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>MapValue(</span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>opi, VMap, RF_None, </span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>)</span><span>;
</span><span>          </span><span style=color:#fa5c4b>if </span><span>(v </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>0</span><span>) {
</span><span>            </span><span style=color:#fe8019>*</span><span>opi </span><span style=color:#fe8019>=</span><span> v;
</span><span>          }
</span><span>        }
</span><span>        </span><span style=color:#928374;font-style:italic>// Remap phi nodes' incoming blocks.
</span><span>        </span><span style=color:#fa5c4b>if </span><span>(PHINode </span><span style=color:#fe8019>*</span><span>pn </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>dyn_cast&lt;PHINode>(i)</span><span>) {
</span><span>          </span><span style=color:#fa5c4b>for </span><span>(</span><span style=color:#fa5c4b>unsigned</span><span> j </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>, e </span><span style=color:#fe8019>=</span><span> pn-></span><span style=color:#fdf4c1>getNumIncomingValues</span><span>(); j </span><span style=color:#fe8019>!=</span><span> e; </span><span style=color:#fe8019>++</span><span>j) {
</span><span>            Value </span><span style=color:#fe8019>*</span><span>v </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>MapValue(pn->getIncomingBlock(j), VMap, RF_None, </span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>)</span><span>;
</span><span>            </span><span style=color:#fa5c4b>if </span><span>(v </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>0</span><span>) {
</span><span>              pn-></span><span style=color:#fdf4c1>setIncomingBlock</span><span>(j, </span><span style=color:#fdf4c1>cast&lt;BasicBlock>(v)</span><span>);
</span><span>            }
</span><span>          }
</span><span>        }
</span><span>        </span><span style=color:#928374;font-style:italic>// Remap attached metadata.
</span><span>        SmallVector</span><span style=color:#fe8019>&lt;</span><span>std::pair</span><span style=color:#fe8019>&lt;</span><span style=color:#fa5c4b>unsigned</span><span>, MDNode </span><span style=color:#fe8019>*></span><span>, </span><span style=color:#d3869b>4</span><span style=color:#fe8019>></span><span> MDs;
</span><span>        i-></span><span style=color:#fdf4c1>getAllMetadata</span><span>(MDs);
</span><span>        </span><span style=color:#928374;font-style:italic>// important for compiling with DWARF, using option -g.
</span><span>        i-></span><span style=color:#fdf4c1>setDebugLoc</span><span>(ji-></span><span style=color:#fdf4c1>getDebugLoc</span><span>());
</span><span>        ji</span><span style=color:#fe8019>++</span><span>;
</span><span>
</span><span>      } </span><span style=color:#928374;font-style:italic>// The instructions' informations are now all correct
</span><span>
</span><span>
</span><span>      </span><span style=color:#928374;font-style:italic>// add random instruction in the middle of the bloc. This part can be improve
</span><span>      </span><span style=color:#fa5c4b>for </span><span>(BasicBlock::iterator i </span><span style=color:#fe8019>=</span><span> alteredBB-></span><span style=color:#fdf4c1>begin</span><span>(), e </span><span style=color:#fe8019>=</span><span> alteredBB-></span><span style=color:#fdf4c1>end</span><span>(); i </span><span style=color:#fe8019>!=</span><span> e; </span><span style=color:#fe8019>++</span><span>i) {
</span><span>        </span><span style=color:#928374;font-style:italic>// in the case we find binary operator, we modify slightly this part by randomly
</span><span>        </span><span style=color:#928374;font-style:italic>// insert some instructions
</span><span>        </span><span style=color:#fa5c4b>if </span><span>(i-></span><span style=color:#fdf4c1>isBinaryOp</span><span>()) { </span><span style=color:#928374;font-style:italic>// binary instructions
</span><span>          </span><span style=color:#fa5c4b>unsigned</span><span> opcode </span><span style=color:#fe8019>=</span><span> i-></span><span style=color:#fdf4c1>getOpcode</span><span>();
</span><span>          BinaryOperator </span><span style=color:#fe8019>*</span><span>op, </span><span style=color:#fe8019>*</span><span>op1 </span><span style=color:#fe8019>= </span><span style=color:#d3869b>NULL</span><span>;
</span><span>          UnaryOperator </span><span style=color:#fe8019>*</span><span>op2;
</span><span>          Twine </span><span style=color:#fe8019>*</span><span>var </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>new </span><span style=color:#fdf4c1>Twine(</span><span style=color:#b8bb26>"_"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>          </span><span style=color:#928374;font-style:italic>// treat differently float or int
</span><span>          </span><span style=color:#928374;font-style:italic>// Binary int
</span><span>          </span><span style=color:#fa5c4b>if </span><span>(opcode </span><span style=color:#fe8019>==</span><span> Instruction::Add </span><span style=color:#fe8019>||</span><span> opcode </span><span style=color:#fe8019>==</span><span> Instruction::Sub </span><span style=color:#fe8019>||</span><span> opcode </span><span style=color:#fe8019>==</span><span> Instruction::Mul </span><span style=color:#fe8019>||
</span><span>              opcode </span><span style=color:#fe8019>==</span><span> Instruction::UDiv </span><span style=color:#fe8019>||</span><span> opcode </span><span style=color:#fe8019>==</span><span> Instruction::SDiv </span><span style=color:#fe8019>||</span><span> opcode </span><span style=color:#fe8019>==</span><span> Instruction::URem </span><span style=color:#fe8019>||
</span><span>              opcode </span><span style=color:#fe8019>==</span><span> Instruction::SRem </span><span style=color:#fe8019>||</span><span> opcode </span><span style=color:#fe8019>==</span><span> Instruction::Shl </span><span style=color:#fe8019>||</span><span> opcode </span><span style=color:#fe8019>==</span><span> Instruction::LShr </span><span style=color:#fe8019>||
</span><span>              opcode </span><span style=color:#fe8019>==</span><span> Instruction::AShr </span><span style=color:#fe8019>||</span><span> opcode </span><span style=color:#fe8019>==</span><span> Instruction::And </span><span style=color:#fe8019>||</span><span> opcode </span><span style=color:#fe8019>==</span><span> Instruction::Or </span><span style=color:#fe8019>||
</span><span>              opcode </span><span style=color:#fe8019>==</span><span> Instruction::Xor) {
</span><span>            </span><span style=color:#fa5c4b>for </span><span>(</span><span style=color:#fa5c4b>int</span><span> random </span><span style=color:#fe8019>= </span><span>(</span><span style=color:#fa5c4b>int</span><span>)llvm::cryptoutils-></span><span style=color:#fdf4c1>get_range</span><span>(</span><span style=color:#d3869b>10</span><span>); random </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>10</span><span>; </span><span style=color:#fe8019>++</span><span>random) {
</span><span>              </span><span style=color:#fa5c4b>switch </span><span>(llvm::cryptoutils-></span><span style=color:#fdf4c1>get_range</span><span>(</span><span style=color:#d3869b>4</span><span>)) { </span><span style=color:#928374;font-style:italic>// to improve
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>0</span><span>:                                    </span><span style=color:#928374;font-style:italic>// do nothing
</span><span>                </span><span style=color:#fa5c4b>break</span><span>;
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>1</span><span>:
</span><span>                op </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>BinaryOperator::CreateNeg(i->getOperand(</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>), </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>var, </span><span style=color:#fe8019>&*</span><span style=color:#fdf4c1>i)</span><span>;
</span><span>                op1 </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>BinaryOperator::Create(Instruction::Add, op, i->getOperand(</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>), </span><span style=color:#b8bb26>"gen"</span><span style=color:#fdf4c1>, </span><span style=color:#fe8019>&*</span><span style=color:#fdf4c1>i)</span><span>;
</span><span>                </span><span style=color:#fa5c4b>break</span><span>;
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>2</span><span>:
</span><span>                op1 </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>BinaryOperator::Create(Instruction::Sub, i->getOperand(</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>), i->getOperand(</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>), </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>var, </span><span style=color:#fe8019>&*</span><span style=color:#fdf4c1>i)</span><span>;
</span><span>                op </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>BinaryOperator::Create(Instruction::Mul, op1, i->getOperand(</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>), </span><span style=color:#b8bb26>"gen"</span><span style=color:#fdf4c1>, </span><span style=color:#fe8019>&*</span><span style=color:#fdf4c1>i)</span><span>;
</span><span>                </span><span style=color:#fa5c4b>break</span><span>;
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>3</span><span>:
</span><span>                op </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>BinaryOperator::Create(Instruction::Shl, i->getOperand(</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>), i->getOperand(</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>), </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>var, </span><span style=color:#fe8019>&*</span><span style=color:#fdf4c1>i)</span><span>;
</span><span>                </span><span style=color:#fa5c4b>break</span><span>;
</span><span>              }
</span><span>            }
</span><span>          }
</span><span>          </span><span style=color:#928374;font-style:italic>// Binary float
</span><span>          </span><span style=color:#fa5c4b>if </span><span>(opcode </span><span style=color:#fe8019>==</span><span> Instruction::FAdd </span><span style=color:#fe8019>||</span><span> opcode </span><span style=color:#fe8019>==</span><span> Instruction::FSub </span><span style=color:#fe8019>||</span><span> opcode </span><span style=color:#fe8019>==</span><span> Instruction::FMul </span><span style=color:#fe8019>||
</span><span>              opcode </span><span style=color:#fe8019>==</span><span> Instruction::FDiv </span><span style=color:#fe8019>||</span><span> opcode </span><span style=color:#fe8019>==</span><span> Instruction::FRem) {
</span><span>            </span><span style=color:#fa5c4b>for </span><span>(</span><span style=color:#fa5c4b>int</span><span> random </span><span style=color:#fe8019>= </span><span>(</span><span style=color:#fa5c4b>int</span><span>)llvm::cryptoutils-></span><span style=color:#fdf4c1>get_range</span><span>(</span><span style=color:#d3869b>10</span><span>); random </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>10</span><span>; </span><span style=color:#fe8019>++</span><span>random) {
</span><span>              </span><span style=color:#fa5c4b>switch </span><span>(llvm::cryptoutils-></span><span style=color:#fdf4c1>get_range</span><span>(</span><span style=color:#d3869b>3</span><span>)) { </span><span style=color:#928374;font-style:italic>// can be improved
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>0</span><span>:                                    </span><span style=color:#928374;font-style:italic>// do nothing
</span><span>                </span><span style=color:#fa5c4b>break</span><span>;
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>1</span><span>:
</span><span>                op2 </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>UnaryOperator::CreateFNeg(i->getOperand(</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>), </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>var, </span><span style=color:#fe8019>&*</span><span style=color:#fdf4c1>i)</span><span>;
</span><span>                op1 </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>BinaryOperator::Create(Instruction::FAdd, op2, i->getOperand(</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>), </span><span style=color:#b8bb26>"gen"</span><span style=color:#fdf4c1>, </span><span style=color:#fe8019>&*</span><span style=color:#fdf4c1>i)</span><span>;
</span><span>                </span><span style=color:#fa5c4b>break</span><span>;
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>2</span><span>:
</span><span>                op </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>BinaryOperator::Create(Instruction::FSub, i->getOperand(</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>), i->getOperand(</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>), </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>var, </span><span style=color:#fe8019>&*</span><span style=color:#fdf4c1>i)</span><span>;
</span><span>                op1 </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>BinaryOperator::Create(Instruction::FMul, op, i->getOperand(</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>), </span><span style=color:#b8bb26>"gen"</span><span style=color:#fdf4c1>, </span><span style=color:#fe8019>&*</span><span style=color:#fdf4c1>i)</span><span>;
</span><span>                </span><span style=color:#fa5c4b>break</span><span>;
</span><span>              }
</span><span>            }
</span><span>          }
</span><span>          </span><span style=color:#fa5c4b>if </span><span>(opcode </span><span style=color:#fe8019>==</span><span> Instruction::ICmp) { </span><span style=color:#928374;font-style:italic>// Condition (with int)
</span><span>            ICmpInst </span><span style=color:#fe8019>*</span><span>currentI </span><span style=color:#fe8019>= </span><span>(ICmpInst </span><span style=color:#fe8019>*</span><span>)(</span><span style=color:#fe8019>&</span><span>i);
</span><span>            </span><span style=color:#fa5c4b>switch </span><span>(llvm::cryptoutils-></span><span style=color:#fdf4c1>get_range</span><span>(</span><span style=color:#d3869b>3</span><span>)) { </span><span style=color:#928374;font-style:italic>// must be improved
</span><span>            </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>0</span><span>:                                    </span><span style=color:#928374;font-style:italic>// do nothing
</span><span>              </span><span style=color:#fa5c4b>break</span><span>;
</span><span>            </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>1</span><span>:
</span><span>              currentI-></span><span style=color:#fdf4c1>swapOperands</span><span>();
</span><span>              </span><span style=color:#fa5c4b>break</span><span>;
</span><span>            </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>2</span><span>: </span><span style=color:#928374;font-style:italic>// randomly change the predicate
</span><span>              </span><span style=color:#fa5c4b>switch </span><span>(llvm::cryptoutils-></span><span style=color:#fdf4c1>get_range</span><span>(</span><span style=color:#d3869b>10</span><span>)) {
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>0</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(ICmpInst::ICMP_EQ);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// equal
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>1</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(ICmpInst::ICMP_NE);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// not equal
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>2</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(ICmpInst::ICMP_UGT);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// unsigned greater than
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>3</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(ICmpInst::ICMP_UGE);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// unsigned greater or equal
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>4</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(ICmpInst::ICMP_ULT);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// unsigned less than
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>5</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(ICmpInst::ICMP_ULE);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// unsigned less or equal
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>6</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(ICmpInst::ICMP_SGT);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// signed greater than
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>7</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(ICmpInst::ICMP_SGE);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// signed greater or equal
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>8</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(ICmpInst::ICMP_SLT);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// signed less than
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>9</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(ICmpInst::ICMP_SLE);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// signed less or equal
</span><span>              }
</span><span>              </span><span style=color:#fa5c4b>break</span><span>;
</span><span>            }
</span><span>          }
</span><span>          </span><span style=color:#fa5c4b>if </span><span>(opcode </span><span style=color:#fe8019>==</span><span> Instruction::FCmp) { </span><span style=color:#928374;font-style:italic>// Conditions (with float)
</span><span>            FCmpInst </span><span style=color:#fe8019>*</span><span>currentI </span><span style=color:#fe8019>= </span><span>(FCmpInst </span><span style=color:#fe8019>*</span><span>)(</span><span style=color:#fe8019>&</span><span>i);
</span><span>            </span><span style=color:#fa5c4b>switch </span><span>(llvm::cryptoutils-></span><span style=color:#fdf4c1>get_range</span><span>(</span><span style=color:#d3869b>3</span><span>)) { </span><span style=color:#928374;font-style:italic>// must be improved
</span><span>            </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>0</span><span>:                                    </span><span style=color:#928374;font-style:italic>// do nothing
</span><span>              </span><span style=color:#fa5c4b>break</span><span>;
</span><span>            </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>1</span><span>:
</span><span>              currentI-></span><span style=color:#fdf4c1>swapOperands</span><span>();
</span><span>              </span><span style=color:#fa5c4b>break</span><span>;
</span><span>            </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>2</span><span>: </span><span style=color:#928374;font-style:italic>// randomly change the predicate
</span><span>              </span><span style=color:#fa5c4b>switch </span><span>(llvm::cryptoutils-></span><span style=color:#fdf4c1>get_range</span><span>(</span><span style=color:#d3869b>10</span><span>)) {
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>0</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(FCmpInst::FCMP_OEQ);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// ordered and equal
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>1</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(FCmpInst::FCMP_ONE);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// ordered and operands are unequal
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>2</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(FCmpInst::FCMP_UGT);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// unordered or greater than
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>3</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(FCmpInst::FCMP_UGE);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// unordered, or greater than, or equal
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>4</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(FCmpInst::FCMP_ULT);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// unordered or less than
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>5</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(FCmpInst::FCMP_ULE);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// unordered, or less than, or equal
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>6</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(FCmpInst::FCMP_OGT);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// ordered and greater than
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>7</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(FCmpInst::FCMP_OGE);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// ordered and greater than or equal
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>8</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(FCmpInst::FCMP_OLT);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// ordered and less than
</span><span>              </span><span style=color:#fa5c4b>case </span><span style=color:#d3869b>9</span><span>:
</span><span>                currentI-></span><span style=color:#fdf4c1>setPredicate</span><span>(FCmpInst::FCMP_OLE);
</span><span>                </span><span style=color:#fa5c4b>break</span><span>; </span><span style=color:#928374;font-style:italic>// ordered or less than, or equal
</span><span>              }
</span><span>              </span><span style=color:#fa5c4b>break</span><span>;
</span><span>            }
</span><span>          }
</span><span>        }
</span><span>      }
</span><span>      </span><span style=color:#fa5c4b>return</span><span> alteredBB;
</span><span>    } </span><span style=color:#928374;font-style:italic>// end of createAlteredBasicBlock()
</span></code></pre><p>主要是分两部分：<ol><li>复制原始块，并修复伪造块的调试信息与元数据<li>在伪造块中寻找二元运算、浮点运算、比较指令，在其中插入垃圾指令。</ol><h2 id=0x03-chuang-jian-zi-ji-de-hun-yao>0x03 创建自己的混淆</h2><p>对 OLLVM 的 bcf 混淆有了初步的映像之后，接下来就可以依样画葫芦抄一个自己的混淆出来啦。<h3 id=3-1-fang-an>3.1 方案</h3><p><img alt=image-20211103105527721 src=https://nnnewb.github.io/posts/2021/learning-packer-08/image-20211103105527721.webp><p>作为概念验证，我们的 pass 将原始代码分割成三个基本块，称为 <code>entry</code>、<code>original</code>和<code>terminator</code>。<code>entry</code> 通过一个恒真判断跳转至 <code>original</code>，<code>original</code> 通过恒真判断跳转至 <code>terminator</code>。伪造块 <code>altered</code> 则是 false 分支，内容仅复制 <code>original</code> 块，并在末尾跳转至 <code>original</code> 块。<p>伪造块应该永远不会被执行。<h3 id=3-2-llvmbian-cheng-de-zhong-yao-gai-nian>3.2 LLVM编程的重要概念</h3><p>参考文章：<a href=https://mukulrathi.com/create-your-own-programming-language/llvm-ir-cpp-api-tutorial/>LLVM IR C++ API Tutorial</a><h4 id=guan-jian-lei-xing>关键类型：</h4><p>清单如下：<ul><li><code>Value</code><li><code>Module</code><li><code>Type</code><li><code>Function</code><li><code>BasicBlock</code><li><code>BranchInst</code></ul><p>列出的这些是 LLVM C++ 接口定义的类，可以通过 <code>Module</code> 获取 <code>Function</code>，可以从 <code>Function</code> 获取 <code>BasicBlock</code>，也可以从 <code>BasicBlock</code> 反过来获取 <code>Function</code>，这些容器间组织成层级关系。<p><code>Module</code>-><code>Function</code>-><code>BasicBlock</code>-><code>Instruction</code><p><code>Value</code> 是公共基类，<code>Function</code>、<code>BasicBlock</code>，包括各种指令类都是从<code>Value</code>继承。<h4 id=phinode>PHINode：</h4><p>参考文章：<a href=http://mayuyu.io/2018/06/04/PhiNode-in-LLVM/>PhiNode in LLVM</a><p>LLVM的指令类型中包含一种特殊节点叫 PhiNode，PhiNode 的存在是为了解决 LLVM IR 中因 SSA （静态单次赋值）引起的条件初始化问题。示例如下。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>int </span><span style=color:#8ec07c>foooooo</span><span>(</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>bar</span><span>){
</span><span>    </span><span style=color:#fa5c4b>int</span><span> i</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span>;
</span><span>    </span><span style=color:#fa5c4b>if</span><span>(bar</span><span style=color:#fe8019>%</span><span style=color:#d3869b>2</span><span style=color:#fe8019>==</span><span style=color:#d3869b>0</span><span>){
</span><span>        i</span><span style=color:#fe8019>=</span><span style=color:#d3869b>1</span><span>; </span><span style=color:#928374;font-style:italic>//BasicBlock 1
</span><span>    }
</span><span>    </span><span style=color:#fa5c4b>else</span><span>{
</span><span>        i</span><span style=color:#fe8019>=</span><span style=color:#d3869b>2</span><span>; </span><span style=color:#928374;font-style:italic>//BasicBlock 2
</span><span>    }
</span><span>    </span><span style=color:#fa5c4b>return</span><span> i;
</span><span>}
</span></code></pre><p>可以看到我们需要按 <code>bar</code> 的取值来初始化 <code>i</code>，但 SSA 要求 <code>i</code> 只能被赋值一次。PhiNode 允许根据基本块选择赋值。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>int </span><span style=color:#8ec07c>foooooo</span><span>(</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>bar</span><span>) {
</span><span>    </span><span style=color:#fa5c4b>if</span><span>(bar</span><span style=color:#fe8019>%</span><span style=color:#d3869b>2</span><span style=color:#fe8019>==</span><span style=color:#d3869b>0</span><span>){
</span><span>        </span><span style=color:#928374;font-style:italic>//BasicBlock1
</span><span>    }
</span><span>    </span><span style=color:#fa5c4b>else</span><span>{
</span><span>        </span><span style=color:#928374;font-style:italic>//BasicBlock2
</span><span>    }
</span><span>    </span><span style=color:#fa5c4b>int</span><span> i</span><span style=color:#fe8019>=</span><span style=color:#fdf4c1>Phi([BasicBlock1,</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>],[BasicBlock2,</span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>])</span><span>;
</span><span>    </span><span style=color:#fa5c4b>return</span><span> i;
</span><span>}
</span></code></pre><p>上面的例子也可以改成在栈或堆上开辟空间，以类似指针的方式避开 SSA 约束。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>int </span><span style=color:#8ec07c>foooooo</span><span>(</span><span style=color:#fa5c4b>int </span><span style=color:#fdf4c1>bar</span><span>) {
</span><span>    </span><span style=color:#fa5c4b>int</span><span style=color:#fe8019>*</span><span> i</span><span style=color:#fe8019>=</span><span style=color:#fabd2f>malloc</span><span style=color:#fdf4c1>(</span><span style=color:#fe8019>sizeof</span><span style=color:#fdf4c1>(</span><span style=color:#fa5c4b>int</span><span style=color:#fdf4c1>))</span><span>;
</span><span>    </span><span style=color:#fa5c4b>if</span><span>(bar</span><span style=color:#fe8019>%</span><span style=color:#d3869b>2</span><span style=color:#fe8019>==</span><span style=color:#d3869b>0</span><span>){
</span><span>        Store Value </span><span style=color:#d3869b>1</span><span> to the memory location pointed to by i;
</span><span>    }
</span><span>    </span><span style=color:#fa5c4b>else</span><span>{
</span><span>        Store Value </span><span style=color:#d3869b>2</span><span> to the memory location pointed to by i;
</span><span>    }
</span><span>    </span><span style=color:#fa5c4b>int</span><span> j</span><span style=color:#fe8019>=</span><span>load from the address pointed by i;
</span><span>    </span><span style=color:#fa5c4b>return</span><span> j;
</span><span>}
</span></code></pre><h4 id=terminator>Terminator:</h4><p>参考文章：<a href=https://www.quora.com/How-do-Terminators-work-in-the-LLVM-IR>How do Terminator work in LLVM IR</a><p>LLVM中，一个基本块 <em>BasicBlock</em> 总是以终结指令 <em>TerminatorInst</em> 结束的。终结指令不能出现在基本块末尾以外的任何地方。粗略地说，终结指令标识控制流在基本块结束后去往何方。<p>每个终结指令都包含一定的后继基本块。<p>几个常见的终结指令类型：<ul><li><p><code>ReturnInst</code> 就像是普通编程中的的<code>return</code>语句。</p><li><p><code>BranchInst</code> 是跳转指令，包括两类：</p> <ul><li>条件跳转，满足条件时跳转分支1，否则跳转分支2。<li>非条件跳转，总是跳转到某个分支。</ul><li><p><code>SwitchInst</code> 类似于普通编程里的 <code>switch</code> 语句，可以包含更多的后继块。</p></ul><p>还有些不那么常见的终结指令：<ul><li><code>invoke</code> 和 <code>catchswitch</code><li><code>unreachable</code></ul><h3 id=3-3-gong-ju-lian>3.3 工具链</h3><p>参考文章：<a href=https://llvm.org/docs/CommandGuide/index.html>LLVM Command Guide</a><p>实际动手前先了解下 LLVM工具链，列出一些会涉及到的命令行工具。<ul><li><code>llc</code> 将输入的 LLVM IR(<code>.ll</code>) 编译成指定架构的汇编（或二进制对象文件）<li><code>lli</code> 将输入的 BitCode(<code>.bc</code>) 解释执行。<li><code>llvm-as</code> 汇编器<li><code>llvm-dis</code> 反汇编器，可以反汇编 BitCode<li><code>opt</code> BITCODE/IR 优化器</ul><p>最好再安装一个 graphviz，因为很多编程语言的命令行工具如果提供图形输出的话，大多是以 dot 形式提供（比如 go 的 pprof 和 LLVM opt 的 dot-cfg）。<h3 id=3-3-runonfunction>3.3 runOnFunction</h3><p>参考 OLLVM 的代码，抄出过滤函数。原理不明暂且不深究。<pre class=language-c++ data-lang=c++ style=color:#fdf4c1aa;background-color:#282828><code class=language-c++ data-lang=c++><span style=color:#fa5c4b>bool </span><span style=color:#8ec07c>isObfuscateable</span><span>(</span><span style=color:#fa5c4b>const</span><span> Function </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>fn</span><span>) {
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(fn.</span><span style=color:#fdf4c1>isDeclaration</span><span>()) {
</span><span>        </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>false</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(fn.</span><span style=color:#fdf4c1>hasAvailableExternallyLinkage</span><span>()) {
</span><span>        </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>false</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(</span><span style=color:#fe8019>!</span><span style=color:#fdf4c1>isInvoke(fn)</span><span>) {
</span><span>        </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>false</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>true</span><span>;
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>bool </span><span style=color:#8ec07c>isInvoke</span><span>(</span><span style=color:#fa5c4b>const</span><span> Function </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>fn</span><span>) {
</span><span>    </span><span style=color:#fa5c4b>for </span><span>(</span><span style=color:#fa5c4b>const</span><span> BasicBlock </span><span style=color:#fe8019>&</span><span>bb </span><span style=color:#fe8019>:</span><span> fn) {
</span><span>        </span><span style=color:#fa5c4b>if </span><span>(</span><span style=color:#fdf4c1>isa&lt;InvokeInst>(bb.getTerminator())</span><span>) {
</span><span>            </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>false</span><span>;
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>true</span><span>;
</span><span>}
</span></code></pre><p>然后在入口点简单过滤掉不能混淆的函数，接着遍历基本块，对每个基本块都进行一次混淆。<pre class=language-c++ data-lang=c++ style=color:#fdf4c1aa;background-color:#282828><code class=language-c++ data-lang=c++><span style=color:#fa5c4b>bool </span><span style=color:#8ec07c>runOnFunction</span><span>(Function</span><span style=color:#fe8019>& </span><span style=color:#fdf4c1>F</span><span>) {
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(</span><span style=color:#fe8019>!</span><span style=color:#fdf4c1>isObfuscateable(F)</span><span>) {
</span><span>        </span><span style=color:#fdf4c1>errs()</span><span style=color:#fe8019>&lt;&lt;</span><span style=color:#b8bb26>"function "</span><span style=color:#fe8019>&lt;&lt;</span><span> F.</span><span style=color:#fdf4c1>getName</span><span>() </span><span style=color:#fe8019>&lt;&lt;</span><span style=color:#b8bb26>" is not obfuscateable\n"</span><span>;
</span><span>        </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>false</span><span>;
</span><span>    }
</span><span>    
</span><span>    list</span><span style=color:#fe8019>&lt;</span><span>BasicBlock </span><span style=color:#fe8019>*></span><span> blocks;
</span><span>    </span><span style=color:#fa5c4b>for </span><span>(BasicBlock </span><span style=color:#fe8019>&</span><span>block </span><span style=color:#fe8019>:</span><span> F) {
</span><span>        blocks.</span><span style=color:#fdf4c1>push_back</span><span>(</span><span style=color:#fe8019>&</span><span>block);
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa5c4b>for </span><span>(BasicBlock </span><span style=color:#fe8019>*</span><span>block </span><span style=color:#fe8019>:</span><span> blocks) {
</span><span>        </span><span style=color:#928374;font-style:italic>// 原始块分割为三个基本块：entry、original、terminator
</span><span>        </span><span style=color:#928374;font-style:italic>// 通过两个恒真条件连接
</span><span>        </span><span style=color:#fa5c4b>auto</span><span> entryBB </span><span style=color:#fe8019>= &</span><span>block;
</span><span>        </span><span style=color:#fa5c4b>auto</span><span> originalBB </span><span style=color:#fe8019>=</span><span> entryBB-></span><span style=color:#fdf4c1>splitBasicBlock</span><span>(entryBB-></span><span style=color:#fdf4c1>getFirstNonPHIOrDbgOrLifetime</span><span>(), </span><span style=color:#fdf4c1>Twine(</span><span style=color:#b8bb26>"original"</span><span style=color:#fdf4c1>)</span><span>);
</span><span>        </span><span style=color:#fa5c4b>auto</span><span> terminatorBB </span><span style=color:#fe8019>=</span><span> originalBB-></span><span style=color:#fdf4c1>splitBasicBlock</span><span>(</span><span style=color:#fe8019>--</span><span>originalBB-></span><span style=color:#fdf4c1>end</span><span>(), </span><span style=color:#fdf4c1>Twine(</span><span style=color:#b8bb26>"terminator"</span><span style=color:#fdf4c1>)</span><span>);
</span><span>
</span><span>        </span><span style=color:#928374;font-style:italic>// 构造伪造块
</span><span>        </span><span style=color:#928374;font-style:italic>// 这一步已经构造好了 altered 跳转 original
</span><span>        </span><span style=color:#fa5c4b>auto</span><span> alteredBB </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>createAlteredBB(originalBB, F)</span><span>;
</span><span>
</span><span>        </span><span style=color:#928374;font-style:italic>// 清理 terminator，重新构造跳转关系
</span><span>        entryBB-></span><span style=color:#fdf4c1>getTerminator</span><span>()-></span><span style=color:#fdf4c1>eraseFromParent</span><span>();
</span><span>        originalBB-></span><span style=color:#fdf4c1>getTerminator</span><span>()-></span><span style=color:#fdf4c1>eraseFromParent</span><span>();
</span><span>
</span><span>        </span><span style=color:#928374;font-style:italic>// 构造恒真条件，从 entry 跳转到 original
</span><span>        </span><span style=color:#fa5c4b>auto</span><span> lhs </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>ConstantInt::get(Type::getInt32Ty(F.getContext()), </span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>)</span><span>;
</span><span>        </span><span style=color:#fa5c4b>auto</span><span> rhs </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>ConstantInt::get(Type::getInt32Ty(F.getContext()), </span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>)</span><span>;
</span><span>        </span><span style=color:#fa5c4b>auto</span><span> condition </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>new </span><span style=color:#fdf4c1>ICmpInst(</span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>entryBB, ICmpInst::ICMP_EQ, lhs, rhs, Twine(</span><span style=color:#b8bb26>"condition"</span><span style=color:#fdf4c1>))</span><span>;
</span><span>        </span><span style=color:#fdf4c1>BranchInst::Create(originalBB, alteredBB, (Value </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>)condition, entryBB)</span><span>;
</span><span>
</span><span>        </span><span style=color:#928374;font-style:italic>// 构造恒真条件，从 original 跳转到 terminator
</span><span>        </span><span style=color:#fa5c4b>auto</span><span> lhs2 </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>ConstantInt::get(Type::getInt32Ty(F.getContext()), </span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>)</span><span>;
</span><span>        </span><span style=color:#fa5c4b>auto</span><span> rhs2 </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>ConstantInt::get(Type::getInt32Ty(F.getContext()), </span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>)</span><span>;
</span><span>        </span><span style=color:#fa5c4b>auto</span><span> condition2 </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>new </span><span style=color:#fdf4c1>ICmpInst(</span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>originalBB, ICmpInst::ICMP_EQ, lhs, rhs, Twine(</span><span style=color:#b8bb26>"condition2"</span><span style=color:#fdf4c1>))</span><span>;
</span><span>        </span><span style=color:#fdf4c1>BranchInst::Create(terminatorBB, alteredBB, (Value </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>)condition, originalBB)</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>false</span><span>;
</span><span>}
</span></code></pre><p>混淆过程非常简单，原始基本块分割成三个部分，清除<code>entry</code>和<code>original</code>的<code>terminator</code>并加入恒真条件跳转，false 分支都指定为 <code>altered</code> 即可。<h3 id=3-4-createalteredbb>3.4 createAlteredBB</h3><pre class=language-c++ data-lang=c++ style=color:#fdf4c1aa;background-color:#282828><code class=language-c++ data-lang=c++><span>BasicBlock </span><span style=color:#fe8019>*</span><span style=color:#8ec07c>createAlteredBB</span><span>(BasicBlock </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>original</span><span>, Function </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>F</span><span>) {
</span><span>    </span><span style=color:#928374;font-style:italic>// 构造伪造块
</span><span>    ValueToValueMapTy VMap;
</span><span>    </span><span style=color:#fa5c4b>auto</span><span> altered </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>CloneBasicBlock(original, VMap, Twine(</span><span style=color:#b8bb26>"altered"</span><span style=color:#fdf4c1>), </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>F)</span><span>;
</span><span>
</span><span>    </span><span style=color:#928374;font-style:italic>// 修复伪造块的指令
</span><span>    </span><span style=color:#fa5c4b>auto</span><span> originalInstIt </span><span style=color:#fe8019>=</span><span> original-></span><span style=color:#fdf4c1>begin</span><span>();
</span><span>    </span><span style=color:#fa5c4b>for </span><span>(</span><span style=color:#fa5c4b>auto </span><span style=color:#fe8019>&</span><span>inst </span><span style=color:#fe8019>: *</span><span>altered) {
</span><span>        </span><span style=color:#928374;font-style:italic>// NOTE:
</span><span>        </span><span style=color:#928374;font-style:italic>// 参考链接： https://bbs.pediy.com/thread-266201.htm
</span><span>        </span><span style=color:#928374;font-style:italic>//
</span><span>        </span><span style=color:#928374;font-style:italic>// ... 但是CloneBasicBlock函数进行的克隆并不是完全的克隆，第一他不会对指令的操作数进行替换，比如：
</span><span>        </span><span style=color:#928374;font-style:italic>//
</span><span>        </span><span style=color:#928374;font-style:italic>// ```
</span><span>        </span><span style=color:#928374;font-style:italic>// orig:
</span><span>        </span><span style=color:#928374;font-style:italic>//   %a = ...
</span><span>        </span><span style=color:#928374;font-style:italic>//   %b = fadd %a, ...
</span><span>        </span><span style=color:#928374;font-style:italic>//
</span><span>        </span><span style=color:#928374;font-style:italic>// clone:
</span><span>        </span><span style=color:#928374;font-style:italic>//   %a.clone = ...
</span><span>        </span><span style=color:#928374;font-style:italic>//   %b.clone = fadd %a, ... ; Note that this references the old %a and
</span><span>        </span><span style=color:#928374;font-style:italic>// not %a.clone!
</span><span>        </span><span style=color:#928374;font-style:italic>// ```
</span><span>        </span><span style=color:#928374;font-style:italic>//
</span><span>        </span><span style=color:#928374;font-style:italic>// 在clone出来的基本块中，fadd指令的操作数不是%a.clone，而是%a。
</span><span>        </span><span style=color:#928374;font-style:italic>// 所以之后要通过VMap对所有操作数进行映射，使其恢复正常：
</span><span>        </span><span style=color:#928374;font-style:italic>//
</span><span>        </span><span style=color:#fa5c4b>for </span><span>(</span><span style=color:#fa5c4b>auto</span><span> opi </span><span style=color:#fe8019>=</span><span> inst.</span><span style=color:#fdf4c1>op_begin</span><span>(); opi </span><span style=color:#fe8019>!=</span><span> inst.</span><span style=color:#fdf4c1>op_end</span><span>(); opi</span><span style=color:#fe8019>++</span><span>) {
</span><span>            Value </span><span style=color:#fe8019>*</span><span>v </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>MapValue(</span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>opi, VMap, RF_None, </span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>)</span><span>;
</span><span>            </span><span style=color:#fa5c4b>if </span><span>(v </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>0</span><span>) {
</span><span>                </span><span style=color:#fe8019>*</span><span>opi </span><span style=color:#fe8019>=</span><span> v;
</span><span>            }
</span><span>        }
</span><span>
</span><span>        </span><span style=color:#928374;font-style:italic>// 第二，它不会对PHI Node进行任何处理，PHI Node的前驱块仍然是原始基本块的前驱块，
</span><span>        </span><span style=color:#928374;font-style:italic>// 但是新克隆出来的基本块并没有任何前驱块，所以我们要对PHI Node的前驱块进行remap：
</span><span>        </span><span style=color:#fa5c4b>if </span><span>(</span><span style=color:#fa5c4b>auto</span><span> pn </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>dyn_cast&lt;PHINode>(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>inst)</span><span>) {
</span><span>            </span><span style=color:#fa5c4b>for </span><span>(</span><span style=color:#fa5c4b>unsigned</span><span> j </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>, e </span><span style=color:#fe8019>=</span><span> pn-></span><span style=color:#fdf4c1>getNumIncomingValues</span><span>(); j </span><span style=color:#fe8019>!=</span><span> e; </span><span style=color:#fe8019>++</span><span>j) {
</span><span>                Value </span><span style=color:#fe8019>*</span><span>v </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>MapValue(pn->getIncomingBlock(j), VMap, RF_None, </span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>)</span><span>;
</span><span>                </span><span style=color:#fa5c4b>if </span><span>(v </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>0</span><span>) {
</span><span>                    pn-></span><span style=color:#fdf4c1>setIncomingBlock</span><span>(j, </span><span style=color:#fdf4c1>cast&lt;BasicBlock>(v)</span><span>);
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>
</span><span>        </span><span style=color:#928374;font-style:italic>// 元数据
</span><span>        SmallVector</span><span style=color:#fe8019>&lt;</span><span>pair</span><span style=color:#fe8019>&lt;</span><span style=color:#fa5c4b>unsigned</span><span>, MDNode </span><span style=color:#fe8019>*></span><span>, </span><span style=color:#d3869b>4</span><span style=color:#fe8019>></span><span> MDs;
</span><span>        inst.</span><span style=color:#fdf4c1>getAllMetadata</span><span>(MDs);
</span><span>
</span><span>        </span><span style=color:#928374;font-style:italic>// 修复调试
</span><span>        inst.</span><span style=color:#fdf4c1>setDebugLoc</span><span>(originalInstIt-></span><span style=color:#fdf4c1>getDebugLoc</span><span>());
</span><span>        </span><span style=color:#fe8019>++</span><span>originalInstIt;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#928374;font-style:italic>// 清理原来的 terminator，无条件从 altered 跳转到 original
</span><span>    altered-></span><span style=color:#fdf4c1>getTerminator</span><span>()-></span><span style=color:#fdf4c1>eraseFromParent</span><span>();
</span><span>    </span><span style=color:#fdf4c1>BranchInst::Create(original, altered)</span><span>;
</span><span>
</span><span>    </span><span style=color:#fa5c4b>return</span><span> altered;
</span><span>}
</span></code></pre><p>去除修复指令操作数和 PhiNode 的部分，其实就是复制了原始块的指令，然后将终结指令改成跳转到原始块而已。<h3 id=3-5-bian-yi-he-ce-shi>3.5 编译和测试</h3><p>使用 CMake 编译，在环境设置一节中已经说明了怎么配置，编译得到了 <code>Hello.dll</code> 后用下面的案例程序测试。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>&lt;stdio.h>
</span><span>
</span><span style=color:#fa5c4b>int </span><span style=color:#8ec07c>main</span><span>(</span><span style=color:#fa5c4b>void</span><span>) {
</span><span>    </span><span style=color:#fabd2f>printf</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"hello world"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>0</span><span>;
</span><span>}
</span></code></pre><p>程序保存在 <code>sample/sample.c</code>，测试命令如下。<pre class=language-bash data-lang=bash style=color:#fdf4c1aa;background-color:#282828><code class=language-bash data-lang=bash><span style=color:#928374;font-style:italic># clang 编译得到 bitcode
</span><span style=color:#fdf4c1>clang -emit-llvm .</span><span style=color:#b8bb26>\s</span><span style=color:#fdf4c1>ample</span><span style=color:#b8bb26>\s</span><span style=color:#fdf4c1>ample.c -c -o .</span><span style=color:#b8bb26>\s</span><span style=color:#fdf4c1>ample</span><span style=color:#b8bb26>\s</span><span style=color:#fdf4c1>ample.bc
</span><span style=color:#928374;font-style:italic># opt 启用 hello pass 创建混淆后的新 bitcode
</span><span style=color:#fdf4c1>opt -enable-new-pm</span><span style=color:#fe8019>=</span><span style=color:#fdf4c1>0 -load .</span><span style=color:#b8bb26>\b</span><span style=color:#fdf4c1>uild</span><span style=color:#b8bb26>\H</span><span style=color:#fdf4c1>ello.dll -hello .</span><span style=color:#b8bb26>\s</span><span style=color:#fdf4c1>ample</span><span style=color:#b8bb26>\s</span><span style=color:#fdf4c1>ample.bc -o .</span><span style=color:#b8bb26>\s</span><span style=color:#fdf4c1>ample</span><span style=color:#b8bb26>\s</span><span style=color:#fdf4c1>ample-optimized.bc
</span><span style=color:#928374;font-style:italic># llvm-dis 反汇编混淆后的 bitcode，得到 sample-optimized.ll ，可以拿来看混淆结果
</span><span style=color:#fdf4c1>llvm-dis .</span><span style=color:#b8bb26>\s</span><span style=color:#fdf4c1>ample</span><span style=color:#b8bb26>\s</span><span style=color:#fdf4c1>ample-optimized.bc
</span><span style=color:#928374;font-style:italic># llc 将混淆后的 bitcode 编译出汇编文件，也可以编译出 obj 文件，用 -filetype=obj 就行
</span><span style=color:#928374;font-style:italic># 注意 -O0，不然默认优化就会直接把我们伪造的分支给干掉
</span><span style=color:#fdf4c1>llc .</span><span style=color:#b8bb26>\s</span><span style=color:#fdf4c1>ample</span><span style=color:#b8bb26>\s</span><span style=color:#fdf4c1>ample-optimized.bc -O0 -o .</span><span style=color:#b8bb26>\s</span><span style=color:#fdf4c1>ample.s
</span><span style=color:#928374;font-style:italic># 用 clang 完成最后的汇编和链接
</span><span style=color:#fdf4c1>clang sample.s -o sample.exe
</span></code></pre><p>也可以用 opt 来获得混淆后的代码控制流视图。<pre class=language-bash data-lang=bash style=color:#fdf4c1aa;background-color:#282828><code class=language-bash data-lang=bash><span style=color:#fdf4c1>opt -enable-new-pm</span><span style=color:#fe8019>=</span><span style=color:#fdf4c1>0 -dot-cfg -cfg-func-name</span><span style=color:#fe8019>=</span><span style=color:#fdf4c1>main .</span><span style=color:#b8bb26>\s</span><span style=color:#fdf4c1>ample</span><span style=color:#b8bb26>\s</span><span style=color:#fdf4c1>ample-optimized.bc
</span></code></pre><p><img alt=main src=https://nnnewb.github.io/posts/2021/learning-packer-08/main.webp><p>在IDA打开后看到的结果如下。<p><img alt=image-20211103141258015 src=https://nnnewb.github.io/posts/2021/learning-packer-08/image-20211103141258015.webp><p>再来个更复杂的例子：<a href=https://github.com/nnnewb/crackmes/blob/main/cm02/main.c>main.c</a><p><img alt=image-20211103142352174 src=https://nnnewb.github.io/posts/2021/learning-packer-08/image-20211103142352174.webp><h3 id=3-6-kuo-zhan-bu-tou-ming-wei-ci>3.6 扩展：不透明谓词</h3><p>参考文章：<a href=https://reverseengineering.stackexchange.com/questions/1669/what-is-an-opaque-predicate>what is an opaque predicate</a><p>PS：本人没有相关学术背景，内容东拼西凑，如果存在理解错误或者陈述不准确请指出。<p>概括地说，不透明谓词就是“某种如果程序分析不够充分，就可能错过的东西”。学术上说不透明谓词是始终在一个方向上执行的分支，对程序创建者已知，对分析器未知。<p>例如我们知道程序运行时，<code>LoadLibraryA</code> 加载一个不存在的库会返回 <code>null</code>，但分析器并不清楚我们运行的环境里是否真的存在/不存在这个库，对于分析器来说用<code>LoadLibraryA</code>构造出来的条件跳转就是一个不透明谓词。<p>那透明呢？不知道有没有这样的说法，不透明是分析器可能错过的东西的话，透明就是分析器不会错过的东西，比如 <code>xor eax,eax</code> 再紧跟着 <code>test eax,eax</code>，那么<code>jnz</code>的走向对分析器来说就是已知的——除非分析器根本没这功能。<h2 id=zong-jie>总结</h2><p>首先是完整案例代码：<a href=https://github.com/nnnewb/learning-packer/tree/main/packer8>packer8 - GitHub</a><p>总结知识点：<ul><li>关键类型：<code>Module</code>、<code>Function</code>、<code>BasicBlock</code>、<code>Instruction</code> ...<li>PhiNode<li>终结指令，<code>BranchInst</code>、<code>ReturnInst</code><li>LLVM 工具链：<code>opt</code>、<code>llc</code>、<code>lli</code>、<code>llvm-dis</code><li>关于 new pass manager 的坑：<code>-fno-experimental-new-pass-manager</code>、<code>-enable-new-pm=0</code></ul><p>用 opt 单独搞混淆很麻烦，也不能集成到已有的 cmake/make 项目里。用 clang 加载混淆器的只需要这样：<code>-Xclang -load -Xclang bcf.dll -fno-experimental-new-pass-manager</code> 就可以直接使用 <code>bcf.dll</code> 参与混淆啦。<p>LLVM 13.x 版本的新 pass manager 带来了很多问题，主要是 LLVM 的文档没写怎么把 Pass 注册到新的 PM 里，结果 opt 能跑 clang 又没运行 pass ，就搜来搜去花了很多时间...不过实际动手写过之后会发现 LLVM 是个大宝库，特别适合发挥想象。Pass 来扩展编译器功能还是挺方便扩展的，也能一窥LLVM内部的奇妙世界。<p>原本还打算看看控制流扁平化，毕竟OLLVM都已经开始看了，控制流扁平化不看一下感觉有点说不过去。但是实际上手发现没耐心再读一遍这代码了=。=也许下次。OLLVM代码解读好像有不少帖子了吧，不献丑了。控制流扁平化的代码量也不是很多，慢慢读还是能捋清楚逻辑的。<p>另外还可以发挥想象：能不能用 LLVM Pass 往代码里插入花指令？<p>参考资料：<ul><li><a href=https://llvm.org/docs/CMake.html#cmake-out-of-source-pass>CMake out of source pass - LLVM</a><li><a href=https://llvm.org/docs/WritingAnLLVMPass.html>Writing an LLVM Pass - LLVM</a><li><a href=https://mukulrathi.com/create-your-own-programming-language/llvm-ir-cpp-api-tutorial/>LLVM IR C++ API Tutorial</a><li><a href=http://mayuyu.io/2018/06/04/PhiNode-in-LLVM/>PhiNode in LLVM</a><li><a href=https://www.quora.com/How-do-Terminators-work-in-the-LLVM-IR>How do Terminator work in LLVM IR</a><li><a href=https://llvm.org/docs/CommandGuide/index.html>LLVM Command Guide</a><li><a href=https://bbs.pediy.com/thread-266201.htm>OLLVM 虚假控制流源码学习笔记 - 看雪论坛</a><li><a href=https://github1s.com/0x3f97/ollvm-12.x/blob/HEAD/README.md>0x3f97/ollvm-12.x</a></ul></article><p class=tags-data><a href=/tags/ni-xiang>/逆向/</a> <a href=/tags/windows>/windows/</a> <a href=/tags/c>/c++/</a> <a href=/tags/llvm>/llvm/</a> <a href=/tags/hui-bian>/汇编/</a> <a href=/tags/security>/security/</a> <a href=/tags/binary-analysis>/binary-analysis/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>