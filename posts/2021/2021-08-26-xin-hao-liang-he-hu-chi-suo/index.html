<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>信号量 vs 互斥锁</title><meta content="信号量 vs 互斥锁" name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2021/2021-08-26-xin-hao-liang-he-hu-chi-suo/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content="信号量 vs 互斥锁" property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2021/2021-08-26-xin-hao-liang-he-hu-chi-suo/ property=twitter:url><meta content="信号量 vs 互斥锁" property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2021/2021-08-26-xin-hao-liang-he-hu-chi-suo/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>信号量 vs 互斥锁</h1><p class=author-line>作于：2021-08-26 00:00 ，预计阅读时间 7 分钟<article><p>看 <a href=https://github.com/tmrts/go-patterns/blob/master/synchronization/semaphore.md>go-patterns/semaphore.md at master · tmrts/go-patterns (github.com)</a> 时产生了疑问，信号量为啥长得和互斥锁没啥区别呢。于是就谷歌了一圈，重温下一些关于并发的知识，对比信号量 <em>semaphore</em> 和互斥锁 <em>mutex</em> 。<h2 id=hu-chi-suo-mutex>互斥锁 mutex</h2><p>以 <em>pthread</em> 自带的互斥锁为例，提供了三种不同类型的互斥锁：<ul><li><em>PTHREAD_MUTEX_NORMAL</em> ，普通的互斥锁，不支持死锁检测（<em>does not detect deadlock</em>），不支持递归加锁（<em>relock without first unlocking it</em> 会导致死锁），不检测解锁线程，解锁一个未加锁的互斥锁是未定义行为（<em>undefined behavior</em>）。<li><em>PTHREAD_MUTEX_ERRORCHECK</em>，带错误检查的互斥锁，不支持递归加锁（会返回错误），解锁其他线程的互斥锁会返回错误，解锁未加锁的互斥锁会返回错误。<li><em>PTHREAD_MUTEX_RECURSIVE</em>，递归加锁（<em>relock with out unlocking it</em>）会成功，解锁时需要调用解锁的次数和加锁时调用加锁的次数相同。解锁其他线程的互斥锁会返回错误。解锁未加锁的互斥锁会返回错误。<li><em>PTHREAD_MUTEX_DEFAULT</em>，默认互斥锁类型，对这一类型的互斥锁递归加锁时行为是未定义的，解锁未加锁的互斥锁行为是未定义的，解锁其他线程的互斥锁行为是未定义的。这一类型的互斥锁通常映射为另外几种互斥锁之一。</ul><p>可以比较清楚地看出，互斥锁有三个基本特征：<ul><li>是否可重复加锁<li>是否可解锁未加锁的互斥锁<li>是否可解锁被其他人加锁的互斥锁</ul><p>最严格的 <em>PTHREAD_MUTEX_ERRORCHECK</em> 类型互斥锁，对此定义是 NO、NO、NO 。<p>互斥锁的基本使用方式和使用场景有点像厕所的坑位：<ol><li>抢坑位，锁门<li>你懂的<li>解锁，出门</ol><p>其中有隐含的信息包括：<ol><li>坑位是提前选择好的，你只能抢一个坑位，不能抢多个坑位。<li>坑位在使用期间是独占的，你不能和别人分享一个坑位。<li>只有你自己能解锁坑位，谁也不想办事儿的时候有人闯进来吧？</ol><p>而递归加锁这一特殊场景，我寻思吧，有点难拿坑位比喻。反正也不重要，就别管了。<h2 id=xin-hao-liang-semaphore>信号量 semaphore</h2><p>信号量本质上是一个整型值，不细分什么类型了。还是用 <em>pthread</em> 举例吧，依据 <em>POSIX</em> 标准。<p>对信号量的操作可以先简单分5种。<ul><li><code>sem_init(sem,pshared,value)</code>，初始化一个信号量，可以指定要不要在 <code>fork()</code> 创建的进程间共享，还可以指定信号量初始值。<li><code>sem_wait(sem)</code>，等待信号量，信号量等于0时阻塞，其他线程通过<code>sem_post</code>唤醒。<li><code>sem_post(sem)</code>，发送信号量，唤醒阻塞在<code>sem_wait</code>的线程。<li><code>sem_getvalue(sem,valp)</code>，获取信号量当前值。<li><code>sem_destroy(sem)</code>，销毁信号量。</ul><p>信号量的主要特征就是它的值：<ul><li>当值等于0时，<code>sem_wait</code> 会阻塞。<li>当值大于0时，<code>sem_wait</code> 返回并使值-1。</ul><p>可以注意到，信号量的确可以做到互斥锁能做到的事情：设定好初始值1，然后<code>sem_wait</code>等同于加锁，<code>sem_post</code>等同于解锁，的确模拟出了互斥锁的功能。<p>不过信号量去模拟互斥锁会有一些问题。比如说无法实现递归加锁（信号量值等于0时，<code>sem_wait</code>会阻塞），无法检测解锁线程是不是加锁线程（除非你自己再封装一次，把信号量和线程ID绑定），解锁未加锁会导致信号量值大于1，进而造成<code>sem_wait</code>会允许多个线程并行执行（还是一样，你得自己封装，在<code>sem_post</code>前检查当前信号量的值）。<p>好，模拟互斥锁的话题到此为止。回到屎尿屁的比喻上。互斥锁可以比作公厕收费的老大爷。<ul><li>老规矩，不排队，大家从老大爷手里抢坑位。<li>坑位满员的时候老大爷谁也不让进。<li>每出来一个人，老大爷就放进去一个人。</ul><p>其中隐含的信息包括：<ul><li>当然，可用的坑位或者说资源依然是有限的，数量不确定。<li>你只能独占一部分资源，而且每个人独占的资源都一样多。不然老大爷看到有一个坑位放你进去了，但你想要用两个坑位，那你就只能继续等着，或者和别人分享坑位了。</ul><p>信号量最好用的场景还是 <strong>生产者-消费者</strong> 模型的队列，来统计队列中元素数量。消费者可以用一个简单的 <code>sem_timedwait</code> 调用实现等待新元素加入队列，用互斥锁来确保队列操作是线程安全的。<p>可见管公厕的老大爷也是非常有生活智慧哈，充分利用了年轻时的编程经验来提高晚年生活质量。<h2 id=jie-lun>结论</h2><p>互斥锁和信号量都能处理数据竞争，但各有侧重。<p>典型的数据竞争场景当然是互斥锁好用，但信号量也不是完全不行。<p>信号量的典型场景也一样，互斥锁即便能行也会显得别扭。</article><p class=tags-data><a href=/tags/golang>/golang/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>