<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>自娱自乐 crackme-02</title><meta content="自娱自乐 crackme-02" name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2021/crackme-02/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content="自娱自乐 crackme-02" property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2021/crackme-02/ property=twitter:url><meta content="自娱自乐 crackme-02" property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2021/crackme-02/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>自娱自乐 crackme-02</h1><p class=author-line>作于：2021-09-15 15:43 ，预计阅读时间 18 分钟<article><h2 id=de-you-ge-qian-yan>得有个前言</h2><p>总之上一个 crackme-01 还过得去，稍微加强一点，把密码隐藏起来，不要随便被看到。<h2 id=0x01-yuan-ma>0x01 源码</h2><pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>&lt;stdio.h>
</span><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>&lt;stdlib.h>
</span><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>&lt;string.h>
</span><span>
</span><span style=color:#fabd2f>size_t </span><span style=color:#8ec07c>getline</span><span>(</span><span style=color:#fa5c4b>char </span><span style=color:#fe8019>**</span><span style=color:#fdf4c1>lineptr</span><span>, </span><span style=color:#fabd2f>size_t </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>n</span><span>, FILE </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>stream</span><span>) {
</span><span>  </span><span style=color:#fa5c4b>char </span><span style=color:#fe8019>*</span><span>bufptr </span><span style=color:#fe8019>= </span><span style=color:#d3869b>NULL</span><span>;
</span><span>  </span><span style=color:#fa5c4b>char </span><span style=color:#fe8019>*</span><span>p </span><span style=color:#fe8019>=</span><span> bufptr;
</span><span>  </span><span style=color:#fabd2f>size_t</span><span> size;
</span><span>  </span><span style=color:#fa5c4b>int</span><span> c;
</span><span>
</span><span>  </span><span style=color:#fa5c4b>if </span><span>(lineptr </span><span style=color:#fe8019>== </span><span style=color:#d3869b>NULL</span><span>) {
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>;
</span><span>  }
</span><span>  </span><span style=color:#fa5c4b>if </span><span>(stream </span><span style=color:#fe8019>== </span><span style=color:#d3869b>NULL</span><span>) {
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>;
</span><span>  }
</span><span>  </span><span style=color:#fa5c4b>if </span><span>(n </span><span style=color:#fe8019>== </span><span style=color:#d3869b>NULL</span><span>) {
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>;
</span><span>  }
</span><span>  bufptr </span><span style=color:#fe8019>= *</span><span>lineptr;
</span><span>  size </span><span style=color:#fe8019>= *</span><span>n;
</span><span>
</span><span>  c </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>fgetc</span><span style=color:#fdf4c1>(stream)</span><span>;
</span><span>  </span><span style=color:#fa5c4b>if </span><span>(c </span><span style=color:#fe8019>==</span><span> EOF) {
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>;
</span><span>  }
</span><span>  </span><span style=color:#fa5c4b>if </span><span>(bufptr </span><span style=color:#fe8019>== </span><span style=color:#d3869b>NULL</span><span>) {
</span><span>    bufptr </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>malloc</span><span style=color:#fdf4c1>(</span><span style=color:#d3869b>128</span><span style=color:#fdf4c1>)</span><span>;
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(bufptr </span><span style=color:#fe8019>== </span><span style=color:#d3869b>NULL</span><span>) {
</span><span>      </span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>;
</span><span>    }
</span><span>    size </span><span style=color:#fe8019>= </span><span style=color:#d3869b>128</span><span>;
</span><span>  }
</span><span>  p </span><span style=color:#fe8019>=</span><span> bufptr;
</span><span>  </span><span style=color:#fa5c4b>while </span><span>(c </span><span style=color:#fe8019>!=</span><span> EOF) {
</span><span>    </span><span style=color:#fa5c4b>if </span><span>((p </span><span style=color:#fe8019>-</span><span> bufptr) </span><span style=color:#fe8019>> </span><span>(size </span><span style=color:#fe8019>- </span><span style=color:#d3869b>1</span><span>)) {
</span><span>      size </span><span style=color:#fe8019>=</span><span> size </span><span style=color:#fe8019>+ </span><span style=color:#d3869b>128</span><span>;
</span><span>      bufptr </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>realloc</span><span style=color:#fdf4c1>(bufptr, size)</span><span>;
</span><span>      </span><span style=color:#fa5c4b>if </span><span>(bufptr </span><span style=color:#fe8019>== </span><span style=color:#d3869b>NULL</span><span>) {
</span><span>        </span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>;
</span><span>      }
</span><span>    }
</span><span>    </span><span style=color:#fe8019>*</span><span>p</span><span style=color:#fe8019>++ =</span><span> c;
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(c </span><span style=color:#fe8019>== </span><span style=color:#b8bb26>'\n'</span><span>) {
</span><span>      </span><span style=color:#fa5c4b>break</span><span>;
</span><span>    }
</span><span>    c </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>fgetc</span><span style=color:#fdf4c1>(stream)</span><span>;
</span><span>  }
</span><span>
</span><span>  </span><span style=color:#fe8019>*</span><span>p</span><span style=color:#fe8019>++ = </span><span style=color:#b8bb26>'\0'</span><span>;
</span><span>  </span><span style=color:#fe8019>*</span><span>lineptr </span><span style=color:#fe8019>=</span><span> bufptr;
</span><span>  </span><span style=color:#fe8019>*</span><span>n </span><span style=color:#fe8019>=</span><span> size;
</span><span>
</span><span>  </span><span style=color:#fa5c4b>return</span><span> p </span><span style=color:#fe8019>-</span><span> bufptr </span><span style=color:#fe8019>- </span><span style=color:#d3869b>1</span><span>;
</span><span>}
</span><span>
</span><span style=color:#fabd2f>size_t </span><span style=color:#8ec07c>r_trim</span><span>(</span><span style=color:#fa5c4b>char </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>str</span><span>, </span><span style=color:#fabd2f>size_t </span><span style=color:#fdf4c1>len</span><span>) {
</span><span>  </span><span style=color:#fabd2f>size_t</span><span> slen </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>strnlen(str, len)</span><span>;
</span><span>  </span><span style=color:#fa5c4b>for </span><span>(</span><span style=color:#fabd2f>size_t</span><span> i </span><span style=color:#fe8019>=</span><span> slen </span><span style=color:#fe8019>- </span><span style=color:#d3869b>1</span><span>; i </span><span style=color:#fe8019>>= </span><span style=color:#d3869b>0</span><span>; i</span><span style=color:#fe8019>++</span><span>) {
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(str[i] </span><span style=color:#fe8019>== </span><span style=color:#b8bb26>' ' </span><span style=color:#fe8019>||</span><span> str[i] </span><span style=color:#fe8019>== </span><span style=color:#b8bb26>'\n' </span><span style=color:#fe8019>||</span><span> str[i] </span><span style=color:#fe8019>== </span><span style=color:#b8bb26>'\r'</span><span>) {
</span><span>      str[i] </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>'\0'</span><span>;
</span><span>    } </span><span style=color:#fa5c4b>else </span><span>{
</span><span>      </span><span style=color:#fa5c4b>break</span><span>;
</span><span>    }
</span><span>  }
</span><span>  </span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>strnlen(str, len)</span><span>;
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>char </span><span style=color:#fe8019>*</span><span style=color:#8ec07c>calculate</span><span>(</span><span style=color:#fa5c4b>char </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>username</span><span>, </span><span style=color:#fa5c4b>const </span><span style=color:#fabd2f>size_t </span><span style=color:#fdf4c1>username_len</span><span>) {
</span><span>  </span><span style=color:#928374;font-style:italic>// 初始化固定8字节计算密钥的空间
</span><span>  </span><span style=color:#fa5c4b>const </span><span style=color:#fabd2f>size_t</span><span> input_buf_len </span><span style=color:#fe8019>= </span><span style=color:#d3869b>8</span><span>;
</span><span>  </span><span style=color:#fa5c4b>char </span><span style=color:#fe8019>*</span><span>input_buf </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>malloc</span><span style=color:#fdf4c1>(input_buf_len)</span><span>;
</span><span>  </span><span style=color:#fa5c4b>for </span><span>(</span><span style=color:#fabd2f>size_t</span><span> i </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>; i </span><span style=color:#fe8019>&lt;</span><span> input_buf_len; i</span><span style=color:#fe8019>++</span><span>) {
</span><span>    input_buf[i] </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x52 </span><span style=color:#fe8019>+</span><span> i;
</span><span>  }
</span><span>  </span><span style=color:#928374;font-style:italic>// 用用户输入替换初始化的数据
</span><span>  </span><span style=color:#fdf4c1>memcpy_s(input_buf, input_buf_len, username, username_len)</span><span>;
</span><span>
</span><span>  </span><span style=color:#928374;font-style:italic>// 异或处理
</span><span>  </span><span style=color:#fa5c4b>for </span><span>(</span><span style=color:#fabd2f>size_t</span><span> i </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>; i </span><span style=color:#fe8019>&lt;</span><span> input_buf_len; i</span><span style=color:#fe8019>++</span><span>) {
</span><span>    input_buf[i] </span><span style=color:#fe8019>^= </span><span style=color:#d3869b>0x25</span><span>;
</span><span>  }
</span><span>
</span><span>  </span><span style=color:#928374;font-style:italic>// 初始化 Hex 输出
</span><span>  </span><span style=color:#fa5c4b>const </span><span style=color:#fabd2f>size_t</span><span> output_buf_len </span><span style=color:#fe8019>= </span><span style=color:#d3869b>17</span><span>;
</span><span>  </span><span style=color:#fa5c4b>char </span><span style=color:#fe8019>*</span><span>output_buf </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>malloc</span><span style=color:#fdf4c1>(output_buf_len)</span><span>;
</span><span>
</span><span>  </span><span style=color:#928374;font-style:italic>// 转为可读字符串
</span><span>  </span><span style=color:#fa5c4b>for </span><span>(</span><span style=color:#fabd2f>size_t</span><span> i </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>; i </span><span style=color:#fe8019>&lt;</span><span> input_buf_len; i</span><span style=color:#fe8019>++</span><span>) {
</span><span>    </span><span style=color:#fabd2f>sprintf</span><span style=color:#fdf4c1>(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>output_buf[i </span><span style=color:#fe8019>* </span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>], </span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>%02x</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>, input_buf[i])</span><span>;
</span><span>  }
</span><span>
</span><span>  output_buf[</span><span style=color:#d3869b>16</span><span>] </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>;
</span><span>  </span><span style=color:#fabd2f>free</span><span style=color:#fdf4c1>(input_buf)</span><span>;
</span><span>  </span><span style=color:#fa5c4b>return</span><span> output_buf;
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>int </span><span style=color:#8ec07c>main</span><span>() {
</span><span>  </span><span style=color:#fa5c4b>while </span><span>(</span><span style=color:#d3869b>1</span><span>) {
</span><span>    </span><span style=color:#fa5c4b>char </span><span style=color:#fe8019>*</span><span>username </span><span style=color:#fe8019>= </span><span style=color:#d3869b>NULL</span><span>;
</span><span>    </span><span style=color:#fabd2f>size_t</span><span> username_len </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>;
</span><span>    </span><span style=color:#fa5c4b>char </span><span style=color:#fe8019>*</span><span>serial </span><span style=color:#fe8019>= </span><span style=color:#d3869b>NULL</span><span>;
</span><span>    </span><span style=color:#fabd2f>size_t</span><span> serial_len </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>;
</span><span>    </span><span style=color:#fabd2f>size_t</span><span> linesize </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>;
</span><span>
</span><span>    </span><span style=color:#fabd2f>printf</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"username:"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>    linesize </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>getline(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>username, </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>username_len, stdin)</span><span>;
</span><span>    username_len </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>r_trim(username, linesize)</span><span>;
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(username_len </span><span style=color:#fe8019>> </span><span style=color:#d3869b>8</span><span>) {
</span><span>      </span><span style=color:#fabd2f>free</span><span style=color:#fdf4c1>(username)</span><span>;
</span><span>      </span><span style=color:#fabd2f>puts</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"username less than 8 letter"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>      </span><span style=color:#fa5c4b>continue</span><span>;
</span><span>    } </span><span style=color:#fa5c4b>else if </span><span>(username_len </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0</span><span>) {
</span><span>      </span><span style=color:#fabd2f>free</span><span style=color:#fdf4c1>(username)</span><span>;
</span><span>      </span><span style=color:#fa5c4b>continue</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fabd2f>printf</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"serial:"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>    linesize </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>getline(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>serial, </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>serial_len, stdin)</span><span>;
</span><span>    serial_len </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>r_trim(serial, linesize)</span><span>;
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(serial_len </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>16</span><span>) {
</span><span>      </span><span style=color:#fabd2f>free</span><span style=color:#fdf4c1>(username)</span><span>;
</span><span>      </span><span style=color:#fabd2f>free</span><span style=color:#fdf4c1>(serial)</span><span>;
</span><span>      </span><span style=color:#fabd2f>puts</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"serial has 16 letters"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>      </span><span style=color:#fa5c4b>continue</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa5c4b>char </span><span style=color:#fe8019>*</span><span>correct </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>calculate(username, username_len)</span><span>;
</span><span>    </span><span style=color:#fa5c4b>int</span><span> rc </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>strncmp</span><span style=color:#fdf4c1>(serial, correct, </span><span style=color:#d3869b>16</span><span style=color:#fdf4c1>)</span><span>;
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(rc </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0</span><span>) {
</span><span>      </span><span style=color:#fabd2f>free</span><span style=color:#fdf4c1>(correct)</span><span>;
</span><span>      </span><span style=color:#fabd2f>puts</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"Good job!"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>      </span><span style=color:#fa5c4b>break</span><span>;
</span><span>    } </span><span style=color:#fa5c4b>else </span><span>{
</span><span>      </span><span style=color:#fabd2f>puts</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"wrong pwd!"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>    }
</span><span>    </span><span style=color:#fabd2f>free</span><span style=color:#fdf4c1>(username)</span><span>;
</span><span>    </span><span style=color:#fabd2f>free</span><span style=color:#fdf4c1>(serial)</span><span>;
</span><span>    </span><span style=color:#fabd2f>free</span><span style=color:#fdf4c1>(correct)</span><span>;
</span><span>  }
</span><span>  </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>0</span><span>;
</span><span>}
</span></code></pre><p>编译方式是<pre class=language-bat data-lang=bat style=color:#fdf4c1aa;background-color:#282828><code class=language-bat data-lang=bat><span>clang main.c -o cm02-easy.exe -Wall -m32 -O0
</span><span>clang main.c -o cm02-normal.exe -Wall -m32 -O1
</span><span>clang main.c -o cm02-hard.exe -Wall -m32 -O2
</span></code></pre><h2 id=0x02-guan-cha>0x02 观察</h2><p>启动后观察行为（不截图了。）<pre style=color:#fdf4c1aa;background-color:#282828><code><span>weakptr in cm02 ❯ .\cm02-easy.exe
</span><span>username:abc
</span><span>serial:123456
</span><span>serial 长度为16
</span><span>username:abc
</span><span>serial:123456789012345 
</span><span>wrong pwd!
</span><span>username:
</span><span>serial:
</span><span>serial 长度为16
</span><span>username:abc
</span><span>serial:aaaaaaaaaaaaaaa
</span><span>wrong pwd!
</span></code></pre><p>这次的目标是：<ol><li>得到某个用户名对应的序列号（<code>serial</code>）。<li>破解，总是正确或对任何输入都提示正确。<li>注册机。</ol><h2 id=0x03-jing-tai-fen-xi-easy>0x03 静态分析 - easy</h2><h3 id=3-1-zhu-xun-huan>3.1 主循环</h3><p>在公司没IDA，用 <a href=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/https://cutter.re/>Cutter</a> 打开，在上方输入框输入 <code>main</code> 跳转到 <code>main</code> 函数。<p><img alt=image-20210914114426600 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-1.webp><p>然后点击 <em>图表（main）</em> 进入类似 IDA 的控制流视图。<p><img alt=image-20210914114547128 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-2.webp><p>之后就能看到下面的控制流了。<p><img alt src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-3.webp><p>easy难度下没有开启任何编译器优化，控制流和原始代码能直接对应上。瞧着困难很多对吧？<p>先简单扫一眼，会发现很多分支直接跳回了<code>0x0040139d</code>，也就是从上往下数第二个代码块，基本每个跳转都是下一个块或跳回这个块。按照 <a href=https://nnnewb.github.io/blog/p/crackme-01/>cm01</a>的经验，我们先找到关键的一跳。可以直接搜索字符串引用（<code>wrong pwd!</code>），也可以逐个代码块看下去。<p>很快，右下角的关键跳出现在眼前。<p><img alt=image-20210914152834262 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-4.webp><p>接着回头看跳转条件。<p><img alt=image-20210914153728179 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-5.webp><p>虽然没有名字，但<code>fcn.00403ef4</code> 是老熟人了。三个参数，<code>ecx</code>、<code>eax</code>、<code>0x10</code>，返回结果和<code>0</code>做比较，<code>jne</code>条件跳转。<ul><li><code>cmp</code>指令，操作数相减（<code>dest</code>-<code>src</code>），结果存入标志位 <code>SF</code>和<code>ZF</code>。 <ul><li>结果是负数（<code>dest</code>&lt;<code>src</code>），<code>SF</code>也就是结果符号位设置为1。<li>结果是正数（<code>dest</code>><code>src</code>），<code>SF</code>也就是结果符号位设置为0。<li>结果是0（<code>dest</code>=<code>src</code>），<code>ZF</code>设置为1。</ul><li><code>jne</code>或<code>jnz</code>指令，非零跳转。<code>ZF</code>标志位为<code>1</code>时跳转。</ul><p>猜测这个函数应该是<code>strncmp</code>。继续往回看参数是怎么来的。<p><img alt=image-20210914155544252 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-6.webp><p><code>eax</code>来自<code>sub.02x_40298c</code>这个函数，后面两个脱裤子放屁的<code>mov</code>忽略。<code>ecx</code>则来来自<code>mov ecx,dword [ebp-10h]</code>这一行。<p>先不着急分析函数，继续往回找，找到<code>[ebp-10h]</code>的来源。<p><img alt=image-20210914161814604 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-7.webp><p>在入口点附近，看到<code>[ebp-10]</code>被初始化成了0。<p>因为没有很明确的路径，手动计算栈上偏移又非常麻烦，这里本应该掏出调试器——但出于学习练手的目的，还是先尝试计算下。首先回顾下简化的栈内存布局，从上往下增长，如图。<p><img alt=stack-layout src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-8.webp><p>接下来从<code>mov ebp,esp</code>开始，往下列出所有函数调用，捋一捋逻辑。<p><img alt=image-20210914214920437 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-9.webp><p>第一个框，<code>[esp+2ch+Ix]</code> 计算结果是 <code>[esp]</code>，也就是栈顶，栈顶设置为字符串 <code>username:</code>，接着调用一个未知函数。从参数判断我们先认为是一个输出字符串的函数。<p>再看第二个框，<code>acrt_iob_func</code>，百度一下就会发现，<code>__acrt_iob_func</code>函数是定义于 c 运行库里的函数，作用是返回 <code>stdin/stdout/stderr</code> 。栈顶设置为0，所以获得的是 <code>stdin</code>。<p>再看第三个框，<code>edx</code>和<code>ecx</code>赋值为栈上两个变量的地址，再为参数。按顺序就是<code>f(edx,ecx,stdin)</code>。暂时不明。函数返回值被赋值回了<code>[ebp-18h]</code>。<p>第四个框，从第三个框得到的返回值被当参数传给一个未知函数。<code>f([ebp-8h], [ebp-18h])</code>，返回值被赋值回 <code>[ebp-0Ch]</code>。<p>结合最后的 <code>cmp</code> 和 <code>jbe</code> 指令分析，人肉反编译后用伪代码表示，就是下面这样。<code>jbe</code>指令只在<code>cmp</code>左操作数小于等于右操作数时执行跳转（<code>CF</code>标志位和<code>ZF</code>标志位其中一个为1时）。<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>var var_8 </span><span style=color:#928374;font-style:italic># 偏移值 ebp-8h
</span><span>var var_0C </span><span style=color:#928374;font-style:italic># 偏移值 ebp-0Ch
</span><span>var var_18 </span><span style=color:#928374;font-style:italic># 偏移值 ebp-18h
</span><span>
</span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"username:"</span><span style=color:#fdf4c1>)
</span><span>var_18 </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>unknown_func1(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>var_8,</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>var_0c,stdin)
</span><span>var_0c </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>unknown_func2(var_8, var_18)
</span><span style=color:#fa5c4b>if </span><span>var_0c </span><span style=color:#fe8019>&lt;= </span><span style=color:#d3869b>8</span><span>:
</span><span>    </span><span style=color:#d3869b>... </span><span style=color:#928374;font-style:italic># jbe 跳转执行
</span></code></pre><p><img alt=image-20210914223919137 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-10.webp><p>可以看出，当 <code>var_0c</code> 小于 8 时，提示 <code>username less than 8 letter</code> 。因此可以确定 <code>[ebp-0Ch]</code> 这个变量就是 <code>username</code> 字符串的长度，上一个函数会计算字符串长度返回。我们再根据这个发现修改下伪代码。<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>var var_8 </span><span style=color:#928374;font-style:italic># 偏移值 ebp-8h
</span><span>var username_len </span><span style=color:#928374;font-style:italic># 偏移值 ebp-0Ch
</span><span>var var_18 </span><span style=color:#928374;font-style:italic># 偏移值 ebp-18h
</span><span>
</span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"username:"</span><span style=color:#fdf4c1>)
</span><span>var_18 </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>unknown_func1(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>var_8,</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>username_len,stdin) </span><span style=color:#928374;font-style:italic># var_8 可能是 username 指针
</span><span>username_len </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>unknown_func2(var_8, var_18) </span><span style=color:#928374;font-style:italic># 计算字符串长度
</span><span style=color:#fa5c4b>if </span><span>username_len </span><span style=color:#fe8019>&lt;= </span><span style=color:#d3869b>8</span><span>:
</span><span>    </span><span style=color:#d3869b>... </span><span style=color:#928374;font-style:italic># jbe 跳转执行
</span><span style=color:#fa5c4b>else</span><span>:
</span><span>    </span><span style=color:#928374;font-style:italic># jmp 到开头
</span><span>
</span></code></pre><p>第一个未知函数看起来已经呼之欲出了，<code>stdin</code>和<code>&username_len</code>作为参数，<code>var_8</code> 有极大可能就是<code>username</code>字符串指针。不过在进入调试器前，还不能马上下结论，继续看正确跳转的代码。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#fa5c4b>cmp </span><span style=color:#fdf4c1>[ebp-</span><span style=color:#d3869b>0Ch</span><span style=color:#fdf4c1>], </span><span style=color:#d3869b>0
</span><span style=color:#fa5c4b>jnz </span><span style=color:#8ec07c>...
</span></code></pre><p>这次是比较用户名长度和0，非0跳转。<p><img alt=image-20210914224625891 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-11.webp><p>可以看到为零时，经过一个未知函数 <code>sub_4036FC(var_8)</code> 后，跳回开头。<p>继续看正确流程，<code>jmp $+5</code> ，<code>$</code> 表示当前正在执行的代码在代码段内的偏移量，+5就是从当前代码开始往后跳过5个字节，我们直接看IDA分析好的跳转位置。<p><img alt=image-20210914225052452 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-12.webp><p>又是非常熟悉的代码，和读取 <code>username</code> 的分析方式相同，以相同的顺序调用相同的函数，可以得到<code>var_14</code>是<code>serial_len</code>，<code>Str1</code>可能是<code>serial</code>字符串指针。不做重复分析，继续往下看。<p><img alt=image-20210914225322787 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-13.webp><p>右边的代码块是关于长度的判断，分析方法不再重复。左侧代码就是我们的关键跳转了，其中出现两个函数调用。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, [ebp+</span><span style=color:#8ec07c>var_C</span><span style=color:#fdf4c1>]
</span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>ecx, [ebp+</span><span style=color:#8ec07c>Block</span><span style=color:#fdf4c1>]
</span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>[esp+</span><span style=color:#d3869b>2Ch</span><span style=color:#fdf4c1>+</span><span style=color:#8ec07c>Ix</span><span style=color:#fdf4c1>], ecx</span><span style=color:#928374;font-style:italic> ; void *
</span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>[esp+</span><span style=color:#d3869b>2Ch</span><span style=color:#fdf4c1>+</span><span style=color:#8ec07c>Str2</span><span style=color:#fdf4c1>], eax</span><span style=color:#928374;font-style:italic> ; size_t
</span><span style=color:#fa5c4b>call    </span><span style=color:#8ec07c>sub_401250
</span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>[ebp+</span><span style=color:#8ec07c>var_1C</span><span style=color:#fdf4c1>], eax
</span></code></pre><p><code>var_c</code>先前被判断是<code>username_len</code>，<code>Block</code>就是<code>var_8</code>，先前被怀疑是用户键入的用户名字符串指针。未知函数的返回值保存在 <code>[ebp-1ch]</code>中。<p>这个<code>1c</code>在随后的代码中立刻被用到。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, [ebp+</span><span style=color:#8ec07c>var_1C</span><span style=color:#fdf4c1>]
</span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>ecx, [ebp+</span><span style=color:#8ec07c>Str1</span><span style=color:#fdf4c1>]
</span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>[esp+</span><span style=color:#d3869b>2Ch</span><span style=color:#fdf4c1>+</span><span style=color:#8ec07c>Ix</span><span style=color:#fdf4c1>], ecx</span><span style=color:#928374;font-style:italic> ; Str1
</span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>[esp+</span><span style=color:#d3869b>2Ch</span><span style=color:#fdf4c1>+</span><span style=color:#8ec07c>Str2</span><span style=color:#fdf4c1>], eax</span><span style=color:#928374;font-style:italic> ; Str2
</span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>[esp+</span><span style=color:#d3869b>2Ch</span><span style=color:#fdf4c1>+</span><span style=color:#8ec07c>MaxCount</span><span style=color:#fdf4c1>], </span><span style=color:#d3869b>10h</span><span style=color:#928374;font-style:italic> ; MaxCount
</span><span style=color:#fa5c4b>call    </span><span style=color:#8ec07c>_strncmp
</span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>[ebp+</span><span style=color:#8ec07c>var_20</span><span style=color:#fdf4c1>], eax
</span></code></pre><p><code>Str1</code>在<code>serial</code>输入这一步被怀疑是用户输入的序列号字符串指针，它和上一个函数调用返回的<code>var_1c</code>被作为参数传递给<code>strncmp</code>，字符串长度最大16字节。由此可见，<code>var_1c</code>基本可以确定是正确序列号的指针，之前的未知函数可能就是生成序列号的函数。<p>下一步分析序列号生成函数。<h3 id=3-2-sheng-cheng-xu-lie-hao>3.2 生成序列号</h3><p>先看下控制流全览，能依稀分辨出三个循环。<p><img alt=generate src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-14.webp><p>自动分析出的变量表<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#928374;font-style:italic>; var uint32_t var_1ch @ ebp-0x1c
</span><span style=color:#928374;font-style:italic>; var int32_t var_18h @ ebp-0x18
</span><span style=color:#928374;font-style:italic>; var int32_t var_14h @ ebp-0x14
</span><span style=color:#928374;font-style:italic>; var uint32_t var_10h @ ebp-0x10
</span><span style=color:#928374;font-style:italic>; var uint32_t var_ch @ ebp-0xc
</span><span style=color:#928374;font-style:italic>; var int32_t var_8h @ ebp-0x8
</span><span style=color:#928374;font-style:italic>; var int32_t var_4h @ ebp-0x4
</span><span style=color:#928374;font-style:italic>; arg uint32_t arg_8h @ ebp+0x8
</span><span style=color:#928374;font-style:italic>; arg int32_t arg_ch @ ebp+0xc
</span><span style=color:#928374;font-style:italic>; var int32_t var_sp_4h @ esp+0x4
</span><span style=color:#928374;font-style:italic>; var int32_t var_sp_8h @ esp+0x8
</span><span style=color:#928374;font-style:italic>; var int32_t var_sp_ch @ esp+0xc
</span></code></pre><p>先看循环外的代码，简单按用途划一下分隔线。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#d3869b>0x004071f0      </span><span style=color:#fa5c4b>push    </span><span style=color:#fdf4c1>ebp
</span><span style=color:#d3869b>0x004071f1      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>ebp, esp
</span><span style=color:#d3869b>0x004071f3      </span><span style=color:#fa5c4b>sub     </span><span style=color:#fdf4c1>esp, </span><span style=color:#d3869b>0x2c
</span><span style=color:#928374;font-style:italic>; ---
</span><span style=color:#d3869b>0x004071f6      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>arg_ch</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x004071f9      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>arg_8h</span><span style=color:#fdf4c1>]
</span><span style=color:#928374;font-style:italic>; ---
</span><span style=color:#d3869b>0x004071fc      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_4h</span><span style=color:#fdf4c1>], </span><span style=color:#d3869b>8
</span><span style=color:#928374;font-style:italic>; ---
</span><span style=color:#d3869b>0x00407203      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[esp], </span><span style=color:#d3869b>8
</span><span style=color:#d3869b>0x0040720a      </span><span style=color:#fa5c4b>call    </span><span style=color:#8ec07c>fcn.</span><span style=color:#d3869b>00401302
</span><span style=color:#d3869b>0x0040720f      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_8h</span><span style=color:#fdf4c1>], eax
</span><span style=color:#928374;font-style:italic>; ---
</span><span style=color:#d3869b>0x00407212      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_ch</span><span style=color:#fdf4c1>], </span><span style=color:#d3869b>0
</span></code></pre><p>开头是惯例的两句栈帧准备动作，随后开辟 0x2c 大小的栈空间。<p>两个没用的 <code>mov eax,...</code>，之后是<code>[ebp-4h]</code>设置为8，再把8作为参数调用了一个未知函数，返回值赋值给<code>[ebp-8h]</code>，再初始化<code>[ebp-ch]</code>为 0。伪代码表示就是下面这样。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>int</span><span> var_4h, var_8h， var_ch; </span><span style=color:#928374;font-style:italic>// ebp-4h, ebp-8h, ebp-ch
</span><span>var_4h </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x8</span><span>;
</span><span>var_8h </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>unknown_func(</span><span style=color:#d3869b>0x8</span><span style=color:#fdf4c1>)</span><span>;
</span><span>var_ch </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x0</span><span>;
</span></code></pre><p>然后是一个条件跳转。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#d3869b>0x00407219      </span><span style=color:#fa5c4b>cmp     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_ch</span><span style=color:#fdf4c1>], </span><span style=color:#d3869b>8
</span><span style=color:#d3869b>0x0040721d      </span><span style=color:#fa5c4b>jae     </span><span style=color:#d3869b>0x407242
</span></code></pre><p>学习下<code>jae</code>指令。<code>jae</code>指令和<code>jnc</code>指令相同，<code>CF=0</code>则跳转。<code>jae</code> 可以看作 <em>Jump if above or equals</em>。上一句 <code>cmp</code> 计算 <code>var_ch - 0x8</code> ，对相关标志位赋值。<code>jae</code>指令根据<code>CF</code>标志位判断，由于<code>cmp</code>指令是减法，所以判断的是减法中有没有出现 <em>借位</em> 。<p>简单的描述就是，<code>cmp ax, bx</code>，如果<code>ax &lt; bx</code> 则 <code>CF=1</code>，如果 <code>ax >= bx</code> 则 <code>CF=0</code>。<p>因为我们知道 <code>var_ch</code> 刚被初始化成了0，不成立，继续看不成立的分支。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#d3869b>0x00407223      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_ch</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x00407226      </span><span style=color:#fa5c4b>add     </span><span style=color:#fdf4c1>eax, </span><span style=color:#d3869b>0x52</span><span style=color:#928374;font-style:italic>  ; 82
</span><span style=color:#d3869b>0x00407229      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>dl, al
</span><span style=color:#928374;font-style:italic>; ---
</span><span style=color:#d3869b>0x0040722b      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_8h</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x0040722e      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>ecx, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_ch</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x00407231      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>byte </span><span style=color:#fdf4c1>[eax + ecx], dl
</span><span style=color:#928374;font-style:italic>; ---
</span><span style=color:#d3869b>0x00407234      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_ch</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x00407237      </span><span style=color:#fa5c4b>add     </span><span style=color:#fdf4c1>eax, </span><span style=color:#d3869b>1
</span><span style=color:#d3869b>0x0040723a      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_ch</span><span style=color:#fdf4c1>], eax
</span><span style=color:#d3869b>0x0040723d      </span><span style=color:#fa5c4b>jmp     </span><span style=color:#d3869b>0x407219
</span></code></pre><p>把<code>var_ch</code>移入寄存器<code>eax</code>后，加上<code>0x52</code>，又移动<code>al</code>到<code>dl</code>。后续<code>eax</code>被用作别的用途，这一番操作其实就是给<code>dl</code>赋值了一个<code>(int16_t)0x52+var_ch</code>。<p>随后把<code>var_8h</code>和<code>var_ch</code>相加后的地址赋值 <code>dl</code>，也就是<code>0x52</code>。<p>接着<code>var_ch</code>自增1，跳回 <code>jae</code>判断前的 <code>cmp</code>，形成循环，我们用伪代码表示。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>int</span><span> var_4h, var_8h， var_ch; </span><span style=color:#928374;font-style:italic>// ebp-4h, ebp-8h, ebp-ch
</span><span>var_4h </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x8</span><span>;
</span><span>var_8h </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>unknown_func(</span><span style=color:#d3869b>0x8</span><span style=color:#fdf4c1>)</span><span>;
</span><span>var_ch </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x0</span><span>;
</span><span style=color:#fa5c4b>while</span><span>(var_ch </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>8</span><span>) {
</span><span>    </span><span style=color:#fe8019>*</span><span>(var_8h </span><span style=color:#fe8019>+</span><span> var_ch) </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x52 </span><span style=color:#fe8019>+</span><span> var_ch;
</span><span>    var_ch</span><span style=color:#fe8019>++</span><span>;
</span><span>}
</span></code></pre><p>从结构上看，是一个典型的 for 循环。 <code>var_8h</code> 是一个未知函数返回的指针。我们稍微改下伪代码。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>int</span><span> var_4h, var_8h; </span><span style=color:#928374;font-style:italic>// ebp-4h, ebp-8h
</span><span>var_4h </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x8</span><span>;
</span><span>var_8h </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>unknown_func(</span><span style=color:#d3869b>0x8</span><span style=color:#fdf4c1>)</span><span>;
</span><span>
</span><span style=color:#fa5c4b>for </span><span>(</span><span style=color:#fa5c4b>int</span><span> var_ch</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span>; var_ch </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>8</span><span>; var_ch</span><span style=color:#fe8019>++</span><span>) { </span><span style=color:#928374;font-style:italic>// var_ch -> ebp-ch
</span><span>    var_8h[var_ch] </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x52 </span><span style=color:#fe8019>+</span><span> var_ch;
</span><span>}
</span></code></pre><p>接着继续看循环结束后的代码。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#d3869b>0x00407242      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>arg_ch</span><span style=color:#fdf4c1>]</span><span style=color:#928374;font-style:italic> ; ebp+ch 函数右往左数第二个入参
</span><span style=color:#d3869b>0x00407245      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>ecx, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>arg_8h</span><span style=color:#fdf4c1>]</span><span style=color:#928374;font-style:italic> ; ebp+8h 函数右往左数第一个入参
</span><span style=color:#d3869b>0x00407248      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>edx, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_8h</span><span style=color:#fdf4c1>]</span><span style=color:#928374;font-style:italic> ; ebp-8h
</span><span style=color:#928374;font-style:italic>; ---
</span><span style=color:#d3869b>0x0040724b      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[esp], edx
</span><span style=color:#d3869b>0x0040724e      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_sp_4h</span><span style=color:#fdf4c1>], </span><span style=color:#d3869b>8
</span><span style=color:#d3869b>0x00407256      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_sp_8h</span><span style=color:#fdf4c1>], ecx
</span><span style=color:#d3869b>0x0040725a      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_sp_ch</span><span style=color:#fdf4c1>], eax
</span><span style=color:#d3869b>0x0040725e      </span><span style=color:#fa5c4b>call    </span><span style=color:#8ec07c>fcn.</span><span style=color:#d3869b>00407310
</span><span style=color:#d3869b>0x00407263      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_10h</span><span style=color:#fdf4c1>], </span><span style=color:#d3869b>0
</span></code></pre><p>从之前分析主循环的代码，我们可以发现 <code>arg_8h</code> 其实是用户名字符串指针，<code>arg_ch</code>是用户名字符串长度。<p>接着这两个入参，和 <code>var_8h</code>，也就是之前得到指针，传入一个未知函数，随后再初始化了一个变量 <code>var_10h</code>。<p>伪代码如下。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fdf4c1>unknown_func(var_8h, </span><span style=color:#d3869b>0x8</span><span style=color:#fdf4c1>, username, username_len)</span><span>; </span><span style=color:#928374;font-style:italic>// 猜测的函数签名 func(void*, int, void*, int)
</span><span style=color:#fa5c4b>int</span><span> var_10h </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>;
</span></code></pre><p>接着又是一个条件跳转。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#d3869b>0x0040726a      </span><span style=color:#fa5c4b>cmp     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_10h</span><span style=color:#fdf4c1>], </span><span style=color:#d3869b>8
</span><span style=color:#d3869b>0x0040726e      </span><span style=color:#fa5c4b>jae     </span><span style=color:#d3869b>0x407292
</span></code></pre><p>和先前的循环相同，不作重复分析，直接进入循环体。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#d3869b>0x00407274      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_8h</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x00407277      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>ecx, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_10h</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x0040727a      </span><span style=color:#fa5c4b>movsx   </span><span style=color:#fdf4c1>edx, </span><span style=color:#fabd2f>byte </span><span style=color:#fdf4c1>[eax + ecx]
</span><span style=color:#d3869b>0x0040727e      </span><span style=color:#fa5c4b>xor     </span><span style=color:#fdf4c1>edx, </span><span style=color:#d3869b>0x25</span><span style=color:#928374;font-style:italic>  ; 37
</span><span style=color:#d3869b>0x00407281      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>byte </span><span style=color:#fdf4c1>[eax + ecx], dl
</span><span style=color:#928374;font-style:italic>; ---
</span><span style=color:#d3869b>0x00407284      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_10h</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x00407287      </span><span style=color:#fa5c4b>add     </span><span style=color:#fdf4c1>eax, </span><span style=color:#d3869b>1
</span><span style=color:#d3869b>0x0040728a      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_10h</span><span style=color:#fdf4c1>], eax
</span><span style=color:#928374;font-style:italic>; ---
</span><span style=color:#d3869b>0x0040728d      </span><span style=color:#fa5c4b>jmp     </span><span style=color:#d3869b>0x40726a
</span></code></pre><p>前两条指令没什么可说的，<code>movsx</code>还是第一次见，学习下。<p><code>movsx</code> 从来源取数，不足的部分用来源的符号位填充，这里取的是<code>var_8h[var_10h]</code>，一字节，到 <code>edx</code> 寄存器。<code>movsx</code>的好处是可以保留符号位，加载不同大小的数据时（比如来源是 <code>word</code>，目标是 <code>dword</code>），如果来源是负数，则填充符号位可以正确表示补码形式表示的负数。<p>从<code>var_8h[var_10h]</code>取数移入<code>edx</code> 后，之后是一句简单的 <code>xor</code>，逻辑异或运算。之后将<code>xor</code>运算结果取低位1字节（<code>dl</code>寄存器）移回<code>var_8h[var_10h]</code>。<p>之后自增，跳转循环，和之前的循环一样。将分析过的部分用伪代码表示如下。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>int</span><span> var_4h, var_8h; </span><span style=color:#928374;font-style:italic>// ebp-4h, ebp-8h
</span><span>var_4h </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x8</span><span>;
</span><span>var_8h </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>unknown_func(</span><span style=color:#d3869b>0x8</span><span style=color:#fdf4c1>)</span><span>;
</span><span>
</span><span style=color:#fa5c4b>for </span><span>(</span><span style=color:#fa5c4b>int</span><span> var_ch</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span>; var_ch </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>8</span><span>; var_ch</span><span style=color:#fe8019>++</span><span>) { </span><span style=color:#928374;font-style:italic>// var_ch -> ebp-ch
</span><span>    var_8h[var_ch] </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x52 </span><span style=color:#fe8019>+</span><span> var_ch;
</span><span>}
</span><span>
</span><span style=color:#fdf4c1>unknown_func(var_8h, </span><span style=color:#d3869b>0x8</span><span style=color:#fdf4c1>, username, username_len)</span><span>; </span><span style=color:#928374;font-style:italic>// 猜测的函数签名 func(void*, int, void*, int)
</span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>int</span><span> var_10h</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span>; var_10h </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>8</span><span>; var_10h</span><span style=color:#fe8019>++</span><span>) { </span><span style=color:#928374;font-style:italic>// var_10h -> ebp-10h
</span><span>    var_8h[var_10h] </span><span style=color:#fe8019>^= </span><span style=color:#d3869b>0x25</span><span>;
</span><span>}
</span></code></pre><p>继续看循环结束后的动作。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#d3869b>0x00407292      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_14h</span><span style=color:#fdf4c1>], </span><span style=color:#d3869b>0x11</span><span style=color:#928374;font-style:italic> ; 17
</span><span style=color:#d3869b>0x00407299      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[esp], </span><span style=color:#d3869b>0x11</span><span style=color:#928374;font-style:italic> ; [0x11:4]=-1 ; 17
</span><span style=color:#d3869b>0x004072a0      </span><span style=color:#fa5c4b>call    </span><span style=color:#8ec07c>fcn.</span><span style=color:#d3869b>00401302
</span><span style=color:#d3869b>0x004072a5      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_18h</span><span style=color:#fdf4c1>], eax
</span><span style=color:#d3869b>0x004072a8      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_1ch</span><span style=color:#fdf4c1>], </span><span style=color:#d3869b>0
</span></code></pre><p>调用一个函数，返回值赋值给<code>var_18h</code>，同时初始化<code>var_1ch</code>为 0。伪代码表示如下。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>int</span><span> var_14h </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x11</span><span>;
</span><span>var_18h </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>unknown_func(</span><span style=color:#d3869b>0x11</span><span style=color:#fdf4c1>)</span><span>;
</span><span style=color:#fa5c4b>int</span><span> var_1ch </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x0</span><span>;
</span></code></pre><p>接下来又是一个循环。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#d3869b>0x004072af      </span><span style=color:#fa5c4b>cmp     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_1ch</span><span style=color:#fdf4c1>], </span><span style=color:#d3869b>8
</span><span style=color:#d3869b>0x004072b3      </span><span style=color:#fa5c4b>jae     </span><span style=color:#d3869b>0x4072f2
</span></code></pre><p>不重复分析，进入循环体。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#d3869b>0x004072b9      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_8h</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x004072bc      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>ecx, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_1ch</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x004072bf      </span><span style=color:#fa5c4b>movsx   </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>byte </span><span style=color:#fdf4c1>[eax + ecx]
</span><span style=color:#d3869b>0x004072c3      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>edx, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_18h</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x004072c6      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>ecx, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_1ch</span><span style=color:#fdf4c1>]
</span><span style=color:#928374;font-style:italic>; ---
</span><span style=color:#d3869b>0x004072c9      </span><span style=color:#fa5c4b>shl     </span><span style=color:#fdf4c1>ecx, </span><span style=color:#d3869b>1
</span><span style=color:#d3869b>0x004072cc      </span><span style=color:#fa5c4b>add     </span><span style=color:#fdf4c1>edx, ecx
</span><span style=color:#928374;font-style:italic>; ---
</span><span style=color:#d3869b>0x004072ce      </span><span style=color:#fa5c4b>lea     </span><span style=color:#fdf4c1>ecx, </span><span style=color:#fa5c4b>str</span><span style=color:#8ec07c>.02x</span><span style=color:#928374;font-style:italic> ; 0x45de50，内容是 %02x
</span><span style=color:#928374;font-style:italic>; ---
</span><span style=color:#d3869b>0x004072d4      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[esp], edx
</span><span style=color:#d3869b>0x004072d7      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_sp_4h</span><span style=color:#fdf4c1>], ecx
</span><span style=color:#d3869b>0x004072db      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_sp_8h</span><span style=color:#fdf4c1>], eax
</span><span style=color:#d3869b>0x004072df      </span><span style=color:#fa5c4b>call    </span><span style=color:#8ec07c>fcn.00403dcd
</span><span style=color:#928374;font-style:italic>; ---
</span><span style=color:#d3869b>0x004072e4      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_1ch</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x004072e7      </span><span style=color:#fa5c4b>add     </span><span style=color:#fdf4c1>eax, </span><span style=color:#d3869b>1
</span><span style=color:#d3869b>0x004072ea      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_1ch</span><span style=color:#fdf4c1>], eax
</span><span style=color:#d3869b>0x004072ed      </span><span style=color:#fa5c4b>jmp     </span><span style=color:#d3869b>0x4072af
</span></code></pre><p>依然是从 <code>var_8h[var_1ch]</code> 取数，之后把 <code>var_18h</code> 和 <code>var_1ch</code> 也取数，分别放到 <code>eax</code>、<code>edx</code>、<code>ecx</code>。<p>接着是一个没见过的命令，<code>shl</code>，学习下。<p><code>shl</code>是逻辑左移，和 c 中的 <code>&lt;&lt;</code> 运算符一样，两个操作数，命令格式<code>shl 寄存器,立即数</code>。<p>这里做的就是 <code>ecx</code>，也就是 <code>var_1ch</code> 的值左移1位，众所周知左移n位可以看作乘上2^n^ ，所以这句 <code>shl</code> 其实就是 <code>var_1ch*2</code>。左移后结果加到了<code>edx</code>，<code>edx</code>是<code>var_18h</code>。<p>之后是一个<code>lea</code>，加载地址，内容是常量字符串 <code>%02x</code>，看起来是一个 c 格式化字符串。<p>接着压栈传参，调用未知函数，结果忽略。伪代码表示如下。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fdf4c1>unknown_func(var_18h </span><span style=color:#fe8019>+</span><span style=color:#fdf4c1> var_1ch </span><span style=color:#fe8019>* </span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>, </span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>%02x</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>, var_8h[var_1ch])</span><span>;
</span></code></pre><p>随后是变量自增，跳转回循环开头。<p>我们把分析出来的伪代码再合并下。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>int</span><span> var_4h, var_8h; </span><span style=color:#928374;font-style:italic>// ebp-4h, ebp-8h
</span><span>var_4h </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x8</span><span>;
</span><span>var_8h </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>unknown_func(</span><span style=color:#d3869b>0x8</span><span style=color:#fdf4c1>)</span><span>;
</span><span>
</span><span style=color:#fa5c4b>for </span><span>(</span><span style=color:#fa5c4b>int</span><span> var_ch</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span>; var_ch </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>8</span><span>; var_ch</span><span style=color:#fe8019>++</span><span>) { </span><span style=color:#928374;font-style:italic>// var_ch -> ebp-ch
</span><span>    var_8h[var_ch] </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x52 </span><span style=color:#fe8019>+</span><span> var_ch;
</span><span>}
</span><span>
</span><span style=color:#fdf4c1>unknown_func(var_8h, </span><span style=color:#d3869b>0x8</span><span style=color:#fdf4c1>, username, username_len)</span><span>; </span><span style=color:#928374;font-style:italic>// 猜测的函数签名 func(void*, int, void*, int)
</span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>int</span><span> var_10h</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span>; var_10h </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>8</span><span>; var_10h</span><span style=color:#fe8019>++</span><span>) { </span><span style=color:#928374;font-style:italic>// var_10h -> ebp-10h
</span><span>    var_8h[var_10h] </span><span style=color:#fe8019>^= </span><span style=color:#d3869b>0x25</span><span>;
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>int</span><span> var_14h </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x11</span><span>;
</span><span>var_18h </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>unknown_func(</span><span style=color:#d3869b>0x11</span><span style=color:#fdf4c1>)</span><span>;
</span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>int</span><span> var_1ch </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x0</span><span>; var_1ch </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>8</span><span>; var_1ch</span><span style=color:#fe8019>++</span><span>) {
</span><span>    </span><span style=color:#fdf4c1>unknown_func(var_18h </span><span style=color:#fe8019>+</span><span style=color:#fdf4c1> var_1ch </span><span style=color:#fe8019>* </span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>, </span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>%02x</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>, var_8h[var_1ch])</span><span>;
</span><span>}
</span></code></pre><p>最后是循环结束后的代码。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#d3869b>0x004072f2      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_18h</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x004072f5      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>byte </span><span style=color:#fdf4c1>[eax + </span><span style=color:#d3869b>0x10</span><span style=color:#fdf4c1>], </span><span style=color:#d3869b>0
</span><span style=color:#928374;font-style:italic>; ---
</span><span style=color:#d3869b>0x004072f9      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_8h</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x004072fc      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[esp], eax
</span><span style=color:#d3869b>0x004072ff      </span><span style=color:#fa5c4b>call    </span><span style=color:#8ec07c>fcn.00402a36
</span><span style=color:#928374;font-style:italic>; ---
</span><span style=color:#d3869b>0x00407304      </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>var_18h</span><span style=color:#fdf4c1>]
</span><span style=color:#928374;font-style:italic>; ---
</span><span style=color:#d3869b>0x00407307      </span><span style=color:#fa5c4b>add     </span><span style=color:#fdf4c1>esp, </span><span style=color:#d3869b>0x2c
</span><span style=color:#d3869b>0x0040730a      </span><span style=color:#fa5c4b>pop     </span><span style=color:#fdf4c1>ebp
</span><span style=color:#d3869b>0x0040730b      </span><span style=color:#fa5c4b>ret
</span></code></pre><p>首先是把<code>var_18h[0x10]</code> 的值设为0。<p>接着<code>var_8h</code>做参数调未知函数。<p>把<code>var_18h</code>移到<code>eax</code>，也就是<code>cdecl</code>约定下的返回值位置。<p>最后平栈，恢复<code>ebp</code>，返回，函数结束。我们把所有内容的伪代码合并起来。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>int</span><span> var_4h </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x8</span><span>; </span><span style=color:#928374;font-style:italic>// ebp-4h
</span><span style=color:#fa5c4b>void</span><span style=color:#fe8019>*</span><span> var_8h </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>unknown_func(</span><span style=color:#d3869b>0x8</span><span style=color:#fdf4c1>)</span><span>; </span><span style=color:#928374;font-style:italic>// ebp-8h
</span><span>
</span><span style=color:#fa5c4b>for </span><span>(</span><span style=color:#fa5c4b>int</span><span> var_ch</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span>; var_ch </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>8</span><span>; var_ch</span><span style=color:#fe8019>++</span><span>) { </span><span style=color:#928374;font-style:italic>// var_ch -> ebp-ch
</span><span>    var_8h[var_ch] </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x52 </span><span style=color:#fe8019>+</span><span> var_ch;
</span><span>}
</span><span>
</span><span style=color:#fdf4c1>unknown_func(var_8h, </span><span style=color:#d3869b>0x8</span><span style=color:#fdf4c1>, username, username_len)</span><span>; </span><span style=color:#928374;font-style:italic>// 猜测的函数签名 func(void*, int, void*, int)
</span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>int</span><span> var_10h</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span>; var_10h </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>8</span><span>; var_10h</span><span style=color:#fe8019>++</span><span>) { </span><span style=color:#928374;font-style:italic>// var_10h -> ebp-10h
</span><span>    var_8h[var_10h] </span><span style=color:#fe8019>^= </span><span style=color:#d3869b>0x25</span><span>;
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>int</span><span> var_14h </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x11</span><span>;
</span><span>var_18h </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>unknown_func(</span><span style=color:#d3869b>0x11</span><span style=color:#fdf4c1>)</span><span>;
</span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>int</span><span> var_1ch </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x0</span><span>; var_1ch </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>8</span><span>; var_1ch</span><span style=color:#fe8019>++</span><span>) {
</span><span>    </span><span style=color:#fdf4c1>unknown_func(var_18h </span><span style=color:#fe8019>+</span><span style=color:#fdf4c1> var_1ch </span><span style=color:#fe8019>* </span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>, </span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>%02x</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>, var_8h[var_1ch])</span><span>;
</span><span>}
</span><span>var_18h[</span><span style=color:#d3869b>0x10</span><span>] </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>;
</span><span>
</span><span style=color:#fdf4c1>unknown_func(var_8h)</span><span>;
</span><span style=color:#fa5c4b>return</span><span> var_18h;
</span></code></pre><p>从这我们已经能看出具体算法了，未知函数可以猜测调试看看。<h2 id=0x04-diao-shi-qi-easy>0x04 调试器 - easy</h2><p>调试的目标是确认生成序列号的算法，把分析出的伪代码中还不清楚用途的未知函数，分析出作用。<h3 id=4-1-x32dbg>4.1 x32dbg</h3><p>打开调试器后，先找到关键跳，在工具栏点击字符串工具图标，在下方搜索栏输入<code>wrong pwd!</code><p><img alt=image-20210915140718400 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-15.webp><p>跳到引用位置。<p><img alt=image-20210915111455604 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-18.webp><p><img alt=image-20210915111621678 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-19.webp><p>之后可以按g，进入控制流视图，不过这个控制流视图有点不好看，我们也可以直接参考静态分析中的汇编，直接找到函数，并在入口下断点。<p><img alt=image-20210915112358449 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-20.webp><p>尝试随便输入一点内容，调试器命中。<p><img alt=image-20210915112552389 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-21.webp><p>接下来就可以用左上角的单步调试了。<p><img alt=image-20210915140939909 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-22.webp><p>不做更多介绍，汇编的分析已经进行过一次。这次我们找到对输入 "abc" 的正确序列号，完成一次解密。<p>只需要在断点处点击<img alt=image-20210915141120060 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-23.webp>按钮，然后观察<code>eax</code>寄存器。<p><img alt=image-20210915141405302 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-24.webp><p>抄出来（居然不能右键复制后面的字符串），内容是<code>4447467073727d7c</code>。<p>接着继续运行，再把抄出来的答案复制进去看看。<p><img alt=image-20210915141838395 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-25.webp><p>到这里，我们拿到了一个可以用的序列号。<h2 id=0x05-zhu-ce-ji>0x05 注册机</h2><h3 id=5-1-python-jiao-ben-zhu-ce-ji>5.1 Python 脚本注册机</h3><p>先把前面的伪代码贴一下。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>int</span><span> var_4h </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x8</span><span>; </span><span style=color:#928374;font-style:italic>// ebp-4h
</span><span style=color:#fa5c4b>void</span><span style=color:#fe8019>*</span><span> var_8h </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>unknown_func(</span><span style=color:#d3869b>0x8</span><span style=color:#fdf4c1>)</span><span>; </span><span style=color:#928374;font-style:italic>// ebp-8h
</span><span>
</span><span style=color:#fa5c4b>for </span><span>(</span><span style=color:#fa5c4b>int</span><span> var_ch</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span>; var_ch </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>8</span><span>; var_ch</span><span style=color:#fe8019>++</span><span>) { </span><span style=color:#928374;font-style:italic>// var_ch -> ebp-ch
</span><span>    var_8h[var_ch] </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x52 </span><span style=color:#fe8019>+</span><span> var_ch;
</span><span>}
</span><span>
</span><span style=color:#fdf4c1>unknown_func(var_8h, </span><span style=color:#d3869b>0x8</span><span style=color:#fdf4c1>, username, username_len)</span><span>; </span><span style=color:#928374;font-style:italic>// 猜测的函数签名 func(void*, int, void*, int)
</span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>int</span><span> var_10h</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span>; var_10h </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>8</span><span>; var_10h</span><span style=color:#fe8019>++</span><span>) { </span><span style=color:#928374;font-style:italic>// var_10h -> ebp-10h
</span><span>    var_8h[var_10h] </span><span style=color:#fe8019>^= </span><span style=color:#d3869b>0x25</span><span>;
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>int</span><span> var_14h </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x11</span><span>;
</span><span>var_18h </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>unknown_func(</span><span style=color:#d3869b>0x11</span><span style=color:#fdf4c1>)</span><span>;
</span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>int</span><span> var_1ch </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x0</span><span>; var_1ch </span><span style=color:#fe8019>&lt; </span><span style=color:#d3869b>8</span><span>; var_1ch</span><span style=color:#fe8019>++</span><span>) {
</span><span>    </span><span style=color:#fdf4c1>unknown_func(var_18h </span><span style=color:#fe8019>+</span><span style=color:#fdf4c1> var_1ch </span><span style=color:#fe8019>* </span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>, </span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>%02x</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>, var_8h[var_1ch])</span><span>;
</span><span>}
</span><span>var_18h[</span><span style=color:#d3869b>0x10</span><span>] </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>;
</span><span>
</span><span style=color:#fdf4c1>unknown_func(var_8h)</span><span>;
</span><span style=color:#fa5c4b>return</span><span> var_18h;
</span></code></pre><p>里面的未知函数（失策，clang默认静态链接了libcmt，很多库函数在x32dbg里认不出来）猜一猜吧。<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>username </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>input</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>'username:'</span><span style=color:#fdf4c1>).encode()
</span><span>username_len </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>len</span><span style=color:#fdf4c1>(username)
</span><span>
</span><span>var_4h </span><span style=color:#fe8019>= </span><span style=color:#d3869b>8
</span><span>var_8h </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>bytearray</span><span style=color:#fdf4c1>(</span><span style=color:#d3869b>8</span><span style=color:#fdf4c1>)
</span><span>
</span><span style=color:#fa5c4b>for </span><span>i </span><span style=color:#fa5c4b>in </span><span style=color:#fabd2f>range</span><span style=color:#fdf4c1>(</span><span style=color:#d3869b>8</span><span style=color:#fdf4c1>)</span><span>:
</span><span>    var_8h[i] </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0x52 </span><span style=color:#fe8019>+ </span><span>i
</span><span>
</span><span style=color:#928374;font-style:italic># 这里的未知函数通过调试器可以看出，把入参复制到了 var_8h 里
</span><span>var_8h[:username_len] </span><span style=color:#fe8019>= </span><span>username
</span><span>
</span><span style=color:#fa5c4b>for </span><span>i </span><span style=color:#fa5c4b>in </span><span style=color:#fabd2f>range</span><span style=color:#fdf4c1>(</span><span style=color:#d3869b>8</span><span style=color:#fdf4c1>)</span><span>:
</span><span>    var_8h[i] </span><span style=color:#fe8019>^= </span><span style=color:#d3869b>0x25
</span><span>
</span><span style=color:#928374;font-style:italic># for(int var_1ch = 0x0; var_1ch &lt; 8; var_1ch++) {
</span><span style=color:#928374;font-style:italic>#     unknown_func(var_18h + var_1ch * 2, "%02x", var_8h[var_1ch]);
</span><span style=color:#928374;font-style:italic># }
</span><span style=color:#928374;font-style:italic>#
</span><span style=color:#928374;font-style:italic># 最后的那个循环中，函数判断为 sprintf 或其他啥，格式化明确是2位小写16进制数
</span><span style=color:#928374;font-style:italic># 前面的计算看作是算偏移，一个 var_8h 的字节对应 2 字节16进制表示，所以 var_18h 加上 NUL 一共是 0x11 也就是 17 个字节
</span><span style=color:#928374;font-style:italic># 循环的作用是把 var_8h 这个字节数组转换成16进制表示的字符串。
</span><span style=color:#928374;font-style:italic>#
</span><span style=color:#928374;font-style:italic># 在 python 里用 hex() 就行了。
</span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(var_8h.hex())
</span></code></pre><p>运行脚本，输入<code>abc</code>，输出<code>4447467073727d7c</code>，确认注册机可以生成序列号。<h2 id=0x06-xiu-gai-exe>0x06 修改 exe</h2><h3 id=6-1-x32dbg-xiu-gai-guan-jian-tiao>6.1 x32dbg 修改关键跳</h3><p>用调试器打开后找到决定serial是否正确的关键跳转，右键二进制选择用NOP填充，确认即可。<p><img alt=image-20210915150907420 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-26.webp><p>修改后效果如图。<p><img alt=image-20210915150953046 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-27.webp><p>接着把修改后的exe保存下来，在文件菜单里选择补丁。<p><img alt=image-20210915151220354 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-28.webp><p>全选，点修补文件，选择路径保存。<p><img alt=image-20210915151322628 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-29.webp><p>我保存在<code>cm02-easy-patched.exe</code>，接着我们试试运行。<p><img alt=image-20210915151903611 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-30.webp><p>遗憾的是被x32dbg补丁功能导出的文件需要管理员权限运行，为了能截到图，图中用了名为<code>sudo</code>的工具命令，可以用<code>scoop install sudo</code>来安装<code>sudo</code>，点击去<a href=https://scoop.sh>scoop首页</a>。<h3 id=6-2-fan-bian-yi-qi-xiu-gai-guan-jian-tiao>6.2 反编译器修改关键跳</h3><p>以Cutter为例，找到<code>jne</code>指令后，右键修改为<code>nop</code>即可。记得先备份。<p><img alt=image-20210915152428449 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-31.webp><p><img alt=image-20210915152609774 src=https://nnnewb.github.io/posts/2021/crackme-02/image/crackme-02/cm02-easy-32.webp><p>修改后也能实现和x32导出一样的效果，而且不用管理员权限。<h2 id=jie-lun>结论</h2><p>总得有个结论。<p>这次逆向应该能帮助学到下面的东西：<ul><li>栈帧结构和函数调用<li><code>cmp</code>指令<li><code>jne</code>、<code>jbe</code>、<code>jnz</code>、<code>jae</code>指令<li><code>movsx</code>指令<li><code>shl</code>指令</ul><p>库函数因为静态链接的缘故已经变成了文中的未知函数，造成了分析上的障碍。老实说如果不是自己写的源码，能不能这么顺利逆向出注册机还真不好说。<p>开启优化的 <em>normal</em> 和 <em>hard</em> 难度就不进一步分析了，有兴趣可以看看。</article><p class=tags-data><a href=/tags/hui-bian>/汇编/</a> <a href=/tags/ni-xiang>/逆向/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>