<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>基于栈的虚拟机</title><meta content=基于栈的虚拟机 name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2021/stack-based-virtual-machine-for-minilang/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content=基于栈的虚拟机 property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2021/stack-based-virtual-machine-for-minilang/ property=twitter:url><meta content=基于栈的虚拟机 property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2021/stack-based-virtual-machine-for-minilang/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>基于栈的虚拟机</h1><p class=author-line>作于：2021-12-13 16:20 ，预计阅读时间 10 分钟<article><h2 id=qian-yan>前言</h2><p>之前写了个s表达式求值器，很简陋，直接在抽象语法树上执行。只是这样的话其实还没啥意思，所以再试试改进成在基于栈的虚拟机上执行。<h2 id=0x01-xu-ni-ji-mo-xing>0x01 虚拟机模型</h2><p>首先得承认对这些语言层级的虚拟机不熟，基本是随便设计的。<h3 id=dui-xiang-mo-xing>对象模型</h3><p>虚拟机指令操作的目标是 <strong>对象</strong> ，包括内建的对象和用户定义的对象，虚拟机指令操作的基本单位也是对象。<p>目前关注的是内建的对象，简单抽象出了几个基本类型。<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>Object </span><span style=color:#fa5c4b>interface </span><span>{
</span><span>	</span><span style=color:#8ec07c>TypeName</span><span>() </span><span style=color:#fabd2f>string
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>UInt </span><span style=color:#fabd2f>uint64
</span><span>
</span><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>u </span><span style=color:#fa5c4b>UInt</span><span>) </span><span style=color:#8ec07c>TypeName</span><span>() </span><span style=color:#fabd2f>string </span><span>{
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#b8bb26>"UInt"
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>Float </span><span style=color:#fabd2f>float64
</span><span>
</span><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>f </span><span style=color:#fa5c4b>Float</span><span>) </span><span style=color:#8ec07c>TypeName</span><span>() </span><span style=color:#fabd2f>string </span><span>{
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#b8bb26>"Float"
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>Boolean </span><span style=color:#fabd2f>bool
</span><span>
</span><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>b </span><span style=color:#fa5c4b>Boolean</span><span>) </span><span style=color:#8ec07c>TypeName</span><span>() </span><span style=color:#fabd2f>string </span><span>{
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#b8bb26>"boolean"
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>String </span><span style=color:#fabd2f>string
</span><span>
</span><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>s </span><span style=color:#fa5c4b>String</span><span>) </span><span style=color:#8ec07c>TypeName</span><span>() </span><span style=color:#fabd2f>string </span><span>{
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#b8bb26>"string"
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>Symbol </span><span style=color:#fabd2f>string
</span><span>
</span><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>s </span><span style=color:#fa5c4b>Symbol</span><span>) </span><span style=color:#8ec07c>TypeName</span><span>() </span><span style=color:#fabd2f>string </span><span>{
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#b8bb26>"symbol"
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>Nil </span><span style=color:#fa5c4b>struct</span><span>{}
</span><span>
</span><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>n </span><span style=color:#fa5c4b>Nil</span><span>) </span><span style=color:#8ec07c>TypeName</span><span>() </span><span style=color:#fabd2f>string </span><span>{
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#b8bb26>"nil"
</span><span>}
</span></code></pre><p>省略了一部分，领会精神即可。上面定义的 <code>Symbol</code> 类型其实就是 <code>#ident</code> 这种语法元素，目的是保持语义上的简洁。<p>比如说 <code>(let a b)</code>，在 minilang 里解释成以<code>a</code>和<code>b</code>作为参数，调用<code>let</code>函数，<code>a</code>和<code>b</code>都会被求值。<code>let</code>是一个内置函数，在当前环境里定义一个新的变量并设初值。<p>可实际写代码的人想要的可能是 <em>定义a，初始化为b</em>。这种情况下我们不希望<code>a</code>被求值，而是字面意思：标识符<code>a</code>，传给<code>let</code>函数。这种情况下就可以用 <code>(let #a b)</code> ，<code>#a</code> 表示一个 <code>Symbol</code> 类型的字面量。<p>或许有人会注意到本质上来说<code>#a</code>是个语法糖，也可以被写成 <code>(quote "a")</code> 这样的形式。<code>quota</code> 定义为将字符串构造成 <code>Symbol</code> 对象的函数。<h3 id=zhi-ling-ji>指令集</h3><p>有了基本的对象模型，再定义最基本的指令。因为考虑将代码也视作数据，所以目前的想法还是把控制结构也做成内置函数，因此指令集里不需要太多转移指令。<p>暂定的指令集如下。<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>OpCode </span><span style=color:#fabd2f>int32
</span><span>
</span><span style=color:#fa5c4b>const </span><span>(
</span><span>	</span><span style=color:#fdf4c1>RESERVED </span><span style=color:#fe8019>= </span><span style=color:#d3869b>iota
</span><span>	</span><span style=color:#928374;font-style:italic>// CALL &lt;STR>
</span><span>	</span><span style=color:#928374;font-style:italic>// 压栈下一条指令的地址，跳转到指定位置
</span><span>	</span><span style=color:#fdf4c1>CALL
</span><span>	</span><span style=color:#928374;font-style:italic>// RET &lt;OBJ>
</span><span>	</span><span style=color:#928374;font-style:italic>// 取栈顶的对象作为跳转地址，压栈返回值
</span><span>	</span><span style=color:#fdf4c1>RET
</span><span>	</span><span style=color:#928374;font-style:italic>// LOAD &lt;STR>
</span><span>	</span><span style=color:#928374;font-style:italic>// 读取局部环境里的变量压栈
</span><span>	</span><span style=color:#fdf4c1>LOAD
</span><span>	</span><span style=color:#928374;font-style:italic>// PUSH &lt;NUM>
</span><span>	</span><span style=color:#928374;font-style:italic>// 压栈对象
</span><span>	</span><span style=color:#fdf4c1>PUSH
</span><span>	</span><span style=color:#928374;font-style:italic>// POP &lt;NUM>
</span><span>	</span><span style=color:#928374;font-style:italic>// 出栈一定数量的对象，出栈的对象直接丢弃
</span><span>	</span><span style=color:#fdf4c1>POP
</span><span>)
</span><span>
</span><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>o </span><span style=color:#fa5c4b>OpCode</span><span>) </span><span style=color:#8ec07c>String</span><span>() </span><span style=color:#fabd2f>string </span><span>{
</span><span>	</span><span style=color:#fa5c4b>return </span><span>[]</span><span style=color:#fabd2f>string</span><span>{
</span><span>		</span><span style=color:#b8bb26>"RESERVED"</span><span>,
</span><span>		</span><span style=color:#b8bb26>"CALL"</span><span>,
</span><span>		</span><span style=color:#b8bb26>"RET"</span><span>,
</span><span>		</span><span style=color:#b8bb26>"LOAD"</span><span>,
</span><span>		</span><span style=color:#b8bb26>"PUSH"</span><span>,
</span><span>		</span><span style=color:#b8bb26>"POP"</span><span>,
</span><span>	}[</span><span style=color:#fdf4c1>o</span><span>]
</span><span>}
</span></code></pre><p>除了最初的 <code>RESERVED</code> 是故意占用了零值，剩下的就是有效的指令了。<p>写过 x86 汇编的话会看的很不习惯，因为完全没考虑寻址。<ul><li><code>CALL</code> 指令的操作数对象是字符串的时候，在本地环境寻找对应名称的内建函数； <ul><li>或者，操作数是 UINT 的话，压栈下一条指令地址后跳转到指定位置，和 x86 汇编类似；</ul><li><code>RET</code> 把当前栈顶的变量(UINT)当成下一个指令的地址<li><code>LOAD</code> 在本地环境寻找对应名称的变量压栈</ul><p>剩余略。其实可以看出直接对机器编程中的寻址被替换成了根据变量名（字符串）查找本地环境，很多高层级的概念（对象、字符串）被糅杂在里面。<h2 id=0x02-bian-yi>0x02 编译</h2><p>接下来是把抽象语法树翻译成指令序列。<h3 id=zi-mian-liang-fan-yi>字面量翻译</h3><p>因为 minilang 的指令直接操作对象，所以能很省事地把字面量都构造成相应地对象。对于更复杂的对象，也可以编译成构造指令，当然目前不涉及。<p>举个例子，列表字面量 <code>#(display hello)</code>。可以在编译过程里直接构造出 <code>List</code> 对象，然后生成一个 <code>PUSH List{}</code> 指令，这样做的好处是更简单，效率会更好一点，毕竟少几个解释执行的指令。相应的限制是不能引用环境里的变量，因为在构造字面量对象的过程里还没有进入运行时环境。<p>比如说 <code>#(display name)</code>，如果编译成 <code>PUSH List{display, name}</code>，那么<code>name</code>在此刻就不能被求值，必须延迟到执行的时候才能求值<code>name</code>。这里又涉及编译期的计算，比如我可以定义一个编译阶段执行的指令格式 <code>[elem...]</code>，编译的时候对 <code>[elem...]</code>求值，求值结果写进编译出的指令里。也是后话。<p>编译成指令的好处是之后要做 JIT 或者全量编译成本地代码的话，不需要重新处理这个字面量，写一堆 case 把字面量编译成几个函数调用。<p>扯远了，先前我们拿 <code>gocc</code> 生成好了语法树，接下来就是简单地做一下翻译。<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>case </span><span style=color:#fdf4c1>ast</span><span>.</span><span style=color:#fdf4c1>Boolean</span><span>, </span><span style=color:#fdf4c1>ast</span><span>.</span><span style=color:#fdf4c1>UInt</span><span>, </span><span style=color:#fdf4c1>ast</span><span>.</span><span style=color:#fdf4c1>Float</span><span>, </span><span style=color:#fdf4c1>ast</span><span>.</span><span style=color:#fdf4c1>Symbol</span><span>, </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>ast</span><span>.</span><span style=color:#fdf4c1>Quoted</span><span>, </span><span style=color:#fdf4c1>ast</span><span>.</span><span style=color:#fdf4c1>String</span><span>:
</span><span>	</span><span style=color:#fdf4c1>instructions </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>append</span><span>(</span><span style=color:#fdf4c1>instructions</span><span>, </span><span style=color:#fdf4c1>push</span><span>(</span><span style=color:#fdf4c1>vm</span><span>.</span><span style=color:#fdf4c1>ObjectFromLiteral</span><span>(</span><span style=color:#fdf4c1>node</span><span>)))
</span></code></pre><p>其中 <code>vm.ObjectFromLiteral(node)</code> 就是负责把从抽象语法树节点构造出对象实例的函数。<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>ObjectFromLiteral</span><span>(</span><span style=color:#fdf4c1>node ast</span><span>.</span><span style=color:#fa5c4b>Node</span><span>) </span><span style=color:#fa5c4b>Object </span><span>{
</span><span>	</span><span style=color:#fa5c4b>switch </span><span style=color:#fdf4c1>node </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>node</span><span>.(</span><span style=color:#fa5c4b>type</span><span>) {
</span><span>	</span><span style=color:#fa5c4b>case </span><span style=color:#fdf4c1>ast</span><span>.</span><span style=color:#fdf4c1>Float</span><span>:
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>Float</span><span>(</span><span style=color:#fdf4c1>node</span><span>)
</span><span>	</span><span style=color:#fa5c4b>case </span><span style=color:#fdf4c1>ast</span><span>.</span><span style=color:#fdf4c1>UInt</span><span>:
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>UInt</span><span>(</span><span style=color:#fdf4c1>node</span><span>)
</span><span>	</span><span style=color:#fa5c4b>case </span><span style=color:#fdf4c1>ast</span><span>.</span><span style=color:#fdf4c1>String</span><span>:
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>String</span><span>(</span><span style=color:#fdf4c1>node</span><span>)
</span><span>	</span><span style=color:#fa5c4b>case </span><span style=color:#fdf4c1>ast</span><span>.</span><span style=color:#fdf4c1>Boolean</span><span>:
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>Boolean</span><span>(</span><span style=color:#fdf4c1>node</span><span>)
</span><span>	</span><span style=color:#fa5c4b>case </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>ast</span><span>.</span><span style=color:#fdf4c1>Quoted</span><span>:
</span><span>		</span><span style=color:#fdf4c1>lst </span><span style=color:#fe8019>:= &</span><span style=color:#fdf4c1>List</span><span>{}
</span><span>		</span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>_</span><span>, </span><span style=color:#fdf4c1>n </span><span style=color:#fe8019>:= </span><span style=color:#fa5c4b>range </span><span style=color:#fdf4c1>node</span><span>.</span><span style=color:#fdf4c1>GetValue</span><span>().([]</span><span style=color:#fdf4c1>ast</span><span>.</span><span style=color:#fa5c4b>Node</span><span>) {
</span><span>			</span><span style=color:#fdf4c1>lst</span><span>.</span><span style=color:#fdf4c1>underlying </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>append</span><span>(</span><span style=color:#fdf4c1>lst</span><span>.</span><span style=color:#fdf4c1>underlying</span><span>, </span><span style=color:#fdf4c1>ObjectFromLiteral</span><span>(</span><span style=color:#fdf4c1>n</span><span>))
</span><span>		}
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>lst
</span><span>	</span><span style=color:#fa5c4b>case </span><span style=color:#fdf4c1>ast</span><span>.</span><span style=color:#fdf4c1>Symbol</span><span>:
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>Symbol</span><span>(</span><span style=color:#fdf4c1>node</span><span>)
</span><span>	</span><span style=color:#fa5c4b>default</span><span>:
</span><span>		</span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>Fatalf</span><span>(</span><span style=color:#b8bb26>"unexpected ast node in ToValue </span><span style=color:#fdf4c1>%v</span><span style=color:#b8bb26>(</span><span style=color:#fdf4c1>%T</span><span style=color:#b8bb26>)"</span><span>, </span><span style=color:#fdf4c1>node</span><span>, </span><span style=color:#fdf4c1>node</span><span>)
</span><span>	}
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>nil
</span><span>}
</span></code></pre><p><code>Quoted</code> 表示列表字面量。这个函数本身很简单很直白，限制是对于非字面量的节点不能求值（比如 Identifier、函数调用都只能在运行时求值）。<h3 id=han-shu-diao-yong-fan-yi>函数调用翻译</h3><p>接着就是重头戏，函数调用的翻译。<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>case </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>ast</span><span>.</span><span style=color:#fdf4c1>List</span><span>:
</span><span>    </span><span style=color:#fdf4c1>elements </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>node</span><span>.</span><span style=color:#fdf4c1>GetValue</span><span>().([]</span><span style=color:#fdf4c1>ast</span><span>.</span><span style=color:#fa5c4b>Node</span><span>)
</span><span>    </span><span style=color:#fa5c4b>if </span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>elements</span><span>) </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0 </span><span>{
</span><span>        </span><span style=color:#fa5c4b>return </span><span style=color:#fabd2f>make</span><span>([]</span><span style=color:#fdf4c1>vm</span><span>.</span><span style=color:#fa5c4b>Instruction</span><span>, </span><span style=color:#d3869b>0</span><span>), </span><span style=color:#d3869b>nil
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#928374;font-style:italic>// 参数从右到左压栈
</span><span>    </span><span style=color:#fa5c4b>for </span><span style=color:#fdf4c1>i </span><span style=color:#fe8019>:= </span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>elements</span><span>) </span><span style=color:#fe8019>- </span><span style=color:#d3869b>1</span><span>; </span><span style=color:#fdf4c1>i </span><span style=color:#fe8019>> </span><span style=color:#d3869b>0</span><span>; </span><span style=color:#fdf4c1>i</span><span style=color:#fe8019>-- </span><span>{
</span><span>        </span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>inst</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>c</span><span>.</span><span style=color:#fdf4c1>Compile</span><span>(</span><span style=color:#fdf4c1>elements</span><span>[</span><span style=color:#fdf4c1>i</span><span>]); </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>            </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>nil</span><span>, </span><span style=color:#fdf4c1>err
</span><span>        } </span><span style=color:#fa5c4b>else </span><span>{
</span><span>            </span><span style=color:#fdf4c1>instructions </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>append</span><span>(</span><span style=color:#fdf4c1>instructions</span><span>, </span><span style=color:#fdf4c1>inst</span><span style=color:#fe8019>...</span><span>)
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#928374;font-style:italic>// 压入参数数量
</span><span>    </span><span style=color:#fdf4c1>instructions </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>append</span><span>(</span><span style=color:#fdf4c1>instructions</span><span>, </span><span style=color:#fdf4c1>push</span><span>(</span><span style=color:#fdf4c1>vm</span><span>.</span><span style=color:#fdf4c1>UInt</span><span>(</span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>elements</span><span>)</span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>)))
</span><span>
</span><span>    </span><span style=color:#928374;font-style:italic>// 插入调用语句
</span><span>    </span><span style=color:#fdf4c1>callee </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>elements</span><span>[</span><span style=color:#d3869b>0</span><span>]
</span><span>    </span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>ident</span><span>, </span><span style=color:#fdf4c1>ok </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>callee</span><span>.(</span><span style=color:#fdf4c1>ast</span><span>.</span><span style=color:#fa5c4b>Identifier</span><span>); </span><span style=color:#fdf4c1>ok </span><span>{
</span><span>        </span><span style=color:#fdf4c1>instructions </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>append</span><span>(</span><span style=color:#fdf4c1>instructions</span><span>, </span><span style=color:#fdf4c1>vm</span><span>.</span><span style=color:#fdf4c1>Instruction</span><span>{
</span><span>            </span><span style=color:#fdf4c1>OpCode</span><span>:  </span><span style=color:#fdf4c1>vm</span><span>.</span><span style=color:#fdf4c1>CALL</span><span>,
</span><span>            </span><span style=color:#fdf4c1>Operand</span><span>: []</span><span style=color:#fdf4c1>vm</span><span>.</span><span style=color:#fdf4c1>Object</span><span>{</span><span style=color:#fdf4c1>vm</span><span>.</span><span style=color:#fdf4c1>Symbol</span><span>(</span><span style=color:#fdf4c1>ident</span><span>)},
</span><span>        })
</span><span>    }
</span></code></pre><p>谈函数调用的编译前必须先确定好调用约定。这里采用了和 cdecl 类似的调用约定，参数从右往左压栈，同时在最左添加一个参数数量的参数，就像是 <code>object f(object argc, object ...argv)</code> 一样，领会精神。<p>函数的返回值一律包装成 object 返回，不允许多返回值（但可以考虑加个解构语法之类的糖），返回值也通过栈传递。<p>整个函数调用的过程可以描述为：<ol><li>调用方参数压栈<li>调用方参数数量压栈<li>调用方返回地址压栈<li>调用方跳转到函数入口（或者进入内置函数）<li>被调方弹出返回地址<li>被调方弹出所有参数<li>被调方压栈返回值<li>被调方跳转至返回地址</ol><p>一句话概括就是被调方清栈，返回值放在栈顶。对于内置函数，步骤5-8都要在内置函数里完成。之后做用户定义 <code>procedure</code> 的话就要在 <code>procedure</code> 编译结果里加上平栈的代码了。现在还在纠结 <code>POP</code> 指令直接把弹出的对象给丢弃了，该怎么暂存返回地址。实在不行就改成调用方清栈得了。<h2 id=0x03-xu-ni-ji-chou-xiang>0x03 虚拟机抽象</h2><p>虚拟机理解为一个状态容器，包括指令空间（指令集合和指令指针）、数据空间（栈、本地变量），给一个简单的构造器。<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>type </span><span style=color:#8ec07c>MiniVM </span><span style=color:#fa5c4b>struct </span><span>{
</span><span>	</span><span style=color:#fdf4c1>Stack        </span><span>[]</span><span style=color:#fa5c4b>Object          </span><span style=color:#928374;font-style:italic>// 栈空间，包括传参和本地变量都存放在这里
</span><span>	</span><span style=color:#fdf4c1>Top          </span><span style=color:#fabd2f>int               </span><span style=color:#928374;font-style:italic>// 栈顶地址
</span><span>	</span><span style=color:#fdf4c1>Locals       </span><span style=color:#fa5c4b>map</span><span>[</span><span style=color:#fabd2f>string</span><span>]</span><span style=color:#fa5c4b>Object </span><span style=color:#928374;font-style:italic>// 本地变量，从这里查找变量和可调用的对象
</span><span>	</span><span style=color:#fdf4c1>IP           </span><span style=color:#fa5c4b>UInt              </span><span style=color:#928374;font-style:italic>// Instruction Pointer 指令指针
</span><span>	</span><span style=color:#fdf4c1>Instructions </span><span>[]</span><span style=color:#fa5c4b>Instruction     </span><span style=color:#928374;font-style:italic>// 程序指令集合
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>func </span><span style=color:#8ec07c>NewMiniVM</span><span>(</span><span style=color:#fdf4c1>instructions </span><span>[]</span><span style=color:#fa5c4b>Instruction</span><span>) </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>MiniVM </span><span>{
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>MiniVM</span><span>{
</span><span>		</span><span style=color:#fdf4c1>Stack</span><span>:        </span><span style=color:#fabd2f>make</span><span>([]</span><span style=color:#fa5c4b>Object</span><span>, </span><span style=color:#d3869b>0</span><span>),
</span><span>		</span><span style=color:#fdf4c1>Top</span><span>:          </span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>,
</span><span>		</span><span style=color:#fdf4c1>IP</span><span>:           </span><span style=color:#d3869b>0</span><span>,
</span><span>		</span><span style=color:#fdf4c1>Instructions</span><span>: </span><span style=color:#fdf4c1>instructions</span><span>,
</span><span>		</span><span style=color:#fdf4c1>Locals</span><span>:       </span><span style=color:#fabd2f>make</span><span>(</span><span style=color:#fa5c4b>map</span><span>[</span><span style=color:#fabd2f>string</span><span>]</span><span style=color:#fa5c4b>Object</span><span>),
</span><span>	}
</span><span>}
</span></code></pre><p>然后定义每个指令的执行逻辑。这里其实有点像是设计模式里的命令模式（Commnad Pattern）。<pre class=language-go data-lang=go style=color:#fdf4c1aa;background-color:#282828><code class=language-go data-lang=go><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>m </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>MiniVM</span><span>) </span><span style=color:#8ec07c>instCall</span><span>(</span><span style=color:#fdf4c1>inst </span><span style=color:#fa5c4b>Instruction</span><span>) </span><span style=color:#fabd2f>error </span><span>{
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>Operand</span><span>) </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0 </span><span>{
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Errorf</span><span>(</span><span style=color:#b8bb26>"invalid CALL instruction: </span><span style=color:#fdf4c1>%s</span><span style=color:#b8bb26>"</span><span>, </span><span style=color:#fdf4c1>inst</span><span>)
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>sym</span><span>, </span><span style=color:#fdf4c1>ok </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>Operand</span><span>[</span><span style=color:#d3869b>0</span><span>].(</span><span style=color:#fa5c4b>Symbol</span><span>); </span><span style=color:#fdf4c1>ok </span><span>{
</span><span>		</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>proc</span><span>, </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>LookupProc</span><span>(</span><span style=color:#fabd2f>string</span><span>(</span><span style=color:#fdf4c1>sym</span><span>)); </span><span style=color:#fdf4c1>err </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>nil </span><span>{
</span><span>			</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>err
</span><span>		} </span><span style=color:#fa5c4b>else </span><span>{
</span><span>			</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>proc</span><span>.</span><span style=color:#fdf4c1>isBuiltin </span><span>{
</span><span>				</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>Push</span><span>(</span><span style=color:#fdf4c1>UInt</span><span>(</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>IP </span><span style=color:#fe8019>+ </span><span style=color:#d3869b>1</span><span>))
</span><span>				</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>proc</span><span>.</span><span style=color:#fdf4c1>Builtin</span><span>(</span><span style=color:#fdf4c1>m</span><span>)
</span><span>			} </span><span style=color:#fa5c4b>else if </span><span style=color:#fdf4c1>proc</span><span>.</span><span style=color:#fdf4c1>Location </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>0 </span><span>{
</span><span>				</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>Push</span><span>(</span><span style=color:#fdf4c1>UInt</span><span>(</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>IP </span><span style=color:#fe8019>+ </span><span style=color:#d3869b>1</span><span>))
</span><span>				</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>IP </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>UInt</span><span>(</span><span style=color:#fdf4c1>proc</span><span>.</span><span style=color:#fdf4c1>Location</span><span>)
</span><span>			} </span><span style=color:#fa5c4b>else </span><span>{
</span><span>				</span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>Fatalf</span><span>(</span><span style=color:#b8bb26>"invalid Procedure object"</span><span>)
</span><span>				</span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>nil
</span><span>			}
</span><span>		}
</span><span>
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>nil
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#fdf4c1>log</span><span>.</span><span style=color:#fdf4c1>Fatalf</span><span>(</span><span style=color:#b8bb26>"invalid CALL instruction operand </span><span style=color:#fdf4c1>%v</span><span style=color:#b8bb26>"</span><span>, </span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>Operand</span><span>)
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>nil
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>m </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>MiniVM</span><span>) </span><span style=color:#8ec07c>instRet</span><span>(</span><span style=color:#fdf4c1>inst </span><span style=color:#fa5c4b>Instruction</span><span>) </span><span style=color:#fabd2f>error </span><span>{
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>Operand</span><span>) </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0 </span><span>{
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Errorf</span><span>(</span><span style=color:#b8bb26>"invalid RET instruction: </span><span style=color:#fdf4c1>%s</span><span style=color:#b8bb26>"</span><span>, </span><span style=color:#fdf4c1>inst</span><span>)
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#fdf4c1>returnAddress </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>Pop</span><span>().(</span><span style=color:#fa5c4b>UInt</span><span>)
</span><span>	</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>IP </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>returnAddress
</span><span>	</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>Push</span><span>(</span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>Operand</span><span>[</span><span style=color:#d3869b>0</span><span>])
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>nil
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>m </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>MiniVM</span><span>) </span><span style=color:#8ec07c>instPush</span><span>(</span><span style=color:#fdf4c1>inst </span><span style=color:#fa5c4b>Instruction</span><span>) </span><span style=color:#fabd2f>error </span><span>{
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>Operand</span><span>) </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0 </span><span style=color:#fe8019>|| </span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>Operand</span><span>) </span><span style=color:#fe8019>> </span><span style=color:#d3869b>1 </span><span>{
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Errorf</span><span>(</span><span style=color:#b8bb26>"invalid PUSH instruction: </span><span style=color:#fdf4c1>%s</span><span style=color:#b8bb26>"</span><span>, </span><span style=color:#fdf4c1>inst</span><span>)
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>Push</span><span>(</span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>Operand</span><span>[</span><span style=color:#d3869b>0</span><span>])
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>nil
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>m </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>MiniVM</span><span>) </span><span style=color:#8ec07c>instPop</span><span>(</span><span style=color:#fdf4c1>inst </span><span style=color:#fa5c4b>Instruction</span><span>) </span><span style=color:#fabd2f>error </span><span>{
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>Operand</span><span>) </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0 </span><span style=color:#fe8019>|| </span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>Operand</span><span>) </span><span style=color:#fe8019>> </span><span style=color:#d3869b>1 </span><span>{
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Errorf</span><span>(</span><span style=color:#b8bb26>"invalid POP instruction: </span><span style=color:#fdf4c1>%s</span><span style=color:#b8bb26>"</span><span>, </span><span style=color:#fdf4c1>inst</span><span>)
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>Pop</span><span>()
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>nil
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>m </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>MiniVM</span><span>) </span><span style=color:#8ec07c>instLoad</span><span>(</span><span style=color:#fdf4c1>inst </span><span style=color:#fa5c4b>Instruction</span><span>) </span><span style=color:#fabd2f>error </span><span>{
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>Operand</span><span>) </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0 </span><span style=color:#fe8019>|| </span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>Operand</span><span>) </span><span style=color:#fe8019>> </span><span style=color:#d3869b>1 </span><span>{
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Errorf</span><span>(</span><span style=color:#b8bb26>"invalid LOAD instruction: </span><span style=color:#fdf4c1>%s</span><span style=color:#b8bb26>"</span><span>, </span><span style=color:#fdf4c1>inst</span><span>)
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>name</span><span>, </span><span style=color:#fdf4c1>ok </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>Operand</span><span>[</span><span style=color:#d3869b>0</span><span>].(</span><span style=color:#fa5c4b>Symbol</span><span>); </span><span style=color:#fdf4c1>ok </span><span>{
</span><span>		</span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>v</span><span>, </span><span style=color:#fdf4c1>ok </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>Locals</span><span>[</span><span style=color:#fabd2f>string</span><span>(</span><span style=color:#fdf4c1>name</span><span>)]; </span><span style=color:#fdf4c1>ok </span><span>{
</span><span>			</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>Push</span><span>(</span><span style=color:#fdf4c1>v</span><span>)
</span><span>		} </span><span style=color:#fa5c4b>else </span><span>{
</span><span>			</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Errorf</span><span>(</span><span style=color:#b8bb26>"undefined name </span><span style=color:#fdf4c1>%s</span><span style=color:#b8bb26>"</span><span>, </span><span style=color:#fdf4c1>name</span><span>)
</span><span>		}
</span><span>	} </span><span style=color:#fa5c4b>else </span><span>{
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Errorf</span><span>(</span><span style=color:#b8bb26>"unexpected operand for instruction LOAD </span><span style=color:#fdf4c1>%v</span><span style=color:#b8bb26>(</span><span style=color:#fdf4c1>%T</span><span style=color:#b8bb26>)"</span><span>, </span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>Operand</span><span>[</span><span style=color:#d3869b>0</span><span>], </span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>Operand</span><span>[</span><span style=color:#d3869b>0</span><span>])
</span><span>	}
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>nil
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>func </span><span>(</span><span style=color:#fdf4c1>m </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>MiniVM</span><span>) </span><span style=color:#8ec07c>ExecNextInstruction</span><span>() </span><span style=color:#fabd2f>error </span><span>{
</span><span>	</span><span style=color:#fa5c4b>if </span><span style=color:#fabd2f>int</span><span>(</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>IP</span><span>) </span><span style=color:#fe8019>>= </span><span style=color:#fabd2f>len</span><span>(</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>Instructions</span><span>) {
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>ErrNoMoreInstructions
</span><span>	}
</span><span>
</span><span>	</span><span style=color:#fdf4c1>inst </span><span style=color:#fe8019>:= </span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>Instructions</span><span>[</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>IP</span><span>]
</span><span>	</span><span style=color:#fa5c4b>switch </span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>OpCode </span><span>{
</span><span>	</span><span style=color:#fa5c4b>case </span><span style=color:#fdf4c1>CALL</span><span>:
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>instCall</span><span>(</span><span style=color:#fdf4c1>inst</span><span>)
</span><span>	</span><span style=color:#fa5c4b>case </span><span style=color:#fdf4c1>RET</span><span>:
</span><span>		</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>instRet</span><span>(</span><span style=color:#fdf4c1>inst</span><span>)
</span><span>	</span><span style=color:#fa5c4b>case </span><span style=color:#fdf4c1>PUSH</span><span>:
</span><span>		</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>instPush</span><span>(</span><span style=color:#fdf4c1>inst</span><span>)
</span><span>	</span><span style=color:#fa5c4b>case </span><span style=color:#fdf4c1>POP</span><span>:
</span><span>		</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>instPop</span><span>(</span><span style=color:#fdf4c1>inst</span><span>)
</span><span>	</span><span style=color:#fa5c4b>case </span><span style=color:#fdf4c1>LOAD</span><span>:
</span><span>		</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>instLoad</span><span>(</span><span style=color:#fdf4c1>inst</span><span>)
</span><span>	</span><span style=color:#fa5c4b>default</span><span>:
</span><span>		</span><span style=color:#fa5c4b>return </span><span style=color:#fdf4c1>fmt</span><span>.</span><span style=color:#fdf4c1>Errorf</span><span>(</span><span style=color:#b8bb26>"unexpected opcode </span><span style=color:#fdf4c1>%v</span><span style=color:#b8bb26>"</span><span>, </span><span style=color:#fdf4c1>inst</span><span>.</span><span style=color:#fdf4c1>OpCode</span><span>)
</span><span>	}
</span><span>	</span><span style=color:#fdf4c1>m</span><span>.</span><span style=color:#fdf4c1>IP</span><span style=color:#fe8019>++
</span><span>	</span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>nil
</span><span>}
</span><span>
</span></code></pre><h2 id=0x04-jie-guo-zhan-shi>0x04 结果展示</h2><p><img alt=image-20211213160751960 src=https://nnnewb.github.io/posts/2021/stack-based-virtual-machine-for-minilang/image-20211213160751960.webp><p>PS：这个 <code>+</code> 也是函数。<h2 id=zong-jie>总结</h2><p>这个简单的 VM 写的时候脑子里想的都是 x86 汇编和 Python 的类型，所以内置类型定义就很粗暴，指令 OpCode 定义也是想当然。写成这样当然还是不满意的，都费了这么大劲了，简简单单做个 JIT 不过分吧？<p>但讲老实的，我还真不知道不用 CGO 的情况下，我就算是拿 <code>syscall</code> 这个包分配好了读写执行的空间也成功汇编出了机器码，也不知道怎么去调 Go 里定义的函数和数据结构。这一点看，要是一开始拿 C 写的话，问题就会好解决很多：够底层嘛，不用担心移植性和运行时的封装。<p>不过也不是真的一点办法也没有，干脆把内建类型和函数全部拿 C 或者 minilang 自己实现就好了，定义好数据结构，minilang 编译出来的指令全是调用自己或者调用C函数，再想翻译到汇编指令就简单很多了。到了这一步，直接拿 minilang 写一个编译自己的编译器也不是不行。</article><p class=tags-data><a href=/tags/golang>/golang/</a> <a href=/tags/bian-yi-ji-shu>/编译技术/</a> <a href=/tags/scheme>/scheme/</a> <a href=/tags/hui-bian>/汇编/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>