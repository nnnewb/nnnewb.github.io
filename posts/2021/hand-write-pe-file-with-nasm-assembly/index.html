<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>nasm汇编手写个PE可执行文件</title><meta content=nasm汇编手写个PE可执行文件 name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2021/hand-write-pe-file-with-nasm-assembly/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content=nasm汇编手写个PE可执行文件 property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2021/hand-write-pe-file-with-nasm-assembly/ property=twitter:url><meta content=nasm汇编手写个PE可执行文件 property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2021/hand-write-pe-file-with-nasm-assembly/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>nasm汇编手写个PE可执行文件</h1><p class=author-line>作于：2021-10-13 11:05 ，预计阅读时间 13 分钟<article><h2 id=qian-yan>前言</h2><p>主要是虽然有个汇编器 nasm 但是不知道怎么用，啥汇编都是调试器里纸上谈兵。最近碰到个问题，MinGW 可以用参数 <code>-Wl,section-start=</code> 来修改 section 地址，但 <em>msvc</em> 没有对应物，就蛋疼。手动改 PE 来添加 section 好像可行，但不知道该怎么做，lief 也不熟悉。<p>正好瞎谷歌的时候发现 nasm 可以直接编译出 PE 文件，这就听起来很有意思了。汇编嘛，听着就很底层，很自由，改个 Section 地址不是手到擒来。于是就学学看。<p>参考文章附于文末。<h2 id=0x01-nasm-ji-ben-yong-fa>0x01 nasm 基本用法</h2><h3 id=1-1-label>1.1 label</h3><p>汇编当然有经典的 <em>label</em> 和 <em>instruction</em> 了，<em>instruction</em> 的参数就叫 <em>operand</em> 。<p>nasm 的 label 语法很简单，任何不是宏和 <em>instruction</em> 或者伪指令的东西，出现在行首，都会被认作 label。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#8ec07c>lbl1:</span><span style=color:#928374;font-style:italic> ; 这是label
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>sub </span><span style=color:#fdf4c1>esp, </span><span style=color:#d3869b>4h
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>jmp </span><span style=color:#8ec07c>lbl
</span><span style=color:#8ec07c>lbl2</span><span style=color:#928374;font-style:italic>   ; 这也是 label
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>sub </span><span style=color:#fdf4c1>esp, </span><span style=color:#d3869b>4h
</span><span style=color:#8ec07c>lbl3 </span><span style=color:#fabd2f>db </span><span style=color:#d3869b>1</span><span style=color:#928374;font-style:italic> ; 这还是 label
</span><span style=color:#8ec07c>.label4</span><span style=color:#928374;font-style:italic> ; 这是本地 label，可以用 .label4 或者全称 lbl3.label4 访问
</span><span style=color:#8ec07c>.@label5</span><span style=color:#928374;font-style:italic> ; 这是特殊 label ，只能在宏里使用，避免干扰本地label
</span></code></pre><p>label 可以被视作一个数字参与运算，比如说 <code>lbl3-lbl2</code> 这样算出偏移。或者还可以参数伪指令计算。总之用处很多。<h3 id=1-2-wei-zhi-ling>1.2 伪指令</h3><p>伪指令是一些并不是真正的 x86 机器指令，但还是被用在了 instruction 域中的指 令，因为使用它们可以带来很大的方便。当前的伪指令有<code>DB</code>,<code>DW</code>,<code>DD</code>,<code>DQ</code>和 <code>DT</code>，它们对应的未初始化指令是 <code>RESB</code>, <code>RESW</code>,<code> RESD</code>,<code> RESQ</code> 和 <code>REST</code>，<code>INCBIN</code> 命令，<code>EQU</code> 命令和 <code>TIEMS</code> 前缀。<p>不复制粘贴了，看文档好吧。<h3 id=1-2-you-xiao-di-zhi>1.2 有效地址</h3><p>有效地址是指令的操作数，是对内存的引用。nasm中有效地址的语法非常简单：由一个可计算表达式组成，放在中括号内。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#8ec07c>wordvar:
</span><span style=color:#8ec07c>	</span><span style=color:#fabd2f>dw </span><span style=color:#d3869b>123
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>mov </span><span style=color:#fdf4c1>ax, [</span><span style=color:#8ec07c>wordvar</span><span style=color:#fdf4c1>]</span><span style=color:#928374;font-style:italic> ; [wordvar] 就是取 dw 123 的首地址
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>mov </span><span style=color:#fdf4c1>ax, [</span><span style=color:#8ec07c>wordvar</span><span style=color:#fdf4c1>+</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>]</span><span style=color:#928374;font-style:italic> ; wordvar+1 label 参与算术运算，取 dw 123 地址 + 1字节
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>mov </span><span style=color:#fdf4c1>ax, [es</span><span style=color:#8ec07c>:wordvar</span><span style=color:#fdf4c1>+bx]</span><span style=color:#928374;font-style:italic> ; 加上段选择子，寄存器参与运算
</span></code></pre><p>与上例不一致的表达式都不是 nasm 的有效地址，比如 <code>es:wordvar[bx]</code> 。<p>还可以用 <code>BYTE</code> <code>WORD</code> <code>DWORD</code> <code>NOSPLIT</code> 等关键字强迫 nasm 产生特定形式的有效地址。比如 <code>[dword eax+3]</code> 。<p>详细还是看文档。<h3 id=1-3-chang-shu>1.3 常数</h3><p>支持的常数类型包括：<ul><li><p>数值</p> <ul><li><code>100</code> 10进制<li><code>100h</code> 16进制，<code>h</code>结尾<li><code>0x100</code> 16进制，<code>0x</code>开头<li><code>$0100</code> 16进制，<code>$0</code>开头<li><code>777q</code> 8进制，<code>q</code>结尾<li><code>10010011b</code> 2进制，<code>b</code>结尾</ul><li><p>字符</p> <ul><li><code>abcd</code> 字符型常数，小端序</ul><li><p>字符串</p> <ul><li>一般只有伪指令接受，形式如 <code>db 'abcd'</code> 、<code>db 'a','b','c','d'</code> 。</ul><li><p>浮点数</p> <ul><li>反正用不到我也懒得看。</ul></ul><h3 id=1-4-biao-da-shi>1.4 表达式</h3><p>和C的差不多，除了+-*/%和位运算，多了个 <code>//</code> 表示带符号除法，<code>%%</code> 表示带符号取模。<h3 id=1-5-yu-chu-li-qi>1.5 预处理器</h3><p>预处理器指令以 <code>%</code> 开头。举几个例子<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#fabd2f>%define </span><span style=color:#8ec07c>FOO BAR
</span><span style=color:#fabd2f>%define </span><span style=color:#8ec07c>FN(x) (x</span><span style=color:#fdf4c1>+</span><span style=color:#d3869b>1</span><span style=color:#8ec07c>)
</span><span style=color:#fabd2f>%include </span><span style=color:#b8bb26>"xxx.asm"
</span><span style=color:#fabd2f>%undef </span><span style=color:#8ec07c>FOO
</span></code></pre><p>其他懒得写了，先知道这几个和C类似的宏就行，更多看文档。<h3 id=1-6-hui-bian-qi-zhi-ling>1.6 汇编器指令</h3><p>提几个会用到的。<p><code>BITS</code>，指定目标处理器模式，比如 <code>BITS 32</code> 就是32位模式。现在找16位的环境怕是也难。<p><code>SECTION</code>，改变正在编写的代码要汇编进的段。要是打算汇编成 <code>obj</code> 让链接器去链接出新文件会有点用。但是输出格式是 <code>bin</code> 的时候就没有卵用了。<p><code>EXTERN</code>，导入外部符号，还是汇编成 <code>obj</code> 让链接器用的时候会有点用，链接器会搞定链接，输出格式是 <code>bin</code> 的时候就没卵用。<p><code>GLOBAL</code>，导出符号，和<code>EXTERN</code>的应用场景差不多。熟悉C的码农应该能理解。<h3 id=1-7-shu-chu-ge-shi>1.7 输出格式</h3><p>几个值得关注的输出格式。<p><code>-f win32</code> 就是输出成 win32 对象文件 <code>.obj</code>，之后可以用 <code>gcc</code> 或者 <code>link.exe</code> 之类的东西链接。<p><code>-f bin</code> 输出成二进制文件，你写了啥就输出啥，nasm 就是个翻译官。<code>.COM</code>和<code>.SYS</code>都是纯二进制格式的，你要是写这些可能有用。还有操作系统引导程序之类的纯二进制程序，不需要别的什么文件格式的情况。<p><code>-f elf</code> 你要是写 linux 下的程序就有用。<h3 id=1-8-zong-jie>1.8 总结</h3><p>基本就是这样，更多东西就现查现用好吧。善用谷歌。<h2 id=0x02-jian-dan-hui-bian-cheng-xu>0x02 简单汇编程序</h2><p>先写一个简单的汇编程序，不直接产生可执行文件，而是需要链接器进一步链接。例子需要安装 MinGW。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#fabd2f>section </span><span style=color:#8ec07c>.data
</span><span>    </span><span style=color:#fabd2f>global </span><span style=color:#8ec07c>HelloWorld
</span><span>
</span><span style=color:#8ec07c>HelloWorld:
</span><span style=color:#8ec07c>    </span><span style=color:#fabd2f>db </span><span style=color:#b8bb26>'hello world'</span><span style=color:#fdf4c1>,</span><span style=color:#d3869b>0</span><span style=color:#928374;font-style:italic> ; 定义一个字符串常量，用于输出
</span><span>
</span><span style=color:#fabd2f>section </span><span style=color:#8ec07c>.text
</span><span>    </span><span style=color:#fabd2f>global </span><span style=color:#8ec07c>_main</span><span style=color:#928374;font-style:italic> ; _main 就是 C 的 main, 用于让链接器识别出入口点，生成命令行程序
</span><span>    </span><span style=color:#fabd2f>extern </span><span style=color:#8ec07c>_printf</span><span style=color:#928374;font-style:italic> ; _printf 就是 C 的 printf, 用于输出 hello world
</span><span>
</span><span style=color:#8ec07c>_main:
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>push </span><span style=color:#fdf4c1>ebp</span><span style=color:#928374;font-style:italic> ; 其实我们自己写就不用啰嗦 push ebp/mov ebp,esp 了, 心里有底就行
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>mov </span><span style=color:#fdf4c1>ebp, esp
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>push </span><span style=color:#8ec07c>HelloWorld</span><span style=color:#928374;font-style:italic> ; 压入字符串常量的地址做参数
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>call </span><span style=color:#8ec07c>_printf</span><span style=color:#928374;font-style:italic>    ; 调用 printf 输出
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>add </span><span style=color:#fdf4c1>esp, </span><span style=color:#d3869b>4</span><span style=color:#928374;font-style:italic>      ; 根据 cdecl 约定，完成平栈
</span><span style=color:#8ec07c>    </span><span style=color:#fa5c4b>pop </span><span style=color:#fdf4c1>ebp</span><span style=color:#928374;font-style:italic>         ; 要返回一个值的话可以再加一行 mov eax, 0 等同于 return 0
</span><span style=color:#8ec07c>    retn</span><span style=color:#928374;font-style:italic>            ; 完事
</span></code></pre><p>编译命令，要安装 MinGW 才有 gcc 可以用。或者其他链接器也可以，GoLink 好像就行，但是我没用过。<pre class=language-bash data-lang=bash style=color:#fdf4c1aa;background-color:#282828><code class=language-bash data-lang=bash><span style=color:#fdf4c1>nasm main.asm -f win32 -o main.o
</span><span style=color:#fdf4c1>gcc main.o -o main.exe
</span></code></pre><p>生成的代码放进调试器看看。<p><img alt=image-20211013092916141 src=https://nnnewb.github.io/posts/2021/hand-write-pe-file-with-nasm-assembly/image/nasm%E6%89%8B%E5%86%99%E4%B8%AAPE%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/image-20211013092916141.webp><p>可以看到我们的汇编代码忠实地出现在调试器里。<p>这就是 nasm 的简单用法了，想要拿汇编写一点简单的验证代码是没问题的，也可以手写汇编函数，再链接到 C/C++ 代码里。当然，写 C/C++ 的大佬大概也知道 Visual C++ 支持内嵌汇编，<code>__asm {}</code> 就行，这也算一种选项。<h2 id=0x03-sheng-cheng-er-jin-zhi-dai-ma>0x03 生成二进制代码</h2><p>使用 <code>nasm -f bin</code> 可以直接从汇编代码生成二进制文件，也就是没有链接这一步。<p>当然，没有链接这一步（或者说链接相关信息不由 nasm 管理），<code>global</code> 和 <code>extern</code> 都没有意义，在 <code>-f bin</code> 时汇编器会直接提示错误，不能使用。但相对的，因为 nasm 没自动生成更多信息，我们也对汇编结果有了更强的控制力，也要负担更多责任。<h3 id=3-1-sheng-cheng-dos-wen-jian-tou>3.1 生成 DOS 文件头</h3><p>PE 文件格式不再赘述，参考微软的 <a href=https://docs.microsoft.com/en-us/windows/win32/debug/pe-format>PE Format</a> 文档，或者维基百科的 PE 格式图即可。<p>先从生成 PE 文件的文件头开始，填充可执行文件的必要信息。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#fabd2f>BITS 32
</span><span>
</span><span style=color:#928374;font-style:italic>; 由编译器生成的 DOS 文件头其实包含了一段输出 This program cannot be run in DOS mode 的代码
</span><span style=color:#928374;font-style:italic>; 我们不需要，这里直接忽略。
</span><span style=color:#8ec07c>dos_header:
</span><span style=color:#8ec07c>    .magic    </span><span style=color:#fabd2f>dw    </span><span style=color:#b8bb26>"MZ"</span><span style=color:#928374;font-style:italic> ; dw 伪指令会放置一个双字节 word, 也就是操作数 MZ
</span><span style=color:#8ec07c>    .cblp     </span><span style=color:#fabd2f>dw     </span><span style=color:#d3869b>90h</span><span style=color:#928374;font-style:italic> ; 90h 就是 0x90
</span><span style=color:#8ec07c>    .cp       </span><span style=color:#fabd2f>dw     </span><span style=color:#d3869b>3
</span><span style=color:#8ec07c>    .crlc     </span><span style=color:#fabd2f>dw     </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .cparhdr  </span><span style=color:#fabd2f>dw     </span><span style=color:#d3869b>4
</span><span style=color:#8ec07c>    .minalloc </span><span style=color:#fabd2f>dw     </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .maxalloc </span><span style=color:#fabd2f>dw     </span><span style=color:#fdf4c1>-</span><span style=color:#d3869b>1
</span><span style=color:#8ec07c>    .</span><span style=color:#fdf4c1>ss       </span><span style=color:#fabd2f>dw     </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .</span><span style=color:#fdf4c1>sp       </span><span style=color:#fabd2f>dw     </span><span style=color:#d3869b>0B8h
</span><span style=color:#8ec07c>    .csum     </span><span style=color:#fabd2f>dw     </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .</span><span style=color:#fdf4c1>ip       </span><span style=color:#fabd2f>dw     </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .</span><span style=color:#fdf4c1>cs       </span><span style=color:#fabd2f>dw     </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .lfarlc   </span><span style=color:#fabd2f>dw     </span><span style=color:#d3869b>40h
</span><span style=color:#8ec07c>    .ovno     </span><span style=color:#fabd2f>dw     </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .res      </span><span style=color:#fabd2f>times  </span><span style=color:#d3869b>4 </span><span style=color:#fabd2f>dw </span><span style=color:#d3869b>0</span><span style=color:#928374;font-style:italic> ; 伪指令 times 重复 n 次，放置 4 个双字节 word ，值为 0
</span><span style=color:#8ec07c>    .oemid    </span><span style=color:#fabd2f>dw     </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .oeminfo  </span><span style=color:#fabd2f>dw     </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .res2     </span><span style=color:#fabd2f>times  </span><span style=color:#d3869b>10 </span><span style=color:#fabd2f>dw </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .lfanew   </span><span style=color:#fabd2f>dd     </span><span style=color:#8ec07c>.next</span><span style=color:#928374;font-style:italic>    ; 紧随其后的就是 NT 文件头了，所以 lfanew 直接指向自己末尾后
</span><span style=color:#8ec07c>    .next:
</span></code></pre><p>关于链接器自动生成的文件头，可以参考这篇文章 <a href=http://blog.marcinchwedczuk.pl/a-closer-look-at-portable-executable-msdos-stub>a closer look at portable executable MS-DOS stub</a> 。<p>反正咱无脑复制了。<h3 id=3-2-sheng-cheng-pe-wen-jian-tou>3.2 生成 PE 文件头</h3><p>生成 PE 文件头之前我们要预先考虑几个要素。<ul><li><p>文件如何对齐？</p> <p>对齐到 0x400，大部分内容都可以在一个 0x400 里填写完，计算量比较少。</p><li><p>Section 如何对齐？</p> <p>对齐到 0x1000，同样是简化计算。</p><li><p>需要几个 Section？</p> <p>一个 <code>.text</code> 就足够了。</p></ul><p>其余文件头内容，出于简单考虑，包括重定位和 IAT 在内的大部分东西都留空，仅仅写一个什么效果都没有的可执行文件。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#8ec07c>nt_header:
</span><span style=color:#8ec07c>pe_signature:
</span><span style=color:#8ec07c>    .sig                    </span><span style=color:#fabd2f>dd      </span><span style=color:#b8bb26>"PE"</span><span style=color:#928374;font-style:italic> ; 魔术标识, dd 伪指令填充一个 DWORD, 结果是 PE\0\0
</span><span>
</span><span style=color:#8ec07c>file_header:
</span><span style=color:#8ec07c>    .machine                </span><span style=color:#fabd2f>dw      </span><span style=color:#d3869b>0x014c</span><span style=color:#928374;font-style:italic> ; 支持 Intel I386
</span><span style=color:#8ec07c>    .numberofsections       </span><span style=color:#fabd2f>dw      </span><span style=color:#d3869b>0x01</span><span style=color:#928374;font-style:italic>   ; 本文件包含一个 Section
</span><span style=color:#8ec07c>    .timedatestamp          </span><span style=color:#fabd2f>dd      </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .pointertosymboltable   </span><span style=color:#fabd2f>dd      </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .numberofsymbols        </span><span style=color:#fabd2f>dd      </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .optheadersize          </span><span style=color:#fabd2f>dw      $</span><span style=color:#8ec07c>OPT_HEADER_SIZE</span><span style=color:#928374;font-style:italic> ; opt_header_size 会在稍后的 optional_header 末尾计算得到
</span><span style=color:#8ec07c>    .characteristics        </span><span style=color:#fabd2f>dw      </span><span style=color:#d3869b>0x102</span><span style=color:#928374;font-style:italic> 			; 声明本文件是一个32位Windows可执行程序
</span><span>
</span><span style=color:#8ec07c>optional_header:
</span><span style=color:#8ec07c>    .magic                      </span><span style=color:#fabd2f>dw </span><span style=color:#d3869b>0x10b
</span><span style=color:#8ec07c>    .linker_version             </span><span style=color:#fabd2f>db </span><span style=color:#d3869b>8</span><span style=color:#fdf4c1>,</span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .sizeof_code                </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>1000h</span><span style=color:#928374;font-style:italic> ; 共包含 0x1000 字节的代码段
</span><span style=color:#8ec07c>    .sizeof_initialized_data    </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .sizeof_uninitialized_data  </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .addressof_entrypoint       </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>1000h</span><span style=color:#928374;font-style:italic> ; 入口点 RVA
</span><span style=color:#8ec07c>    .baseof_code                </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>1000h</span><span style=color:#928374;font-style:italic> ; 代码段 RVA
</span><span style=color:#8ec07c>    .baseof_data                </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>0h</span><span style=color:#928374;font-style:italic>    ; 数据段 RVA, 没有数据段就留空了
</span><span style=color:#8ec07c>    .image_base                 </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>4000000h</span><span style=color:#928374;font-style:italic> ; 镜像基址 0x04000000, 后面是 6 个 0
</span><span style=color:#8ec07c>    .section_alignment          </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>1000h</span><span style=color:#928374;font-style:italic> ; section 对齐到 1000h
</span><span style=color:#8ec07c>    .file_alignment             </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>400h</span><span style=color:#928374;font-style:italic>  ; 文件对齐到 400h
</span><span style=color:#8ec07c>    .os_version                 </span><span style=color:#fabd2f>dw </span><span style=color:#d3869b>4</span><span style=color:#fdf4c1>,</span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .img_version                </span><span style=color:#fabd2f>dw </span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>,</span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .subsystem_version          </span><span style=color:#fabd2f>dw </span><span style=color:#d3869b>4</span><span style=color:#fdf4c1>,</span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .win32_ver_value            </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .sizeof_img                 </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>2000h</span><span style=color:#928374;font-style:italic> ; 请求的镜像总大小，文件头到代码段起点共 1000h, 代码段 1000h, 共计 2000h
</span><span style=color:#8ec07c>    .sizeof_headers             </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>400h</span><span style=color:#928374;font-style:italic>  ; 文件头大小对齐到了 400h, 我们知道文件头肯定不足 400h, 所以 sizeof_headers 直接填 400h 就行
</span><span style=color:#8ec07c>    .checksum                   </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .subsystem                  </span><span style=color:#fabd2f>dw </span><span style=color:#d3869b>2
</span><span style=color:#8ec07c>    .dll_characteristics        </span><span style=color:#fabd2f>dw </span><span style=color:#d3869b>0x400</span><span style=color:#928374;font-style:italic> ; 不支持 SEH, 不开启 ASLR
</span><span style=color:#8ec07c>    .sizeof_stack_reserved      </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>0x100000
</span><span style=color:#8ec07c>    .sizeof_stack_commit        </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>0x1000
</span><span style=color:#8ec07c>    .sizeof_heap_reserved       </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>0x100000
</span><span style=color:#8ec07c>    .sizeof_heap_commit         </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>0x1000
</span><span style=color:#8ec07c>    .loeader_flags              </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>0
</span><span style=color:#8ec07c>    .numberof_rva_and_sizes     </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>10h</span><span style=color:#928374;font-style:italic>   ; 后续有 16 个 Data Directories
</span><span>
</span><span style=color:#8ec07c>data_directories:
</span><span style=color:#8ec07c>    </span><span style=color:#fabd2f>times </span><span style=color:#d3869b>10h </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, </span><span style=color:#d3869b>0</span><span style=color:#928374;font-style:italic> ; 所有的 data directories 填充 0
</span><span>
</span><span style=color:#928374;font-style:italic>; 通过伪指令 equ ，给 $OPT_HEADER_SIZE 赋值为 (当前地址 - optional_header标签)
</span><span style=color:#928374;font-style:italic>; 也就是整个 optional_header 的大小
</span><span style=color:#fabd2f>$</span><span style=color:#8ec07c>OPT_HEADER_SIZE </span><span style=color:#fabd2f>equ </span><span style=color:#8ec07c>$ </span><span style=color:#fdf4c1>- </span><span style=color:#8ec07c>optional_header
</span><span>
</span><span style=color:#8ec07c>section_table:
</span><span style=color:#8ec07c>    .text:
</span><span style=color:#8ec07c>        </span><span style=color:#fabd2f>db </span><span style=color:#b8bb26>".text"</span><span style=color:#fdf4c1>, </span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, </span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, </span><span style=color:#d3869b>0</span><span style=color:#928374;font-style:italic>                     ; section name
</span><span style=color:#928374;font-style:italic>                                                ; 注意对齐到了 8 字节，不足部分 0 填充, 不能超出
</span><span style=color:#8ec07c>        </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>1000h</span><span style=color:#928374;font-style:italic>                                ; virtual size
</span><span style=color:#928374;font-style:italic>                                                ; Section 使用的内存大小
</span><span style=color:#8ec07c>        </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>1000h</span><span style=color:#928374;font-style:italic>                                ; virtual address
</span><span style=color:#928374;font-style:italic>                                                ; Section 的起始点 RVA
</span><span style=color:#8ec07c>        </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>400h</span><span style=color:#928374;font-style:italic>         					  ; sizeof raw data
</span><span style=color:#928374;font-style:italic>                                                ; 我们知道对齐到了 400h 且代码肯定比这少, 所以 raw data 必然有 400h 大小
</span><span style=color:#8ec07c>        </span><span style=color:#fabd2f>dd </span><span style=color:#8ec07c>code</span><span style=color:#928374;font-style:italic>                                 ; pointer to raw data
</span><span style=color:#928374;font-style:italic>                                                ; 用 label 告诉汇编器 raw data 的偏移
</span><span style=color:#8ec07c>        </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>0</span><span style=color:#928374;font-style:italic>                                    ; pointer to relocations
</span><span style=color:#8ec07c>        </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>0</span><span style=color:#928374;font-style:italic>                                    ; pointer to linenum
</span><span style=color:#8ec07c>        </span><span style=color:#fabd2f>dw </span><span style=color:#d3869b>0</span><span style=color:#928374;font-style:italic>                                    ; number of relocations
</span><span style=color:#8ec07c>        </span><span style=color:#fabd2f>dw </span><span style=color:#d3869b>0</span><span style=color:#928374;font-style:italic>                                    ; number of linenum
</span><span style=color:#8ec07c>        </span><span style=color:#fabd2f>dd </span><span style=color:#d3869b>0x60000020</span><span style=color:#928374;font-style:italic>                           ; characteristics
</span><span style=color:#928374;font-style:italic>                                                ; 含义是：代码段 - 可读
</span><span>
</span><span style=color:#fabd2f>align </span><span style=color:#d3869b>400h</span><span style=color:#fdf4c1>, </span><span style=color:#fabd2f>db </span><span style=color:#d3869b>0
</span><span style=color:#928374;font-style:italic>; align 伪指令，不足的部分填充0, 对齐到 400h
</span><span style=color:#928374;font-style:italic>; 相对文件头到这里, 肯定是不足 400h 的, align 伪指令会填充到满 400h 为止。
</span><span style=color:#928374;font-style:italic>; 这样一来, 整个文件头大小, 正好就是 400h
</span></code></pre><h3 id=3-2-bian-xie-hui-bian-dai-ma>3.2 编写汇编代码</h3><p>文件头定义完成后，就可以开始写汇编代码了。正常这时候还要处理导入表，但我们跳过了。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#8ec07c>code:
</span><span style=color:#8ec07c>.start:
</span><span style=color:#8ec07c>	</span><span style=color:#fa5c4b>xor </span><span style=color:#fdf4c1>eax, eax
</span><span style=color:#8ec07c>	retn
</span><span>
</span><span style=color:#fabd2f>align </span><span style=color:#d3869b>400h</span><span style=color:#fdf4c1>, </span><span style=color:#fabd2f>db </span><span style=color:#d3869b>0</span><span style=color:#928374;font-style:italic> ; 同样，再次对齐到 400h ，把代码段的剩余部分填充成 0
</span></code></pre><p>到这里，整个 PE 文件的内容就填写完毕了。<p>文件头的绝大多数字段并不是我们关注的对象，计算偏移和对齐是最蛋疼的。<h3 id=3-3-guan-yu-dui-qi-de-keng>3.3 关于对齐的坑</h3><blockquote><p>There are additional restrictions on image files if the SectionAlignment value in the optional header is less than the page size of the architecture. For such files, the location of section data in the file must match its location in memory when the image is loaded, so that the physical offset for section data is the same as the RVA.</blockquote><p>微软文档里指出，在 Section 对齐的大小小于体系结构指定的页大小（4K）的时候，会有个额外限制，要求 Section 数据在文件中的偏移 <strong>必须</strong> 对应在内存中的 RVA 。也就是说，如果 Section 对齐为 1 字节，<code>VirtualAddress</code> 指定为 1000h，那 Section 数据必须存放在文件的 1000h 偏移处，否则生成的可执行文件会出现“不是有效的Win32应用程序”错误。<h3 id=3-4-qi-ta-keng>3.4 其他坑</h3><p>建议不要参考单独的某几篇文章，多找些相关的文章博客和文档，互相对照着看。PE格式错误不会有具体的提示，我也没找到什么好用的工具去检查到底哪儿有错，只能建议多用用 CFF Explorer 和 lief、pefile 这些能检查文件格式的库了，要是这些都不行那就看看16进制编辑器什么的吧，比如 HexWorkshop。IDA 在这儿没啥用。<p>另外我还发现1字节对齐的时候，x32dbg 调试会看不到汇编代码，在内存布局里进入自己的PE文件后只能看到PE头，但没有反汇编。不过调试器还是可以正常单步调试和查看寄存器。<h3 id=3-5-bian-yi>3.5 编译</h3><p>上面的汇编代码用 nasm 即可编译，不需要其他编译或链接工具了。<pre class=language-bash data-lang=bash style=color:#fdf4c1aa;background-color:#282828><code class=language-bash data-lang=bash><span style=color:#fdf4c1>nasm pe.asm -f bin -o pe.exe
</span></code></pre><p><img alt=image-20211013104216658 src=https://nnnewb.github.io/posts/2021/hand-write-pe-file-with-nasm-assembly/image/nasm%E6%89%8B%E5%86%99%E4%B8%AAPE%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/image-20211013104216658.webp><p>也可以放进调试器看看。<p><img alt=image-20211013104451137 src=https://nnnewb.github.io/posts/2021/hand-write-pe-file-with-nasm-assembly/image/nasm%E6%89%8B%E5%86%99%E4%B8%AAPE%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/image-20211013104451137.webp><p>可以看到，代码段正确出现在 4001000h 这个地址上（基址+1000h），内容也符合我们写的汇编代码。<p><img alt=image-20211013104646905 src=https://nnnewb.github.io/posts/2021/hand-write-pe-file-with-nasm-assembly/image/nasm%E6%89%8B%E5%86%99%E4%B8%AAPE%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/image-20211013104646905.webp><p>在内存布局窗口也能看到。<h2 id=zong-jie>总结</h2><p>这是个对 PE 文件格式有所了解后的一个简单应用，原先是只会拿其他编程语言去读 PE 文件头的内容，现在学会了用汇编器去写一个简单的 PE 文件。之所以是汇编器去写，而不是拿 C/C++/Python 去写，还是因为我菜而且懒。好了跳过关于我菜的话题吧。<p>参考文档（不分先后）：<ul><li>http://blog.marcinchwedczuk.pl/a-closer-look-at-portable-executable-msdos-stub<li>https://docs.microsoft.com/en-us/windows/win32/debug/pe-format<li>https://reverseengineering.stackexchange.com/questions/11758/how-do-you-calculate-address-start-size-of-pe-section-like-rdata-data<li>http://www.phreedom.org/research/tinype/<li>https://stackoverflow.com/questions/17456372/create-and-use-sections-for-pe-file-in-assembly-nasm<li>https://bitcodersblog.wordpress.com/2017/05/10/win32-in-nasm-part-1/</ul><p>大部分代码其实是来自 tinype，被我调来调去改了很多。自己动手折腾一遍远比走马观花看一遍收获更多，有些实践问题不跟着抄一次改一改是不会发现的。有言道“实践出真知”，虽然说现在有些沙雕把生活经验当成真理导致一帮人捧书本一帮人捧经验，搞得啥事情都非黑即白...把伟人的话当成互相攻讦的武器。<p>淦，好好的学习，结果总结的时候越想越气。<p>果然，“人类的悲欢并不相通，我只觉得他们吵闹。”</article><p class=tags-data><a href=/tags/hui-bian>/汇编/</a> <a href=/tags/ni-xiang>/逆向/</a> <a href=/tags/windows>/windows/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>