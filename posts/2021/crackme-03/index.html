<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>自娱自乐 crackme-03</title><meta content="自娱自乐 crackme-03" name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2021/crackme-03/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content="自娱自乐 crackme-03" property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2021/crackme-03/ property=twitter:url><meta content="自娱自乐 crackme-03" property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2021/crackme-03/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>自娱自乐 crackme-03</h1><p class=author-line>作于：2021-09-24 16:58 ，预计阅读时间 13 分钟<article><h2 id=qian-yan>前言</h2><p>总得有个前言。<p>一直玩命令行 crackme 看着就没啥意思，来点带界面的。依然是学习用，目标是把汇编和底层和内存这套东西读熟。这次是用 wxwidgets 做的简单 crackme，为了在 CrackME-02 基础上再增加点难度但又不至于太难，这次是 OTP 生成序列号，要求解出生成 OTP 的 SECRET。<h2 id=yuan-ma>源码</h2><p>越来越长了，贴上来没法看。现在托管到GitHub，包括前面的两个cm。<p>前两个cm托管的代码编译参数有一点修改，可能造成结果和文章不一致，但大体是一样的，别在意。<p>源码托管地址：<a href=https://github.com/nnnewb/crackmes/>github.com/nnnewb/crackmes</a><p>挑战一下C++代码开启优化的Hard模式。<h2 id=guan-cha>观察</h2><p><img alt=image-20210923104439284 src=https://nnnewb.github.io/posts/2021/crackme-03/image/crackme-03/01.webp><p>一个输入框，点击try it尝试。失败时提示Wrong，没有别的信息。<h2 id=jing-tai-fen-xi>静态分析</h2><p>老规矩先静态分析一波，粗略扫一眼，捋一捋逻辑。用你喜欢的反汇编工具打开，我用Cutter先试试。<p>因为是GUI程序，直接跳<code>main</code>肯定是不行的。Win32 GUI程序的入口点（程序员视角）在<code>WinMain</code>这个特殊函数，不过真拿Win32API手撸界面我是真没见过了，Win32 GUI程序设计也是玩的事件响应，找到主函数的意义不大。<p>所以找关键跳这一步只能是从数据段找字符串查引用，或者调试器下合适的访问断点了。<p>这里直接从数据段找到了字符串，定位到弹出错误对话框的逻辑。<p><img alt=image-20210923105415082 src=https://nnnewb.github.io/posts/2021/crackme-03/image/crackme-03/02.webp><p>这里有个姿势点是<code>__thiscall</code>，这是个微软自定义的调用约定，点这里看<a href="https://docs.microsoft.com/zh-cn/cpp/cpp/thiscall?view=msvc-160">微软的文档</a>。<h3 id=thiscall>__thiscall</h3><p><code>__thiscall</code>的特点是被调用方清栈，<code>this</code>指针通过<code>ecx</code>寄存器传递，其他参数右至左压栈。对于可变长度参数（VAARG）的成员函数会特殊处理，采用<code>cdecl</code>调用约定，<code>this</code>指针最后压栈。<p>这里简单读一下定位到的几句代码，分析下意图。<pre style=color:#fdf4c1aa;background-color:#282828><code><span>
</span><span>0x004064dc      68 34 e8 40 00              push    str.Try_again ; 0x40e834
</span><span>0x004064e1      8d 4d d0                    lea     ecx, [ebp - 0x30]
</span><span>0x004064e4      ff 15 e0 33 41 00           call    dword [public: void __thiscall wxString::constructor(char const *)] ; 0x4133e0
</span><span>0x004064ea      68 44 e8 40 00              push    str.Wrong ; 0x40e844
</span><span>0x004064ef      8d 4d b0                    lea     ecx, [ebp - 0x50]
</span><span>0x004064f2      c6 45 fc 07                 mov     byte [ebp - 4], 7
</span><span>0x004064f6      ff 15 e0 33 41 00           call    dword [public: void __thiscall wxString::constructor(char const *)] ; 0x4133e0
</span><span>0x004064fc      6a ff                       push    0xffffffffffffffff
</span><span>0x004064fe      6a ff                       push    0xffffffffffffffff
</span><span>0x00406500      6a 00                       push    0
</span><span>0x00406502      6a 05                       push    5 ; 5
</span><span>0x00406504      8d 45 d0                    lea     eax, [ebp - 0x30]
</span><span>0x00406507      c6 45 fc 08                 mov     byte [ebp - 4], 8
</span><span>0x0040650b      50                          push    eax
</span><span>0x0040650c      8d 45 b0                    lea     eax, [ebp - 0x50]
</span><span>0x0040650f      50                          push    eax
</span><span>0x00406510      ff 15 d4 3c 41 00           call    dword [int __cdecl wxMessageBox(class wxString const &, class wxString const &, long int, class wxWindow *, int, int)] ; 0x413cd4
</span></code></pre><p>反编译器对调用的第三方库的函数分析极大降低了肉眼判读的难度。可以看到前三步<code>push</code>、<code>lea ecx,...</code>、<code>call</code> 是典型的 <code>__thiscall</code> 调用，调用对象是<code>wxString</code>的构造器，所以可以知道<code>ecx</code>地址保存的是一个<code>wxString</code>对象的指针。<pre style=color:#fdf4c1aa;background-color:#282828><code><span>0x004064ea      68 44 e8 40 00              push    str.Wrong ; 0x40e844
</span><span>0x004064ef      8d 4d b0                    lea     ecx, [ebp - 0x50]
</span><span>0x004064f2      c6 45 fc 07                 mov     byte [ebp - 4], 7
</span><span>0x004064f6      ff 15 e0 33 41 00           call    dword [public: void __thiscall wxString::constructor(char const *)] ; 0x4133e0
</span></code></pre><p>这是另一个<code>wxString</code>的构造。<pre style=color:#fdf4c1aa;background-color:#282828><code><span>0x004064fc      6a ff                       push    0xffffffffffffffff
</span><span>0x004064fe      6a ff                       push    0xffffffffffffffff
</span><span>0x00406500      6a 00                       push    0
</span><span>0x00406502      6a 05                       push    5 ; 5
</span><span>0x00406504      8d 45 d0                    lea     eax, [ebp - 0x30]
</span><span>0x00406507      c6 45 fc 08                 mov     byte [ebp - 4], 8
</span><span>0x0040650b      50                          push    eax
</span><span>0x0040650c      8d 45 b0                    lea     eax, [ebp - 0x50]
</span><span>0x0040650f      50                          push    eax
</span><span>0x00406510      ff 15 d4 3c 41 00           call    dword [int __cdecl wxMessageBox(class wxString const &, class wxString const &, long int, class wxWindow *, int, int)] ; 0x413cd4
</span></code></pre><p>连续推入多个参数后，调用了<code>wxMessageBox</code>函数。我们知道<code>[ebp-0x30]</code>是<code>Try again</code>，<code>[ebp-0x50]</code> 是 <code>Wrong!</code>，这个调用用伪代码表示就是 <code>wxMessageBox("Wrong!", "Try again!", 5, 0, -1, -1)</code>。注意忽略中间的<code>mov     byte [ebp - 4], 8</code>，<code>ebp-4</code>这个偏移显然不大可能是参数。<h3 id=guan-jian-tiao>关键跳</h3><p>回到这段代码的开头，顺着界面上的绿色箭头找到关键跳。<p><img alt=image-20210923111554787 src=https://nnnewb.github.io/posts/2021/crackme-03/image/crackme-03/03.webp><p>一个<code>je</code>跳转，<code>je</code>指令检查<code>ZF</code>，向上一行就是<code>test</code>，<code>test bl,bl</code>自己对自己逻辑与，其实就是求<code>bl</code>是不是0。<p>bl又来自前面的<code>mov bl,al</code>，<code>al</code>寄存器是<code>eax</code>寄存器的低8位，再者大家也知道<code>eax</code>寄存器是函数返回值保存的寄存器，而离这个<code>mov</code>指令最近的<code>call</code>就是截图上方的<code>IsSameAs</code>函数了。<p>到了这一步，改指令跳过验证已经接近成功了，但这要是做 keygen 的话还不行。<p>继续往回翻，寻找密码生成的代码。<h3 id=xun-zhao-mi-ma-sheng-cheng-suan-fa>寻找密码生成算法</h3><p>先一路回到关键跳所处的代码块顶部，挨个往下看有哪些函数调用。<p><img alt=image-20210923113330184 src=https://nnnewb.github.io/posts/2021/crackme-03/image/crackme-03/04.webp><p>还是那句话，感谢分析出了库函数，不然一堆未知函数看得满头雾水。<ol><li><p>调用是 <code>wxString.AsWChar(void)</code>，顾名思义是取宽字符，返回指针。</p><li><p>调用是<code>wxString.DoFormatWchar(wchar_t*)</code>，查询文档可知是个类似<code>sprintf</code>的字符串格式化函数。</p><li><p>调用是析构函数，怀疑上面的两个调用其实是内联了什么wxwidgets库的代码。因为直觉告诉我如果还没离开作用域，编译器应该不会这么着急插入析构函数调用，这听起来就没什么好处，还违背码农直觉。</p><li><p>函数就比较迷惑了，一路看上去的话会发现这个偏移值经过了多次计算，目前看不出用意，但还挺可疑的。</p><li><p>函数顾名思义，比较字符串相等。</p><li><p>又是析构函数。</p></ol><p>重点看字符串比较函数的参数：<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#d3869b>0x0040646c      </span><span style=color:#8ec07c>6a </span><span style=color:#d3869b>01                       </span><span style=color:#fa5c4b>push    </span><span style=color:#d3869b>1</span><span style=color:#928374;font-style:italic> ; 1
</span><span style=color:#d3869b>0x0040646e      </span><span style=color:#8ec07c>8d 4d </span><span style=color:#d3869b>90                    </span><span style=color:#fa5c4b>lea     </span><span style=color:#fdf4c1>ecx, [ebp - </span><span style=color:#d3869b>0x70</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x00406471      </span><span style=color:#8ec07c>c6 </span><span style=color:#d3869b>45 </span><span style=color:#8ec07c>fc </span><span style=color:#d3869b>04                 </span><span style=color:#fa5c4b>mov     </span><span style=color:#fabd2f>byte </span><span style=color:#fdf4c1>[ebp - </span><span style=color:#d3869b>4</span><span style=color:#fdf4c1>], </span><span style=color:#d3869b>4
</span><span style=color:#d3869b>0x00406475      51                          </span><span style=color:#fa5c4b>push    </span><span style=color:#fdf4c1>ecx
</span><span style=color:#d3869b>0x00406476      </span><span style=color:#8ec07c>8b c8                       </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>ecx, eax
</span><span style=color:#d3869b>0x00406478      </span><span style=color:#8ec07c>ff </span><span style=color:#d3869b>15 </span><span style=color:#8ec07c>d4 </span><span style=color:#d3869b>33 41 00           </span><span style=color:#fa5c4b>call    </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>public: bool __thiscall wxString::IsSameAs(class wxString const &</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>bool)const</span><span style=color:#fdf4c1>]</span><span style=color:#928374;font-style:italic> ; 0x4133d4
</span></code></pre><p>把<code>eax</code>当成了<code>this</code>，暂且不看栈上的<code>ebp-0x70</code>，看到<code>eax</code>立刻就发现是来自第四个比较迷惑的函数调用，实锤这函数就是生成密码的函数。<h2 id=dong-tai-diao-shi>动态调试</h2><p>水平有限，静态分析很快遇到了瓶颈，找不出这个偏移值算出来的函数到底在哪儿。<p>于是启动调试器，先跟到我们定位到的这个特殊函数。<p><img alt=image-20210923140108796 src=https://nnnewb.github.io/posts/2021/crackme-03/image/crackme-03/05.webp><p>惊喜地发现胡乱分析出现了错误，<code>eax+0x40</code>其实是获取输入框值的函数。。所以另一个参数，<code>ebp-0x70</code>才是密码。<p>往回看<code>ebp-0x70</code>在<code>DoFormatWchar</code>被当参数传递了进去，要注意的是<code>DoFormatWchar</code>是一个有变长参数的函数，这意味着你没法得知传了几个参数（前面push的内容不一定是当参数传了），分析更困难。<p>看一下<code>DoFormatWchar</code>这段汇编。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#d3869b>0x0040642c      </span><span style=color:#8ec07c>8d 8d </span><span style=color:#d3869b>70 </span><span style=color:#8ec07c>ff ff ff           </span><span style=color:#fa5c4b>lea     </span><span style=color:#fdf4c1>ecx, [ebp - </span><span style=color:#d3869b>0x90</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x00406432      </span><span style=color:#8ec07c>ff </span><span style=color:#d3869b>15 </span><span style=color:#8ec07c>e8 </span><span style=color:#d3869b>33 41 00           </span><span style=color:#fa5c4b>call    </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>private: wchar_t const </span><span style=color:#fdf4c1>* </span><span style=color:#8ec07c>__thiscall wxFormatString::AsWChar(void)</span><span style=color:#fdf4c1>]</span><span style=color:#928374;font-style:italic> ; 0x4133e8
</span><span style=color:#d3869b>0x00406438      56                          </span><span style=color:#fa5c4b>push    </span><span style=color:#fdf4c1>esi
</span><span style=color:#d3869b>0x00406439      50                          </span><span style=color:#fa5c4b>push    </span><span style=color:#fdf4c1>eax
</span><span style=color:#d3869b>0x0040643a      </span><span style=color:#8ec07c>8d </span><span style=color:#d3869b>45 90                    </span><span style=color:#fa5c4b>lea     </span><span style=color:#fdf4c1>eax, [ebp - </span><span style=color:#d3869b>0x70</span><span style=color:#fdf4c1>]
</span><span style=color:#d3869b>0x0040643d      50                          </span><span style=color:#fa5c4b>push    </span><span style=color:#fdf4c1>eax
</span><span style=color:#d3869b>0x0040643e      </span><span style=color:#8ec07c>ff </span><span style=color:#d3869b>15 </span><span style=color:#8ec07c>d0 </span><span style=color:#d3869b>33 41 00           </span><span style=color:#fa5c4b>call    </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[</span><span style=color:#8ec07c>private: static class wxString __cdecl wxString::DoFormatWchar(wchar_t const </span><span style=color:#fdf4c1>*</span><span style=color:#8ec07c>)</span><span style=color:#fdf4c1>]</span><span style=color:#928374;font-style:italic> ; 0x4133d0
</span></code></pre><p>一共推了三个东西入栈，esi、eax（上一个调用的返回值）、还有<code>[ebp-0x70]</code>。<p>继续调试器跟一遍看看。<p><img alt=image-20210923142010900 src=https://nnnewb.github.io/posts/2021/crackme-03/image/crackme-03/06.webp><p><code>esi</code>的值比较怪，先忽略。<p><code>eax</code>比较清楚，宽字符串<code>%06d</code>，按压栈顺序，<code>esi</code>的值是紧跟在格式化字符串后面的参数。<p><img alt=image-20210923142347785 src=https://nnnewb.github.io/posts/2021/crackme-03/image/crackme-03/07.webp><p>最后压栈的eax，也就是ebp-0x70的地址，用伪代码表示就是：<code>DoFormatWchar(&var_70, L"%06d", 0x000F18D8)</code>。PS：有点怪，函数签名最左侧是format也就是格式化字符串，最后压栈这个ebp-0x70就有点莫名其妙。<p><img alt=image-20210923143534148 src=https://nnnewb.github.io/posts/2021/crackme-03/image/crackme-03/08.webp><p>不过用调试器单步步过后就知道用途了，和猜测的一样，存放的是格式化的结果，也就是正确的密码。<p>既然如此，往回找esi是哪儿赋值的，因为inline了一大堆东西，Cutter连函数都认不出来了，控制流视图也挂了。。一直往上翻，找到<code>0xcc</code>或者<code>push ebp; mov ebp, esp</code>为止。<p><img alt=image-20210923145922049 src=https://nnnewb.github.io/posts/2021/crackme-03/image/crackme-03/09.webp><p>右键选择在此处定义函数，随便给个名字，然后等Cutter分析好函数体。<p><img alt=image-20210923150100196 src=https://nnnewb.github.io/posts/2021/crackme-03/image/crackme-03/10.webp><p>这样一来至少图形视图就能看了。粗略扫一眼，在底下找到<code>IsSameAs</code>这个调用，再往回翻哪儿动了<code>esi</code>这个寄存器，很快找到这两段。<p><img alt=image-20210923150438821 src=https://nnnewb.github.io/posts/2021/crackme-03/image/crackme-03/11.webp><p>有点杂，先看看。还是粗略按意图把指令分下段。<code>esi</code>来源涉及<code>eax</code>和<code>ecx</code>，一路跟着赋值路径往回翻到第一个块，找到<code>ecx</code>的赋值。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#d3869b>0x004062f1      </span><span style=color:#8ec07c>e8 </span><span style=color:#d3869b>68 </span><span style=color:#8ec07c>b3 ff ff              </span><span style=color:#fa5c4b>call    </span><span style=color:#8ec07c>fcn.0040165e
</span><span style=color:#d3869b>0x004062f6      </span><span style=color:#8ec07c>8b </span><span style=color:#d3869b>08                       </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>ecx, </span><span style=color:#fabd2f>dword </span><span style=color:#fdf4c1>[eax]
</span></code></pre><p>一个未知函数，ctrl+左键点击跟进去后发现疑似是 libcrypto 内联的函数，调用了 HMAC-SHA1 算法。<p><img alt=image-20210924092624224 src=https://nnnewb.github.io/posts/2021/crackme-03/image/crackme-03/12.webp><p>先做个标记，猜测假设这个函数正确返回（下面的je跳转走到最后一个块），那返回结果应该是HMAC-SHA1的结果。这里通过调试器单步验证。<p>因为 ASLR 的缘故，可执行文件 .text 段映射的地址不是 0x00401000，调试器没法直接转到静态分析工具中的地址，ASLR 确实折磨人...<p>anyway...<p>我投翔，特立独行是没好结果的，跑去下载了一个 IDA Free ，打开x32dbg确认 .text 段映射的基址后再到 IDA 的菜单 <code>Edit</code> -> <code>Segments</code> -> <code>rebase program ...</code> 重新设定镜像基址，这样在反汇编界面看到的地址就能和调试器对上了。缺陷是每次打开调试器都要对一次镜像基址，比较麻烦。<p><img alt=image-20210924154631893 src=https://nnnewb.github.io/posts/2021/crackme-03/image/crackme-03/image-20210924154631893.webp><p>对好镜像基址后，把之前想调试的函数调用地址找到（0x003B62F1），下个断点，看调用后的<code>eax</code>值，发现并不像纯c编译出来的结果，<code>eax</code>并没有什么卵用。<p>稍微往上瞟了一眼，很容易看到一个<code>mov ecx,esi</code>，但没什么卵用。<p>碰壁几次后决定跟进这个函数看看。无果。恼，作弊之（读过RFC可能注意到几个特殊常量，比如取哈希结果下标19，与0xf，作为偏移值向后再取4字节，作为bin code。跳过这个函数调用，直接看接下来的内容的话，会发现哈希值其实就存在<code>ecx</code>保存的地址上了。）<p><img alt=image-20210924162043275 src=https://nnnewb.github.io/posts/2021/crackme-03/image/crackme-03/image-20210924162043275.webp><p>只是这里的HMAC_SHA1值因为不是我们熟悉的ASCII表示，所以一眼有点难看出来。<p>那么直接跳过上面不清不楚的地方，直接看取哈希后的做法。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#8ec07c>.text:003B6307 </span><span style=color:#fa5c4b>movzx   </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>byte ptr </span><span style=color:#fdf4c1>[ecx+</span><span style=color:#d3869b>13h</span><span style=color:#fdf4c1>]
</span><span style=color:#8ec07c>.text:003B630B </span><span style=color:#fa5c4b>and     </span><span style=color:#fdf4c1>eax, </span><span style=color:#d3869b>0Fh</span><span style=color:#928374;font-style:italic> ; 取 hash[19] & 0xf 作为初始偏移
</span><span style=color:#8ec07c>.text:003B630E </span><span style=color:#fa5c4b>add     </span><span style=color:#fdf4c1>ecx, eax
</span><span style=color:#8ec07c>.text:003B6310 </span><span style=color:#fa5c4b>movzx   </span><span style=color:#fdf4c1>esi, </span><span style=color:#fabd2f>byte ptr </span><span style=color:#fdf4c1>[ecx]</span><span style=color:#928374;font-style:italic> ; 取偏移处第一个字节，无符号
</span><span style=color:#8ec07c>.text:003B6313 </span><span style=color:#fa5c4b>movzx   </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>byte ptr </span><span style=color:#fdf4c1>[ecx+</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>]</span><span style=color:#928374;font-style:italic> ; 取偏移处第二个字节，无符号
</span><span style=color:#8ec07c>.text:003B6317 </span><span style=color:#fa5c4b>and     </span><span style=color:#fdf4c1>esi, </span><span style=color:#d3869b>7Fh</span><span style=color:#928374;font-style:italic> ; 偏移处第一个字节 & 0x7f ，确保符号位归零
</span><span style=color:#8ec07c>.text:003B631A </span><span style=color:#fa5c4b>shl     </span><span style=color:#fdf4c1>esi, </span><span style=color:#d3869b>8</span><span style=color:#928374;font-style:italic> ; 第一个字节左移8位后 | 第二个字节，就是把四个字节按顺序填进esi
</span><span style=color:#8ec07c>.text:003B631D </span><span style=color:#fa5c4b>or      </span><span style=color:#fdf4c1>esi, eax
</span><span style=color:#8ec07c>.text:003B631F </span><span style=color:#fa5c4b>movzx   </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>byte ptr </span><span style=color:#fdf4c1>[ecx+</span><span style=color:#d3869b>2</span><span style=color:#fdf4c1>]
</span><span style=color:#8ec07c>.text:003B6323 </span><span style=color:#fa5c4b>shl     </span><span style=color:#fdf4c1>esi, </span><span style=color:#d3869b>8
</span><span style=color:#8ec07c>.text:003B6326 </span><span style=color:#fa5c4b>or      </span><span style=color:#fdf4c1>esi, eax
</span><span style=color:#8ec07c>.text:003B6328 </span><span style=color:#fa5c4b>movzx   </span><span style=color:#fdf4c1>eax, </span><span style=color:#fabd2f>byte ptr </span><span style=color:#fdf4c1>[ecx+</span><span style=color:#d3869b>3</span><span style=color:#fdf4c1>]
</span><span style=color:#8ec07c>.text:003B632C </span><span style=color:#fa5c4b>shl     </span><span style=color:#fdf4c1>esi, </span><span style=color:#d3869b>8
</span></code></pre><p>取得的就是4字节正整数了，按RFC的例子，接下来应该取模得到最大6位整数。看下一块汇编。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#8ec07c>.text:003B6331 </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>ecx, [ebp+</span><span style=color:#8ec07c>Block</span><span style=color:#fdf4c1>]
</span><span style=color:#8ec07c>.text:003B6334 </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, </span><span style=color:#d3869b>431BDE83h</span><span style=color:#928374;font-style:italic> ; magic ?
</span><span style=color:#8ec07c>.text:003B6339 </span><span style=color:#fa5c4b>imul    </span><span style=color:#fdf4c1>esi
</span><span style=color:#8ec07c>.text:003B633B </span><span style=color:#fa5c4b>sar     </span><span style=color:#fdf4c1>edx, </span><span style=color:#d3869b>12h
</span><span style=color:#8ec07c>.text:003B633E </span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, edx
</span><span style=color:#8ec07c>.text:003B6340 </span><span style=color:#fa5c4b>shr     </span><span style=color:#fdf4c1>eax, </span><span style=color:#d3869b>1Fh
</span><span style=color:#8ec07c>.text:003B6343 </span><span style=color:#fa5c4b>add     </span><span style=color:#fdf4c1>eax, edx
</span><span style=color:#8ec07c>.text:003B6345 </span><span style=color:#fa5c4b>imul    </span><span style=color:#fdf4c1>eax, </span><span style=color:#d3869b>0F4240h
</span><span style=color:#8ec07c>.text:003B634B </span><span style=color:#fa5c4b>sub     </span><span style=color:#fdf4c1>esi, eax
</span><span style=color:#8ec07c>.text:003B634D </span><span style=color:#fa5c4b>test    </span><span style=color:#fdf4c1>ecx, ecx
</span><span style=color:#8ec07c>.text:003B634F </span><span style=color:#fa5c4b>jz      </span><span style=color:#8ec07c>short loc_3B638F
</span></code></pre><p><code>431BDE83h</code> 这个魔术常量吓到我了。搜了一下找到篇<a href=https://bbs.pediy.com/thread-100189.htm>看雪的帖子</a>，看起来是编译器把一句<code>%1000000</code>取模给编译成了上面这一串满是魔数的汇编。尝试跟到 <code>sub esi,eax</code> 后，<code>esi</code> 寄存器的结果的确变成了6位以内的整数。<p>这玩意儿有什么特征吗？总不至于多做几次取模，生成的汇编就完全没法看了吧。。。<h2 id=keygen>keygen？</h2><p>实力有限，尽管亲手写下的C++代码真的很简单，但编译后的结果成了无法承受之重...<p>上面分析的内容，其实仔细对着RFC推敲（首先，你得知道是照着RFC写的，不然就多读几遍汇编...），才能很勉强得到个粗糙的算法，至于能不能写出 keygen，我没啥信心。<h2 id=jie-lun>结论</h2><p>很难。<p>如果说前面的 C 代码是小游戏的话，那 cm03 就是地球online。开启优化的C++无间地狱。<p>完全溃败。</article><p class=tags-data><a href=/tags/hui-bian>/汇编/</a> <a href=/tags/ni-xiang>/逆向/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>