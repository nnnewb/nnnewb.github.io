<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>自娱自乐 CrackMe-1</title><meta content="自娱自乐 CrackMe-1" name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2021/crackme-01/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content="自娱自乐 CrackMe-1" property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2021/crackme-01/ property=twitter:url><meta content="自娱自乐 CrackMe-1" property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2021/crackme-01/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>自娱自乐 CrackMe-1</h1><p class=author-line>作于：2021-09-10 09:49 ，预计阅读时间 9 分钟<article><h2 id=qian-yan>前言</h2><p>总之得有个前言。从前有个老和尚（不是，掉光了头发的攻城狮），......<p>以上略，于是作为萌新含量110%的萌新，出于练手、熟悉下反汇编调试的环境之类的目的，还是自己写crackme来把玩吧。<h2 id=cm01-jie-shao>CM01 介绍</h2><p>于是这个 CrackMe 就叫 CM01 好了，命令行无界面。适合差不多对这些东西懂个大概或者打算学习的萌新：<ul><li>反汇编/调试工具<li>寄存器（主要是 ebp、esp、eip、eax）<li>函数调用（cdecl）<li>栈/栈帧<li>内存模型和寻址</ul><h2 id=cm01-yuan-ma>CM01 源码</h2><pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>&lt;stdio.h>
</span><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>&lt;stdlib.h>
</span><span style=color:#fa5c4b>#include </span><span style=color:#b8bb26>&lt;string.h>
</span><span>
</span><span style=color:#fabd2f>size_t </span><span style=color:#8ec07c>getline</span><span>(</span><span style=color:#fa5c4b>char </span><span style=color:#fe8019>**</span><span style=color:#fdf4c1>lineptr</span><span>, </span><span style=color:#fabd2f>size_t </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>n</span><span>, FILE </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>stream</span><span>) {
</span><span>  </span><span style=color:#fa5c4b>char </span><span style=color:#fe8019>*</span><span>bufptr </span><span style=color:#fe8019>= </span><span style=color:#d3869b>NULL</span><span>;
</span><span>  </span><span style=color:#fa5c4b>char </span><span style=color:#fe8019>*</span><span>p </span><span style=color:#fe8019>=</span><span> bufptr;
</span><span>  </span><span style=color:#fabd2f>size_t</span><span> size;
</span><span>  </span><span style=color:#fa5c4b>int</span><span> c;
</span><span>
</span><span>  </span><span style=color:#fa5c4b>if </span><span>(lineptr </span><span style=color:#fe8019>== </span><span style=color:#d3869b>NULL</span><span>) {
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>;
</span><span>  }
</span><span>  </span><span style=color:#fa5c4b>if </span><span>(stream </span><span style=color:#fe8019>== </span><span style=color:#d3869b>NULL</span><span>) {
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>;
</span><span>  }
</span><span>  </span><span style=color:#fa5c4b>if </span><span>(n </span><span style=color:#fe8019>== </span><span style=color:#d3869b>NULL</span><span>) {
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>;
</span><span>  }
</span><span>  bufptr </span><span style=color:#fe8019>= *</span><span>lineptr;
</span><span>  size </span><span style=color:#fe8019>= *</span><span>n;
</span><span>
</span><span>  c </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>fgetc</span><span style=color:#fdf4c1>(stream)</span><span>;
</span><span>  </span><span style=color:#fa5c4b>if </span><span>(c </span><span style=color:#fe8019>==</span><span> EOF) {
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>;
</span><span>  }
</span><span>  </span><span style=color:#fa5c4b>if </span><span>(bufptr </span><span style=color:#fe8019>== </span><span style=color:#d3869b>NULL</span><span>) {
</span><span>    bufptr </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>malloc</span><span style=color:#fdf4c1>(</span><span style=color:#d3869b>128</span><span style=color:#fdf4c1>)</span><span>;
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(bufptr </span><span style=color:#fe8019>== </span><span style=color:#d3869b>NULL</span><span>) {
</span><span>      </span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>;
</span><span>    }
</span><span>    size </span><span style=color:#fe8019>= </span><span style=color:#d3869b>128</span><span>;
</span><span>  }
</span><span>  p </span><span style=color:#fe8019>=</span><span> bufptr;
</span><span>  </span><span style=color:#fa5c4b>while </span><span>(c </span><span style=color:#fe8019>!=</span><span> EOF) {
</span><span>    </span><span style=color:#fa5c4b>if </span><span>((p </span><span style=color:#fe8019>-</span><span> bufptr) </span><span style=color:#fe8019>> </span><span>(size </span><span style=color:#fe8019>- </span><span style=color:#d3869b>1</span><span>)) {
</span><span>      size </span><span style=color:#fe8019>=</span><span> size </span><span style=color:#fe8019>+ </span><span style=color:#d3869b>128</span><span>;
</span><span>      bufptr </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>realloc</span><span style=color:#fdf4c1>(bufptr, size)</span><span>;
</span><span>      </span><span style=color:#fa5c4b>if </span><span>(bufptr </span><span style=color:#fe8019>== </span><span style=color:#d3869b>NULL</span><span>) {
</span><span>        </span><span style=color:#fa5c4b>return </span><span style=color:#fe8019>-</span><span style=color:#d3869b>1</span><span>;
</span><span>      }
</span><span>    }
</span><span>    </span><span style=color:#fe8019>*</span><span>p</span><span style=color:#fe8019>++ =</span><span> c;
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(c </span><span style=color:#fe8019>== </span><span style=color:#b8bb26>'\n'</span><span>) {
</span><span>      </span><span style=color:#fa5c4b>break</span><span>;
</span><span>    }
</span><span>    c </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>fgetc</span><span style=color:#fdf4c1>(stream)</span><span>;
</span><span>  }
</span><span>
</span><span>  </span><span style=color:#fe8019>*</span><span>p</span><span style=color:#fe8019>++ = </span><span style=color:#b8bb26>'\0'</span><span>;
</span><span>  </span><span style=color:#fe8019>*</span><span>lineptr </span><span style=color:#fe8019>=</span><span> bufptr;
</span><span>  </span><span style=color:#fe8019>*</span><span>n </span><span style=color:#fe8019>=</span><span> size;
</span><span>
</span><span>  </span><span style=color:#fa5c4b>return</span><span> p </span><span style=color:#fe8019>-</span><span> bufptr </span><span style=color:#fe8019>- </span><span style=color:#d3869b>1</span><span>;
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>int </span><span style=color:#8ec07c>main</span><span>() {
</span><span>  </span><span style=color:#fa5c4b>const char </span><span style=color:#fe8019>*</span><span>pwd </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>"secret"</span><span>;
</span><span>  </span><span style=color:#fa5c4b>char </span><span style=color:#fe8019>*</span><span>line </span><span style=color:#fe8019>= </span><span style=color:#d3869b>NULL</span><span>;
</span><span>  </span><span style=color:#fabd2f>size_t</span><span> len </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>;
</span><span>  </span><span style=color:#fa5c4b>long int</span><span> linesize </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>;
</span><span>
</span><span>  </span><span style=color:#fa5c4b>while </span><span>(</span><span style=color:#d3869b>1</span><span>) {
</span><span>    </span><span style=color:#fabd2f>printf</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"password:"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>    linesize </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>getline(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>line, </span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>len, stdin)</span><span>;
</span><span>    </span><span style=color:#fa5c4b>int</span><span> rc </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>strncmp</span><span style=color:#fdf4c1>(line, pwd, </span><span style=color:#d3869b>6</span><span style=color:#fdf4c1>)</span><span>;
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(rc </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0</span><span>) {
</span><span>      </span><span style=color:#fabd2f>printf</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"Good job!\n"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>      </span><span style=color:#fa5c4b>break</span><span>;
</span><span>    } </span><span style=color:#fa5c4b>else </span><span>{
</span><span>      </span><span style=color:#fabd2f>printf</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"wrong pwd!\n"</span><span style=color:#fdf4c1>)</span><span>;
</span><span>    }
</span><span>  }
</span><span>  </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>0</span><span>;
</span><span>}
</span></code></pre><p>编译工具链：<ul><li>因为VC++对单纯C的支持比较垃圾，所以用LLVM（Clang）-12.0.1，Clang</ul><p>编译指令<pre class=language-bash data-lang=bash style=color:#fdf4c1aa;background-color:#282828><code class=language-bash data-lang=bash><span style=color:#fdf4c1>clang cm01.c -o cm01-easy.exe -m32 -O0
</span><span style=color:#fdf4c1>clang cm01.c -o cm01-normal.exe -m32 -O1
</span><span style=color:#fdf4c1>clang cm01.c -o cm01-hard.exe -m32 -O2
</span></code></pre><h2 id=guan-cha>观察</h2><p>假装没看到源码，先观察下程序的行为，确定目标。<pre style=color:#fdf4c1aa;background-color:#282828><code><span>weakptr in assembly-play ❯ .\cm01-easy.exe
</span><span>password:password?
</span><span>wrong pwd!
</span><span>password:asdf
</span><span>wrong pwd!
</span><span>password:wrong pwd!
</span><span>password:
</span></code></pre><p>一个 <em>password:</em> 提示符，随便输入了点什么会提示 <em>wrong pwd!</em> 。<p>确定目标是找出正确的密码。<h2 id=jing-tai-fen-xi>静态分析</h2><h3 id=si-lu>思路</h3><p>在逆向中有个说法叫*“关键跳转”*，如分析固定密码，字符串比较后跳转成功或跳转失败就是关键跳。对于简单的问题，找到关键跳即可破局。<h3 id=fan-hui-bian-easy>反汇编 - Easy</h3><p>Easy难度下，<code>-O0</code>参数关闭了编译器优化，生成的汇编代码非常死板，基本能直接对照到C源码上。<p>直接拿IDA打开。<p><img alt=image-20210912172521751 src=https://nnnewb.github.io/posts/2021/crackme-01/image/crackme-01/cm01-easy-1.webp><p>直接跳到了<code>main</code>函数。接着看IDA汇编窗口中的的细节。<p><img alt=image-20210912173539972 src=https://nnnewb.github.io/posts/2021/crackme-01/image/crackme-01/cm01-easy-2.webp><p>IDA反汇编界面是包含一些伪代码的，有助于分析。<p>左侧有长条和箭头的部分是控制流示意，箭头指的就是跳转方向。<p>越过伪代码的部分，就能看到函数体开头例行公事的部分了。随后的便是函数体代码。<p>具体看函数体前，先了解下IDA还提供了另一种控制流可视化的视图，可以极大帮助对函数逻辑的分析。<p>在汇编视图里右键，选择 Graph View，即可进入控制流视图。<p><img alt=image-20210912174233891 src=https://nnnewb.github.io/posts/2021/crackme-01/image/crackme-01/cm01-easy-3.webp><p>在图片左下角的是视图的全览，原本的汇编文本变成了图中箭头连接的小汇编代码块，箭头指示了跳转的方向。<p>在这个视图可以很清楚地看到所谓的关键跳：<p><img alt=image-20210912174738919 src=https://nnnewb.github.io/posts/2021/crackme-01/image/crackme-01/cm01-easy-4.webp><p><code>_strncmp</code>是经过了 name mangling 的 c 标准库函数<code>strncmp</code>，函数如名字所示，用途就是比较字符串。<p>又根据<code>cdecl</code>调用约定，函数参数通过栈传递，参数从右往左压栈。我们看这个<code>call</code>指令前的三句<code>mov</code>。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>[esp+</span><span style=color:#d3869b>24h</span><span style=color:#fdf4c1>+</span><span style=color:#8ec07c>Ix</span><span style=color:#fdf4c1>], ecx</span><span style=color:#928374;font-style:italic> ; Str1
</span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>[esp+</span><span style=color:#d3869b>24h</span><span style=color:#fdf4c1>+</span><span style=color:#8ec07c>Str2</span><span style=color:#fdf4c1>], eax</span><span style=color:#928374;font-style:italic> ; Str2
</span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>[esp+</span><span style=color:#d3869b>24h</span><span style=color:#fdf4c1>+</span><span style=color:#8ec07c>MaxCount</span><span style=color:#fdf4c1>], </span><span style=color:#d3869b>6</span><span style=color:#928374;font-style:italic> ; MaxCount
</span></code></pre><p>需要注意的是没有用<code>push</code>指令，所以三个<code>mov</code>在栈上的顺序要根据偏移算。我们偷个懒直接看<code>strncmp</code>函数的签名就行，IDA也分析出了压栈的地址在注释里。往上看，看看<code>ecx</code>和<code>eax</code>又是哪儿来的。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, [ebp+</span><span style=color:#8ec07c>var_8</span><span style=color:#fdf4c1>]
</span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>ecx, [ebp+</span><span style=color:#8ec07c>Str1</span><span style=color:#fdf4c1>]
</span></code></pre><p>再看<code>ebp+var_8</code>和<code>ebp+str1</code>又是什么。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#fa5c4b>lea     </span><span style=color:#fdf4c1>eax, </span><span style=color:#8ec07c>aSecret</span><span style=color:#928374;font-style:italic>    ; "secret"
</span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>[ebp+</span><span style=color:#8ec07c>var_8</span><span style=color:#fdf4c1>], eax
</span></code></pre><p>所以有一个参数是字符串 <code>"secret"</code>，作为关键跳前 <code>_strncmp</code> 的参数。<p>让我们尝试一下。<p><img alt=image-20210912181959230 src=https://nnnewb.github.io/posts/2021/crackme-01/image/crackme-01/cm01-easy-7.webp><p>成功完成。<h3 id=fan-hui-bian-normal>反汇编 - Normal</h3><p>接下来看使用<code>-O1</code>编译，开启了部分编译器优化的版本。<p><img alt=image-20210912183427553 src=https://nnnewb.github.io/posts/2021/crackme-01/image/crackme-01/cm01-normal-1.webp><p>可以看到，因为编译器优化的缘故，原本清晰的分支变成了一个仅有一个循环。<p>还是先找到关键跳，肉眼过一遍循环中的函数调用，<code>sub_401180</code>从参数看应该是一个往终端打印字符串的函数，忽略。<code>___acrt_iob_func</code>意义不明也忽略。下一个<code>sub_401000</code>依然有点意义不明，先跳过。再往下就看到了老熟人了，<code>_strncmp</code>，<code>"secret"</code>参数更是直接用一个push给压栈了，分析到此结束？<p>不过还有一个问题没解决：失败的提示我们看到了，成功的跳转在哪儿呢？<p>从<code>call _strncmp</code>开始往下看。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#fa5c4b>call    </span><span style=color:#8ec07c>_strncmp</span><span style=color:#928374;font-style:italic> ; 调用，cdecl约定下，返回值在 eax
</span><span style=color:#fa5c4b>add     </span><span style=color:#fdf4c1>esp, </span><span style=color:#d3869b>0Ch</span><span style=color:#928374;font-style:italic> ; 清栈
</span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>esi, eax</span><span style=color:#928374;font-style:italic> ; 函数返回值存入 esi
</span><span style=color:#fa5c4b>test    </span><span style=color:#fdf4c1>eax, eax</span><span style=color:#928374;font-style:italic> ; TEST 指令把操作数按位与并设置标志位，如果 eax 是 0 则 ZF 会设置成 1，否则就是 0。
</span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>eax, </span><span style=color:#8ec07c>offset aWrongPwd</span><span style=color:#928374;font-style:italic> ; eax = "wrong pwd!\n"
</span><span style=color:#928374;font-style:italic>; ebp 被设置为了字符串 "Good job!\n"
</span><span style=color:#928374;font-style:italic>; cmovz 或者说 cmov* 系列的函数用后缀的单个字符表示用哪个标志位来决定是否mov，比如cmovz就是用ZF标志位决定是否执行mov。
</span><span style=color:#fa5c4b>cmovz   </span><span style=color:#fdf4c1>eax, ebp 
</span><span style=color:#fa5c4b>push    </span><span style=color:#fdf4c1>eax</span><span style=color:#928374;font-style:italic> ; 如果 strncmp 返回 0 则是 Good job!\n ，反则 wrong pwd!\n
</span><span style=color:#fa5c4b>call    </span><span style=color:#8ec07c>sub_401180</span><span style=color:#928374;font-style:italic> ; 调用一个输出字符串的函数
</span></code></pre><p>用伪代码来表示，就是<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"Good job!\n" </span><span style=color:#fa5c4b>if </span><span style=color:#fdf4c1>compare_result </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0 </span><span style=color:#fa5c4b>else </span><span style=color:#b8bb26>"wrong pwd!\n"</span><span style=color:#fdf4c1>)
</span></code></pre><h3 id=fan-hui-bian-hard>反汇编 - Hard</h3><p>Hard启用了<code>-O2</code>，也就是开启了大部分编译器优化。用IDA打开。<p><img alt=image-20210912185949657 src=https://nnnewb.github.io/posts/2021/crackme-01/image/crackme-01/cm01-hard-1.webp><p>因为编译器十分聪明地把一些函数给内联编译进了 main 函数，现在 main 函数的控制流已经乱的一批。挨个读下去虽然还可行，但实在费神费力。<p>不过在这个条件下依然还有解决办法：我们可以通过错误或成功的提示字符串找关键跳。<p>已知错误时会输出"wrong pwd!"，我们在IDA找到字符串视图。<p><img alt=image-20210912190657661 src=https://nnnewb.github.io/posts/2021/crackme-01/image/crackme-01/cm01-hard-2.webp><p>然后在视图中找到字符串。<p><img alt=image-20210912190827657 src=https://nnnewb.github.io/posts/2021/crackme-01/image/crackme-01/cm01-hard-3.webp><p>其实就是在内存数据段（Data Segment）或者PE的数据节（Data Section）中的字符串啦，一般手写的字符串字面量都会直接编译到这里。<p>在我们要找的字符串上双击，就会跳到汇编视图中的字符串位置。<p><img alt=image-20210912191125747 src=https://nnnewb.github.io/posts/2021/crackme-01/image/crackme-01/cm01-hard-4.webp><p>然后再双击图中位置。<p><img alt=image-20210912191344967 src=https://nnnewb.github.io/posts/2021/crackme-01/image/crackme-01/cm01-hard-5.webp><p>即可跳转到引用。<p><img alt=image-20210912191435672 src=https://nnnewb.github.io/posts/2021/crackme-01/image/crackme-01/cm01-hard-6.webp><p>接着看跳转到的上下文，又变成了十分熟悉的正确错误分支。往前找到 <code>_strncmp</code>的参数。<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#fa5c4b>push    </span><span style=color:#d3869b>6
</span><span style=color:#fa5c4b>push    </span><span style=color:#8ec07c>offset Str2</span><span style=color:#928374;font-style:italic>     ; "secret"
</span><span style=color:#fa5c4b>push    </span><span style=color:#fdf4c1>edx</span><span style=color:#928374;font-style:italic>             ; Str1
</span><span style=color:#fa5c4b>mov     </span><span style=color:#fdf4c1>ebp, edx
</span><span style=color:#fa5c4b>call    </span><span style=color:#8ec07c>_strncmp
</span></code></pre><p>也就是 <code>strncmp(edx,"secret",6)</code>，密钥就是 <code>"secret"</code>没错了。<h2 id=zong-jie>总结</h2><p>这个 CrackMe （以后也许还有）的主要用途是学习逆向和汇编的基础知识，巩固记忆，学习和熟悉工具。所以尽可能去除干扰项，只保留想要巩固学习的部分，看起来很傻，基本没啥挑战性。<p>有些公共的前置知识（比如寄存器和栈，调用约定，内存模型）我做了个笔记，大概是入不了大佬的眼的。可以在[这里](<a href=https://nnnewb.github.io/blog/p/assembly-learning-note/>32位 Windows x86 汇编语言学习 (nnnewb.github.io)</a>)看看。<p>目前能找到很多 Delphi 和 VB 编写的 CrackMe，Delphi 现在搜搜还能看到些 <em>Delphi still alive</em> 的文章，不过确实比较少见了吧。提到学 GUI 编程，不是推荐 C++/Qt 就是 .Net 全家桶。VB 更是早已完蛋（不是VB.Net），老实说这些 CrackMe 不知道转了几手，还能玩是还能玩，虽然但是吧，总之对我还是略难，看别人的 CrackMe 题解也挺迷茫。<p>不过自己会编程就好了嘛！</article><p class=tags-data><a href=/tags/hui-bian>/汇编/</a> <a href=/tags/ni-xiang>/逆向/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>