<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>加壳原理04 - zlib压缩壳案例</title><meta content="加壳原理04 - zlib压缩壳案例" name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2021/learning-packer-04/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content="加壳原理04 - zlib压缩壳案例" property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2021/learning-packer-04/ property=twitter:url><meta content="加壳原理04 - zlib压缩壳案例" property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2021/learning-packer-04/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>加壳原理04 - zlib压缩壳案例</h1><p class=author-line>作于：2021-10-20 16:07 ，预计阅读时间 5 分钟<article><h2 id=qian-yan>前言</h2><p>本文在前一篇基础上，写一个使用 zlib 的压缩壳案例。<h2 id=0x01-zlib-jie-ya>0x01 zlib 解压</h2><h3 id=1-1-gai-shu>1.1 概述</h3><p>关于 zlib 的用法找了这些参考资料：<ul><li><a href=https://zlib.net/zpipe.c>zlib.net/zpipe.c</a><li><a href=https://zlib.net/zlib_how.html>zlib Usage Example</a><li><a href=https://gist.github.com/arq5x/5315739>Compress and Decompress a string with zlib</a></ul><p>尝试了 zlib、lzo、Windows Compression API，对压缩和解压 API 的基本模式的基本认识大概是这样：<ul><li>首先，你得有被压缩数据的大小（要么分块压缩，要么有整个压缩后的大小）<li>然后得有解压后的预期大小，这个能通过 <em>尝试解压</em> 的操作来实现。比如 Windows Compression API 和 lzo 都可以在解压 buffer 传 NULL，尝试取得解压后的大小，再分配好内存解压。<li>zlib 这样的流式压缩、解压处理文件比较友好，但全程在内存里进行的话，流式解压就会导致大量内存分配 =。= 除非一开始就分配足够的空间，不然一个一个内存块申请和合并会很蛋疼。</ul><h3 id=1-2-nei-cun-bu-ju>1.2 内存布局</h3><p>压缩后的 <code>.packed</code> 节在头部留出 8 个字节，分别保存压缩后大小和压缩前大小，以便一次分配好内存完成解压。<table><thead><tr><th>偏移<th>大小<th>内容<tbody><tr><td>0<td>DWORD<td>小端序，压缩后大小<tr><td>4<td>DWORD<td>小端序，压缩前大小<tr><td>8<td>可变<td>压缩后的数据</table><h3 id=1-3-jie-ya-dai-ma>1.3 解压代码</h3><p>解压过程在加载 PE 之前，找到 <code>.packed</code> 节后，开始读取头部大小，并调用解压代码。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>if </span><span>(packed </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>NULL</span><span>) {
</span><span>    </span><span style=color:#fabd2f>DWORD</span><span> compressed_size </span><span style=color:#fe8019>= *</span><span>((</span><span style=color:#fabd2f>DWORD </span><span style=color:#fe8019>*</span><span>)packed);         </span><span style=color:#928374;font-style:italic>// compressed size little-endian
</span><span>    </span><span style=color:#fabd2f>DWORD</span><span> decompressed_size </span><span style=color:#fe8019>= *</span><span>((</span><span style=color:#fabd2f>DWORD </span><span style=color:#fe8019>*</span><span>)(packed </span><span style=color:#fe8019>+ </span><span style=color:#d3869b>4</span><span>)); </span><span style=color:#928374;font-style:italic>// decompressed size little-endian
</span><span>    </span><span style=color:#fa5c4b>void </span><span style=color:#fe8019>*</span><span>compressed </span><span style=color:#fe8019>= </span><span>(</span><span style=color:#fa5c4b>void </span><span style=color:#fe8019>*</span><span>)(packed </span><span style=color:#fe8019>+ </span><span style=color:#d3869b>8</span><span>);            </span><span style=color:#928374;font-style:italic>// compressed buffer
</span><span>    </span><span style=color:#fa5c4b>void </span><span style=color:#fe8019>*</span><span>decompressed </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>malloc</span><span style=color:#fdf4c1>(decompressed_size)</span><span>;     </span><span style=color:#928374;font-style:italic>// decompressed buffer
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(decompressed </span><span style=color:#fe8019>== </span><span style=color:#d3869b>NULL</span><span>) {
</span><span>        </span><span style=color:#fdf4c1>MessageBoxA(</span><span style=color:#d3869b>NULL</span><span style=color:#fdf4c1>, </span><span style=color:#b8bb26>"memory allocate failed"</span><span style=color:#fdf4c1>, </span><span style=color:#b8bb26>"malloc"</span><span style=color:#fdf4c1>, MB_OK)</span><span>;
</span><span>        </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>0</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fdf4c1>decompress(compressed, compressed_size, decompressed, decompressed_size)</span><span>;
</span><span>
</span><span>    </span><span style=color:#fa5c4b>void </span><span>(</span><span style=color:#fe8019>*</span><span>entrypoint)(</span><span style=color:#fa5c4b>void</span><span>) </span><span style=color:#fe8019>= </span><span>(</span><span style=color:#fa5c4b>void </span><span>(</span><span style=color:#fe8019>*</span><span>)(</span><span style=color:#fa5c4b>void</span><span>))</span><span style=color:#fdf4c1>load_PE(decompressed)</span><span>;
</span><span>    </span><span style=color:#fdf4c1>entrypoint()</span><span>;
</span><span>
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#d3869b>0</span><span>;
</span><span>}
</span></code></pre><p>应该没有太多疑问。接下来的是解压代码。<pre class=language-c data-lang=c style=color:#fdf4c1aa;background-color:#282828><code class=language-c data-lang=c><span style=color:#fa5c4b>void </span><span style=color:#8ec07c>decompress</span><span>(</span><span style=color:#fa5c4b>void </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>compressed</span><span>, </span><span style=color:#fabd2f>size_t </span><span style=color:#fdf4c1>length</span><span>, </span><span style=color:#fa5c4b>void </span><span style=color:#fe8019>*</span><span style=color:#fdf4c1>decompressed</span><span>, </span><span style=color:#fabd2f>size_t </span><span style=color:#fdf4c1>decompressed_length</span><span>) {
</span><span>  z_stream inflate_stream;
</span><span>  inflate_stream.</span><span style=color:#fdf4c1>zalloc </span><span style=color:#fe8019>=</span><span> Z_NULL;
</span><span>  inflate_stream.</span><span style=color:#fdf4c1>zfree </span><span style=color:#fe8019>=</span><span> Z_NULL;
</span><span>  inflate_stream.</span><span style=color:#fdf4c1>opaque </span><span style=color:#fe8019>=</span><span> Z_NULL;
</span><span>  inflate_stream.</span><span style=color:#fdf4c1>avail_in </span><span style=color:#fe8019>= </span><span>(uInt)length;
</span><span>  inflate_stream.</span><span style=color:#fdf4c1>next_in </span><span style=color:#fe8019>= </span><span>(Bytef </span><span style=color:#fe8019>*</span><span>)compressed;
</span><span>  inflate_stream.</span><span style=color:#fdf4c1>avail_out </span><span style=color:#fe8019>= </span><span>(uInt)decompressed_length;
</span><span>  inflate_stream.</span><span style=color:#fdf4c1>next_out </span><span style=color:#fe8019>= </span><span>(Bytef </span><span style=color:#fe8019>*</span><span>)decompressed;
</span><span>  </span><span style=color:#fdf4c1>inflateInit(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>inflate_stream)</span><span>;
</span><span>
</span><span>  </span><span style=color:#fa5c4b>int</span><span> err </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>inflate(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>inflate_stream, Z_NO_FLUSH)</span><span>;
</span><span>  </span><span style=color:#fa5c4b>if </span><span>(err </span><span style=color:#fe8019>!=</span><span> Z_STREAM_END) {
</span><span>    </span><span style=color:#fdf4c1>inflateEnd(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>inflate_stream)</span><span>;
</span><span>    </span><span style=color:#fdf4c1>MessageBoxA(</span><span style=color:#d3869b>NULL</span><span style=color:#fdf4c1>, </span><span style=color:#b8bb26>"zlib decompression failed"</span><span style=color:#fdf4c1>, </span><span style=color:#b8bb26>"zlib"</span><span style=color:#fdf4c1>, MB_OK)</span><span>;
</span><span>    </span><span style=color:#fa5c4b>return</span><span>;
</span><span>  }
</span><span>  </span><span style=color:#fdf4c1>inflateEnd(</span><span style=color:#fe8019>&</span><span style=color:#fdf4c1>inflate_stream)</span><span>;
</span><span>  </span><span style=color:#fa5c4b>return</span><span>;
</span><span>}
</span></code></pre><p>定义 inflate 流：<ul><li><code>avail_in</code> 是可用的输入 buffer 大小<li><code>avail_out</code> 是可用的输出 buffer 大小<li><code>next_in</code> 是输入 buffer 的指针<li><code>next_out</code> 是输出 buffer 的指针<li><code>zalloc</code>、<code>zfree</code>、<code>opaque</code> 初始化成 NULL</ul><p>使用 <code>inflateInit()</code> 初始化流，然后调用 <code>inflate()</code> 解压。<code>inflate()</code> 会返回错误码，如果长度正好，会返回 <code>Z_STREAM_END</code>。如果输出 buffer 长度不足，但解压成功，会返回 <code>Z_OK</code>。其他情况会返回错误码。因为这里很清楚给定的压缩前长度，解压必定返回 <code>Z_STREAM_END</code>，其他情况都有问题，所以只做了一个判断。<p>对于其他情况，错误码可以用 <code>zError</code> 获取错误描述。<p>解压结束后要使用 <code>inflateEnd()</code> 关闭流。<h2 id=0x02-zlibya-suo>0x02 zlib压缩</h2><p>因为使用 python 写加壳机，就不用这么麻烦了。<p>在处理 <code>.packed</code> 节的时候，使用 <code>struct</code> 和 <code>zlib</code> 两个 python 自带的库就能完成压缩和填充头。<p>在脚本头部添加两句 <code>import</code><pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fa5c4b>import </span><span>struct
</span><span style=color:#fa5c4b>import </span><span>zlib
</span></code></pre><p>然后修改加壳代码中，添加 <code>.packed</code> 节的代码。<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#928374;font-style:italic># add packed section
</span><span style=color:#fa5c4b>with </span><span style=color:#fabd2f>open</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>'example.exe'</span><span style=color:#fdf4c1>, </span><span style=color:#b8bb26>'rb'</span><span style=color:#fdf4c1>) </span><span style=color:#fa5c4b>as </span><span>f:
</span><span>    file_content </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>f.read()
</span><span>    origin_length </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>len</span><span style=color:#fdf4c1>(file_content)
</span><span>    compressed </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>zlib.compress(file_content, </span><span style=color:#d3869b>9</span><span style=color:#fdf4c1>)
</span><span>    compressed_length </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>len</span><span style=color:#fdf4c1>(compressed)
</span><span>    section_content </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>struct.pack(</span><span style=color:#b8bb26>'&lt;II'</span><span style=color:#fdf4c1>, compressed_length, origin_length)
</span><span>    section_content </span><span style=color:#fe8019>+= </span><span>compressed
</span><span>
</span><span>    packed_section </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>lief.PE.Section(</span><span style=color:#b8bb26>'.packed'</span><span style=color:#fdf4c1>)
</span><span>    packed_section.content </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>list</span><span style=color:#fdf4c1>(section_content)
</span><span>    packed_section.characteristics </span><span style=color:#fe8019>= </span><span>(lief.</span><span style=color:#fdf4c1>PE</span><span>.</span><span style=color:#fdf4c1>SECTION_CHARACTERISTICS</span><span>.</span><span style=color:#fdf4c1>MEM_READ </span><span style=color:#fe8019>|
</span><span>                                      lief.</span><span style=color:#fdf4c1>PE</span><span>.</span><span style=color:#fdf4c1>SECTION_CHARACTERISTICS</span><span>.</span><span style=color:#fdf4c1>CNT_INITIALIZED_DATA</span><span>)
</span><span>    </span><span style=color:#fdf4c1>output.add_section(packed_section)
</span></code></pre><p>可以看到使用 <code>zlib.compress</code> 就完成了压缩，不用原始 zlib 流那么麻烦。<p><code>struct.pack</code> 指定了小端序，两个4字节int，分别填写压缩后大小和原始大小，连接压缩后的数据，填充进<code>.packed</code> 节。<p>就这样，压缩功能成功完成。<h2 id=0x03-cheng-guo-zhan-shi>0x03 成果展示</h2><p><img alt=compression-packer src=https://nnnewb.github.io/posts/2021/learning-packer-04/compression-packer.gif><p><img alt=image-20211020154513713 src=https://nnnewb.github.io/posts/2021/learning-packer-04/image-20211020154513713.webp><p><img alt=image-20211020154539546 src=https://nnnewb.github.io/posts/2021/learning-packer-04/image-20211020154539546.webp><h2 id=zong-jie>总结</h2><p>偷懒了，用了一些 msvcrt 的函数，比如 malloc，要加个 <code>-lmsvcrt</code> 链接选项。最终成品压缩率还可以，从107KB 压缩到了 49KB，zlib 不负期望。<p>写好壳程序之后，不管是加密还是压缩都是很容易的事情（指单纯做个简单实现），但问题依然存在：<ul><li>64位程序——我觉得可以以后再说吧？我连64位汇编都还不会（泪）。<li>脱壳跟玩一样——现在看 .packed 已经没有 MZ 这个摆明了是原始程序的标志了，但并没有卵用。壳程序也没混淆和反调试，节表也是清晰可见，根本不用分析。</ul><p>下一篇还没想好做什么，得先继续学习充实下自己，找个方向。</article><p class=tags-data><a href=/tags/ni-xiang>/逆向/</a> <a href=/tags/hui-bian>/汇编/</a> <a href=/tags/c>/c++/</a> <a href=/tags/python>/python/</a> <a href=/tags/windows>/windows/</a> <a href=/tags/security>/security/</a> <a href=/tags/binary-analysis>/binary-analysis/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>