<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>密码学入门03 - 古典密码#3</title><meta content="密码学入门03 - 古典密码#3" name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2021/cryptography-introduction-03/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content="密码学入门03 - 古典密码#3" property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2021/cryptography-introduction-03/ property=twitter:url><meta content="密码学入门03 - 古典密码#3" property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2021/cryptography-introduction-03/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>密码学入门03 - 古典密码#3</h1><p class=author-line>作于：2021-11-16 11:31 ，预计阅读时间 12 分钟<article><h2 id=qian-yan>前言</h2><p>学习一下 Hill 密码。<h2 id=0x01-shu-xue-ji-chu>0x01 数学基础</h2><p>参考了 <a href=https://www.shuxuele.com/algebra/matrix-introduction.html>数学乐</a> 。没有详细介绍矩阵的意义，但基本运算规则之类的讲得很清楚好懂。<h3 id=1-1-ju-zhen>1.1 矩阵</h3><p>一个矩阵就是n行m列的数字表格，含义暂不考虑，只学习下矩阵的表示方法、运算规则，不然有点难读懂 Hill 密码的规则。<p>一个有 <em>m</em> 行，<em>n</em> 列的矩阵 <em>A</em> 的书写形式如下。 $$ A=\begin{bmatrix} a_{11} & a_{12} & \dots & a_{1n} \\ a_{21} & a_{22} & \dots & a_{2n} \\ \vdots & \vdots & & \vdots \\ a_{m1} & a_{m2} & \dots & a_{mn} \end{bmatrix} $$<h3 id=1-2-ju-zhen-jia-fa-jian-fa>1.2 矩阵加法/减法</h3><p>矩阵加减法规则如下。设有矩阵 <em>A</em>、<em>B</em> 如下。 $$ A=\begin{bmatrix} a_{11} & a_{12} & \dots & a_{1n} \\ a_{21} & a_{22} & \dots & a_{2n} \\ \vdots & \vdots & & \vdots \\ a_{m1} & a_{m2} & \dots & a_{mn} \end{bmatrix},B=\begin{bmatrix} b_{11} & b_{12} & \dots & b_{1n} \\ b_{21} & b_{22} & \dots & b_{2n} \\ \vdots & \vdots & & \vdots \\ b_{m1} & b_{m2} & \dots & b_{mn} \end{bmatrix} $$ 则计算 A±B 的规则如下。 $$ A±B=\begin{bmatrix} a_{11}±b_{11} & a_{12}±b_{12} & \dots & a_{1n}±b_{1n} \\ a_{21}±b_{21} & a_{22}±b_{22} & \dots & a_{2n}±b_{2n} \\ \vdots & \vdots & & \vdots \\ a_{m1}±b_{m1} & a_{m2}±b_{m2} & \dots & a_{mn}±b_{mn} \end{bmatrix} $$ 性质：<ul><li><strong>只有行列数相同的矩阵，加减法才有意义</strong><li><strong>矩阵的加减法，就是矩阵中相同位置元素加减</strong><li>矩阵加减法满足 <strong>交换律</strong>（<code>A+B=B+A</code>） 和 <strong>结合律</strong> （<code>A+(B+C)=(A+B)+c</code>）</ul><h3 id=1-2-ju-zhen-shu-cheng>1.2 矩阵数乘</h3><p>数λ乘矩阵 <em>A</em>，即使将数λ乘矩阵A中的每一个元素，记为 <em>λA</em> 或 <em>Aλ</em>。<p>特别的，称 <em>-A</em> 为 <em>A</em> 的负矩阵。<p>性质：<ul><li>满足 <strong>结合律</strong> （<code>(λμ)A=λ(μA); (λ+μ)A=λA+μA</code>） 和 <strong>分配律</strong> （<code>λ(A+B)=λA+λB</code>）</ul><h3 id=1-3-ju-zhen-cheng-fa>1.3 矩阵乘法</h3><p>先看矩阵的另一种表示形式：<em>A=(a<sub>ij</sub>)<sub>mxs</sub></em> ，这种表示形式中，<em>m</em> 表示行数，<em>s</em> 表示列数，<em>a<sub>ij</sub></em> 姑且当占位，表示矩阵元素。<p>设 <em>A=(a<sub>ij</sub>)<sub>mxs</sub></em> <em>B=(b<sub>ij</sub>)<sub>sxn</sub></em> ，则 <em>A=AB</em> 是这样一个矩阵：<ol><li>行数和左矩阵 <em>A</em> 相同，列数和右矩阵 <em>B</em> 相同，即 <em>C=(c<sub>ij</sub>)<sub>mxn</sub></em> 。<li><em>C</em> 的第 <em>i</em> 行第 <em>j</em> 列的元素 <em>c<sub>ij</sub></em> 由 <em>A</em> 的第 <em>i</em> 行元素和 <em>B</em> 的第 <em>j</em> 列元素对应相乘，再取乘积之和。</ol><p>举例来说，将这两个矩阵相乘。<p>$$ A=\begin{bmatrix} 1 & 2 \\ 1 & -1 \end{bmatrix},B= \begin{bmatrix} 1 & 2 & -3 \\ -1 & 1 & 2 \end{bmatrix} $$ 结果是一个 2x3 的矩阵，每个元素计算如下： $$ AB=\begin{bmatrix} (1×1+2×-1) & (1×2+2×1) & (1×-3+2×2) \\ (1×1+-1×-1) & (1×2+-1×1) & (1×-3+-1×2) \end{bmatrix}= \begin{bmatrix} -1 & 4 & 1 \\ 2 & 1 & -5 \end{bmatrix} $$ 先用 <em>A</em> 的第1行，分别乘 <em>B</em> 的第1、2、3列，作为结果矩阵 <em>C</em> 的第1行。然后用 <em>A</em> 的第2行，分别乘 <em>B</em> 的第1、2、3列，作为结果矩阵 <em>C</em> 的第二行。<p>注意：相乘的矩阵应该满足条件，左侧矩阵列数等于右侧矩阵行数，计算才能进行。<p>性质（假设运算都是可行的）：<ol><li>符合结合律 <em>(AB)C=A(BC)</em><li>符合分配律 <em>A(B±C)=AB±AC</em> （左分配律）; <em>(B±C)A=BA±CA</em> （右分配律）<li><em>(λA)B=λ(AB)=A(λB)</em></ol><h3 id=1-4-ju-zhen-zhuan-zhi>1.4 矩阵转置</h3><p>将 <em>A</em> 矩阵的行换成同序号的列所得到的新矩阵称为 <em>A</em> 的转置矩阵，记作 <em>A'</em> 或者 <em>A<sup>T</sup></em> 。 $$ A= \begin{bmatrix} 1 & 0 & 3 & -1 \\ 2 & 1 & 0 & 2 \end{bmatrix},A'=A^T= \begin{bmatrix} 1 & 2 \\ 0 & 1 \\ 3 & 0 \\ -1 & 2 \end{bmatrix} $$ 性质：<ol><li><em>(A')'=A</em><li><em>(A+B)'=A'+B'</em><li><em>(AB)'=B'A'</em><li><em>(λA)'=λA'</em>，λ是常数</ol><h3 id=1-5-dui-cheng-ju-zhen>1.5 对称矩阵</h3><p>如果矩阵 <em>A</em> 满足 <em>A'=A</em> ，即 <em>a<sub>ij</sub>=a<sub>ji</sub></em> ，则称 <em>A</em> 为 <strong>对称矩阵</strong>。<p>对称矩阵的特点是它的元素以主对角线为对称轴对应相等。<p>举例如下。 $$ A=\begin{bmatrix} 1 & 2 & 3 \\ 2 & 1 & 2 \\ 3 & 2 & 1 \end{bmatrix} $$<p>尝试将这个矩阵转置，令 <em>a<sub>ij</sub>=a<sub>ji</sub></em> ，得到下面的矩阵，发现的确和原矩阵相同。 $$ A'=\begin{bmatrix} a_{11} & a_{21} & a_{31} \\ a_{12} & a_{22} & a_{32} \\ a_{13} & a_{23} & a_{33} \end{bmatrix}= \begin{bmatrix} 1 & 2 & 3 \\ 2 & 1 & 2 \\ 3 & 2 & 1 \end{bmatrix} $$<p>而原矩阵关于主对角线对称。<h3 id=1-6-dan-wei-ju-zhen>1.6 单位矩阵</h3><p>单位矩阵是除了主对角线上是1，其他数字都是0的矩阵。<strong>任何矩阵和单位矩阵相乘都等于自身</strong>。<p>比如下面这个 3x3 矩阵。 $$ I=\begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix} $$<h3 id=1-7-ni-ju-zhen>1.7 逆矩阵</h3><p>如果有矩阵 <em>B</em> ，令 <em>BA=AB=I</em>，其中 <em>I</em> 为单位矩阵，则称 <em>B</em> 为 <em>A</em> 的逆矩阵，记为 <em>A<sup>-1</sup></em> 。对任意矩阵 <em>A</em> ，逆矩阵并不一定存在。<p>逆矩阵的作用是一定程度上代替了矩阵除法运算（矩阵不能做除法），例如已知矩阵A、B，求矩阵X，有下面的式子。<p><em>XA=B</em><p>如果有除法，那可以直接移项 <em>X=B/A</em> ，但矩阵只能相乘，所以我们可以在两边都乘上 A 的逆矩阵 <em>A<sup>-1</sup></em> 。<p><em>XAA<sup>-1</sup>=BA<sup>-1</sup></em><p>因为 <em>AA<sup>-1</sup></em> 得单位矩阵 <em>I</em> ，所以左侧就变成了 <em>XI</em>。又因为任何矩阵和单位矩阵相乘都等于自身，所以 <em>XI</em> 可以简化为 <em>X</em> 。于是就得到了：<p><em>X=BA<sup>-1</sup></em><p>但是要<strong>注意次序</strong>！ <em>AX=B</em> 不能用上述方法做，因为<strong>矩阵乘法不一定满足结合律</strong> （<em>AB=BA</em>），对于 <em>AX=B</em> 的情况，可以将 <em>A<sup>-1</sup></em> 放在式子之前，也就是 <em>A<sup>-1</sup>AX=A<sup>-1</sup>B</em> 。<h3 id=1-8-xing-lie-shi-la-pu-la-si-zhan-kai>1.8 行列式（拉普拉斯展开）</h3><p>矩阵 A 的行列式记为 <em>|A|</em> ，和绝对值符号一样。只有<strong>方形矩阵</strong>才能计算行列式。方形矩阵就是行和列数目相等的矩阵。<p>首先看 2x2 矩阵。 $$ A=\begin{bmatrix} a & b \\ c & d \end{bmatrix},|A|=ad-bc $$ 2x2矩阵的行列式就是简单的交叉相乘再相减。下图中蓝色是正，红色是负。<p><img alt=image-20211112142023403 src=https://nnnewb.github.io/posts/2021/cryptography-introduction-03/image-20211112142023403.webp><p>再看 3x3 矩阵的行列式写法，用矩阵第一行的元素，逐个去乘不在和这个元素同一行同一列元素的行列式，最后把这些值用加减号连起来。 $$ \begin{vmatrix} a & b & c \\ d & e & f \\ g & h & i \end{vmatrix}= a \begin{vmatrix} e & f \\ h & i \end{vmatrix} -b \begin{vmatrix} d & f \\ g & i \end{vmatrix} +c \begin{vmatrix} d & e \\ g & h \end{vmatrix} =a(ei-fh)-b(di-fg)+c(dh-eg) $$ 更直观的图形化表示：<p><img alt=image-20211112142439733 src=https://nnnewb.github.io/posts/2021/cryptography-introduction-03/image-20211112142439733.webp><p>注意这个过程中的加减符号规律，<em>a<sub>11</sub>×(...)</em> 是正，<em>a<sub>12</sub>×(...)</em> 是负，<em>a<sub>13</sub>×(...)</em> 又是正。<p>知晓这些规律后再看更大的矩阵，也可以依葫芦画瓢写出行列式。<p><img alt=image-20211112143050819 src=https://nnnewb.github.io/posts/2021/cryptography-introduction-03/image-20211112143050819.webp><p>留意其中正负号出现的规律，<em>+a<sub>11</sub></em> <em>-a<sub>12</sub></em> <em>+a<sub>13</sub></em> <em>-a<sub>14</sub></em> 。<p>这种计算方法叫做 <strong>拉普拉斯展开</strong> 。<h3 id=1-9-qiu-ni-ju-zhen-de-fang-fa>1.9 求逆矩阵的方法</h3><ul><li>2x2 矩阵的逆矩阵<li>初等行运算<li>余子式、代数余子式和伴随来求逆矩阵</ul><p>2x2 矩阵的逆矩阵是： $$ A^{-1}=\begin{bmatrix} a & b \\ c & d \end{bmatrix}^{-1}= \frac{1}{|A|} \begin{bmatrix} d & -b \\ -c & a \end{bmatrix} $$<ol><li>调换 <em>a<sub>11</sub></em> 和 <em>a<sub>22</sub></em><li><em>a<sub>12</sub></em> 和 <em>a<sub>21</sub></em> 加上负号<li>除以原矩阵的行列式</ol><p>3x3 或更大的矩阵的逆矩阵求法可以用 <a href=https://www.shuxuele.com/algebra/matrix-inverse-row-operations-gauss-jordan.html>初等行运算</a> 或 <a href=https://www.shuxuele.com/algebra/matrix-inverse-minors-cofactors-adjugate.html>用余子式、代数余子式和伴随 来求逆矩阵</a> 。<h2 id=0x02-hill-mi-ma>0x02 Hill 密码</h2><h3 id=2-1-jia-mi-guo-cheng>2.1 加密过程</h3><p>首先给定一个密码矩阵 <em>A</em>。 $$ A=\begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix} $$<p>再给出明文：<em>The quick brown fox jumps over the lazy dog</em><p>将明文转换成数字（ASCII），两个一组。比如 <code>Th</code> 就是 <code>84 104</code> ，写成矩阵形式就是这样。<p>$$ P=\begin{bmatrix} 84 \\ 104 \end{bmatrix} $$<p>将密码矩阵 <em>A</em> 左乘明文矩阵 <em>P</em> ，<em>C=AP</em>，我们就得到了密文。<p>$$ C=AP=\begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix} \begin{bmatrix} 84 \\ 104 \end{bmatrix}= \begin{bmatrix} 292 \\ 668 \end{bmatrix} $$<h3 id=2-2-jie-mi-guo-cheng>2.2 解密过程</h3><p>解密过程就是利用密码矩阵的逆矩阵 <em>A<sup>-1</sup></em> ，从密文求明文的过程，公式 <em>A<sup>-1</sup>C=A<sup>-1</sup>AP</em> 。<p>2x2 矩阵的逆矩阵求解方法看前面 1.9，求得逆矩阵如下。<p>$$ A^{-1}=\begin{bmatrix} -2 & 1 \\ 1.5 & -0.5 \end{bmatrix} $$<p>然后使用逆矩阵左乘密文：<p>$$ P=A^{-1}C=\begin{bmatrix} -2 & 1 \\ 1.5 & -0.5 \end{bmatrix} \begin{bmatrix} 292 \\ 668 \end{bmatrix}= \begin{bmatrix} 84 \\ 104 \end{bmatrix} $$<p>即可得到明文。<h3 id=2-3-an-quan-xing>2.3 安全性</h3><p>Hill密码的安全性体现在隐藏了单个字母的频率信息，加密矩阵越大效果越好。<p>Hill密码无法抵抗已知明文攻击，已知明文和密文时完全可以计算出加密矩阵。<h2 id=zong-jie>总结</h2><p>重点：<ol><li>矩阵乘法、单位矩阵、行列式和逆矩阵</ol><p>Hill密码是将明文转为矩阵后和加密矩阵相乘，加密矩阵即为加密密钥，加密矩阵越大效果越好。解密使用加密矩阵的逆矩阵作为密钥。<p>Hill 密码能隐藏字母频率信息，对抗仅密文分析，但无法对抗已知明文分析。</article><p class=tags-data><a href=/tags/mi-ma-xue-ru-men>/密码学入门/</a> <a href=/tags/mi-ma-xue>/密码学/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>