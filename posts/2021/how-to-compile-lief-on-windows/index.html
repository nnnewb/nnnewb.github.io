<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>编译LIEF的各种姿势</title><meta content=编译LIEF的各种姿势 name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2021/how-to-compile-lief-on-windows/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content=编译LIEF的各种姿势 property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2021/how-to-compile-lief-on-windows/ property=twitter:url><meta content=编译LIEF的各种姿势 property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2021/how-to-compile-lief-on-windows/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>编译LIEF的各种姿势</h1><p class=author-line>作于：2021-10-08 16:25 ，预计阅读时间 5 分钟<article><h2 id=qian-yan>前言</h2><p>惯例得有个前言。<p>LIEF是一个二进制文件分析和操作库，官方推荐的是 Python 版本，确实更好用，就是类型的问题有点多，而且没附送 <code>.pyi</code> 导致不大好写。而C++版本就没这问题，C++版本有自己的问题=，=<p>一个是官方提供下载的SDK是静态链接的，用到SDK的程序必须指定 <code>/MT</code> 不然编译器就会抱怨运行库不匹配。虽然看issue里已经有人解决了（<code>-DLIEF_USE_CRT_{DEBUG,RELEASE}=MD/MT</code>），但CI还是老样子，反正直接下载的SDK用起来就蛋疼，vcpkg 全都是 <code>/MD</code> 链接的，没法配合用。<p>更别提 MinGW 了，就没官方的SDK。<p>以上就是问题，解决问题的最简单办法就是自己编译了。<h2 id=0x01-visual-c-gong-ju-lian-msbuild>0x01 Visual C++ 工具链 msbuild</h2><p>代码下载下来之后，用 CMake 去编译。下面的命令都是 Powershell 下的，注意折行用的是反引号 backquote，就是波浪号那个键，和 bash 用 反斜杠不一样。直接复制到命令行是跑不起来的。<pre class=language-powershell data-lang=powershell style=color:#fdf4c1aa;background-color:#282828><code class=language-powershell data-lang=powershell><span>cmake .</span><span style=color:#fe8019>. 
</span><span>	</span><span style=color:#fe8019>-</span><span>G </span><span style=color:#b8bb26>"Visual Studio 2019" </span><span style=color:#928374;font-style:italic># Generator，你的工具链，可以用 cmake --help 来看看有哪些可用的
</span><span>	</span><span style=color:#fe8019>-</span><span>A Win32 </span><span style=color:#928374;font-style:italic># 选择 Visual C++ 工具链的情况下可以用 -A Win32 选择编译32位代码，或者 Win64
</span><span>	</span><span style=color:#fe8019>-</span><span>DCMAKE_BUILD_TYPE</span><span style=color:#fe8019>=</span><span>Debug </span><span style=color:#928374;font-style:italic># 常用的 Debug/Release/RelWithDebInfo
</span><span>	</span><span style=color:#fe8019>-</span><span>DLIEF_PYTHON_API</span><span style=color:#fe8019>=</span><span>off </span><span style=color:#928374;font-style:italic># 不编译 Python 模块，这样就不用装 Python 了
</span><span>	</span><span style=color:#fe8019>-</span><span>DLIEF_USE_CRT_DEBUG</span><span style=color:#fe8019>=</span><span>MD </span><span style=color:#928374;font-style:italic># 使用 /MD 链接 msvcrt.dll 而不是 libcmt
</span></code></pre><p>这儿有个坑，用 Visual Studio 这个 Generator 的时候，虽然指定了 <code>CMAKE_BUILD_TYPE</code>，但实际没什么卵用，还得在编译的时候给参数 <code>--config Debug</code> 才会真的按 Debug 编译。<p>然后是编译命令：<pre class=language-powershell data-lang=powershell style=color:#fdf4c1aa;background-color:#282828><code class=language-powershell data-lang=powershell><span>cmake </span><span style=color:#fe8019>--</span><span>build </span><span style=color:#fe8019>. --</span><span>config Debug </span><span style=color:#fe8019>--</span><span>target LIB_LIEF
</span></code></pre><p>默认用微软的 msbuild 会花很长时间去编译，不嫌麻烦的话可以用 Ninja。<p>编译完还不能用，还得先“安装”到一个目录里。<pre class=language-powershell data-lang=powershell style=color:#fdf4c1aa;background-color:#282828><code class=language-powershell data-lang=powershell><span>cmake </span><span style=color:#fe8019>--</span><span>install </span><span style=color:#fe8019>. --</span><span>config Debug </span><span style=color:#fe8019>--</span><span>prefix LIEF</span><span style=color:#fe8019>-</span><span>msvc</span><span style=color:#fe8019>-</span><span>debug
</span></code></pre><p>这样就会把必要的文件给复制到 <code>LIEF-msvc-debug</code> 这个文件夹里了，参考 LIEF 官方的集成文档，把 <code>LIEF_DIR</code> 设置成这个文件夹的路径就可以用啦。<h2 id=0x02-visual-c-gong-ju-lian-ninja>0x02 Visual C++ 工具链 ninja</h2><p>使用 CMake + Ninja 的情况下没法用 <code>-A</code> 去控制编译32位还是64位了，你得先装好 Visual C++ 构建工具，然后打开开发者命令提示符。<p><img alt=image-20211008160449880 src=https://nnnewb.github.io/posts/2021/how-to-compile-lief-on-windows/image/how-to-compile-lief-on-windows/image-20211008160449880.webp><p>比如想编译32位的就选 <code>x86 native tool command prompt</code> ，在这个命令提示符里用 cmake 构建。<pre class=language-powershell data-lang=powershell style=color:#fdf4c1aa;background-color:#282828><code class=language-powershell data-lang=powershell><span>cmake .</span><span style=color:#fe8019>. -</span><span>G Ninja </span><span style=color:#fe8019>-</span><span>DCMAKE_BUILD_TYPE</span><span style=color:#fe8019>=</span><span>Debug </span><span style=color:#fe8019>-</span><span>DLIEF_PYTHON_API</span><span style=color:#fe8019>=</span><span>off </span><span style=color:#fe8019>-</span><span>DLIEF_USE_CRT_DEBUG</span><span style=color:#fe8019>=</span><span>MD
</span><span>cmake </span><span style=color:#fe8019>--</span><span>build </span><span style=color:#fe8019>. --</span><span>target LIB_LIEF
</span><span>cmake </span><span style=color:#fe8019>--</span><span>install </span><span style=color:#fe8019>. --</span><span>prefix LIEF</span><span style=color:#fe8019>-</span><span>msvc</span><span style=color:#fe8019>-</span><span>debug
</span></code></pre><p>其他和直接用 msvc 没啥区别。<h2 id=0x03-mingw-gong-ju-lian-makefile>0x03 MinGW 工具链 makefile</h2><p>MinGW 工具链其实和 msvc 差不太大。先装 MinGW，推荐 msys2，msys2装好后跑命令 <code>pacman -Sy mingw-w64-i686-toolchain</code> 就能装上32位的编译工具链了，包括了 <code>gcc</code>、<code>g++</code>、<code>mingw32-make</code> 这些必要的程序。<p>完事后把 <code>MinGW</code> 工具链加到 <code>PATH</code> 里。一般来说，假如你把 msys2 装到 <code>C:\msys64</code> 下的话，那要加的路径就是 <code>C:\msys64\mingw32\bin</code>，自己看看要用的 gcc 放在哪儿呗。<p>另外 <code>LIEF_USE_CRT_DEBUG</code> 这变量也用不到了，<code>MD</code>还是<code>MT</code> 这是专供 MSVC 的选择题，MinGW 不管这个。<p>接着就可以用 CMake 了。<pre class=language-powershell data-lang=powershell style=color:#fdf4c1aa;background-color:#282828><code class=language-powershell data-lang=powershell><span>cmake .</span><span style=color:#fe8019>. -</span><span>G </span><span style=color:#b8bb26>"MinGW Makefiles" </span><span style=color:#fe8019>-</span><span>DCMAKE_BUILD_TYPE</span><span style=color:#fe8019>=</span><span>Debug </span><span style=color:#fe8019>-</span><span>DLIEF_PYTHON_API</span><span style=color:#fe8019>=</span><span>off </span><span style=color:#b8bb26>'-DCMAKE_C_FLAGS:STRING="-m32"' '-DCMAKE_CXX_FLAGS:STRING="-m32"'
</span><span>cmake </span><span style=color:#fe8019>--</span><span>build </span><span style=color:#fe8019>. --</span><span>target LIB_LIEF
</span><span>cmake </span><span style=color:#fe8019>--</span><span>install </span><span style=color:#fe8019>. --</span><span>prefix LIEF</span><span style=color:#fe8019>-</span><span>mingw32</span><span style=color:#fe8019>-</span><span>debug
</span></code></pre><p>不用担心 CMake 选错工具链，用 <code>MinGW Makefiles</code> 的情况下会优先考虑 GCC 的。不过还有个老问题：怎么选32位还是64位。答案是设置下 <code>C_FLAGS</code> 和 <code>CXX_FLAGS</code> 这两个特殊变量，让编译器加上 <code>-m32</code> 这个参数，编译出来的就是32位代码了。<h2 id=0x04-mingw-gong-ju-lian-ninja>0x04 MinGW 工具链 Ninja</h2><p>和 <code>MinGW Makefiles</code> 差不太多，但是 <code>Ninja</code> 没那么聪明，不知道要用什么编译器，得手动指定。<pre class=language-powershell data-lang=powershell style=color:#fdf4c1aa;background-color:#282828><code class=language-powershell data-lang=powershell><span>cmake .</span><span style=color:#fe8019>. -</span><span>G Ninja </span><span style=color:#fe8019>-</span><span>DCMAKE_BUILD_TYPE</span><span style=color:#fe8019>=</span><span>Debug </span><span style=color:#fe8019>-</span><span>DLIEF_PYTHON_API</span><span style=color:#fe8019>=</span><span>off </span><span style=color:#fe8019>-</span><span>DCMAKE_C_COMPILER</span><span style=color:#fe8019>=</span><span>gcc </span><span style=color:#fe8019>-</span><span>DCMAKE_CXX_COMPILER</span><span style=color:#fe8019>=</span><span>g</span><span style=color:#fe8019>++ </span><span style=color:#b8bb26>'-DCMAKE_C_FLAGS:STRING="-m32"' '-DCMAKE_CXX_FLAGS:STRING="-m32"'
</span><span>cmake </span><span style=color:#fe8019>--</span><span>build </span><span style=color:#fe8019>. --</span><span>target LIB_LIEF
</span><span>cmake </span><span style=color:#fe8019>--</span><span>install </span><span style=color:#fe8019>. --</span><span>prefix LIEF</span><span style=color:#fe8019>-</span><span>mingw32</span><span style=color:#fe8019>-</span><span>debug
</span></code></pre><p>配置阶段多出来两个参数，<code>-DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++</code>，目的就是告诉 CMake 放机灵点，用 <code>gcc/g++</code> 编译器，别瞎整。<h2 id=zong-jie>总结</h2><p>也就这么回事吧。</article><p class=tags-data><a href=/tags/c>/c++/</a> <a href=/tags/lief>/LIEF/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>