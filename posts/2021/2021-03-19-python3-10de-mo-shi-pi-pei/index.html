<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>pattern-match-in-python310</title><meta content=pattern-match-in-python310 name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2021/2021-03-19-python3-10de-mo-shi-pi-pei/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content=pattern-match-in-python310 property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2021/2021-03-19-python3-10de-mo-shi-pi-pei/ property=twitter:url><meta content=pattern-match-in-python310 property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2021/2021-03-19-python3-10de-mo-shi-pi-pei/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>pattern-match-in-python310</h1><p class=author-line>作于：2021-03-19 10:19 ，预计阅读时间 23 分钟<article><h2 id=shuo-ming>说明</h2><p>简单机翻润色一下 PEP-636<h2 id=gai-yao>概要</h2><p>这个PEP是PEP 634引入的模式匹配教程。<p>PEP 622提出了模式匹配的语法，社区和指导委员会对此进行了详细讨论。一个常见的问题是解释(和学习)这个特性是否容易。这个PEP关注的是提供开发人员可以用来学习Python中的模式匹配的文档类型。<p>PEP 636 被认为是PEP 634(模式匹配的技术规范)和PEP 635(模式匹配的添加动机和理由与设计考虑)的支持材料。<p>对于想要快速回顾而不是教程的读者，请参阅附录a。<h2 id=jiao-cheng>教程</h2><p>作为本教程的一个例子，你将编写一个文本冒险游戏。这是一种互动小说形式，用户输入文本命令与虚构世界进行互动，并接收关于所发生事情的文本描述。命令将是简化形式的自然语言，如<code>get sword</code>，<code>attack dragon</code>，<code>go north</code>，<code>enter shop</code>或<code>but cheese</code>。<h3 id=pi-pei-xu-lie>匹配序列</h3><p>你的主循环将需要从用户那里获取输入，并将它分割成单词，例如一个像这样的字符串列表:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>command </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>input</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"What are you doing next? "</span><span style=color:#fdf4c1>)
</span><span style=color:#928374;font-style:italic># analyze the result of command.split()
</span></code></pre><p>下一步是解读这些单词。我们的大多数命令都有两个词:一个动作和一个对象。所以你可能会忍不住这样做:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>[action, obj] </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>command.split()
</span><span style=color:#d3869b>... </span><span style=color:#928374;font-style:italic># interpret action, obj
</span></code></pre><p>这行代码的问题在于它遗漏了一些东西：如果用户输入的单词多于或少于2个单词怎么办?为了防止这个问题，您可以检查单词列表的长度，或者捕获上面的语句将引发的<code>ValueError</code>。<p>或者，你可以使用<code>match</code>语句来代替:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>match </span><span style=color:#fdf4c1>command.split()</span><span>:
</span><span>    case [action, obj]:
</span><span>        </span><span style=color:#d3869b>... </span><span style=color:#928374;font-style:italic># interpret action, obj
</span></code></pre><p><code>match</code>语句计算**“subject”**(<code>match</code>关键字后面的值)，并根据模式(<code>case</code>旁边的代码)检查它。一个模式可以做两件不同的事情:<ul><li>验证 subject 具有一定的结构。在您的示例中，<code>[action, obj]</code>模式匹配任何恰好包含两个元素的序列。这叫做 <strong>maching</strong>。<li>它将模式中的一些名称绑定到 subject 的组件元素。在本例中，如果列表有两个元素，它将绑定<code>action = subject[0]</code>和<code>obj = subject[1]</code>。</ul><p>如果匹配，则<code>case</code>块内的语句将与绑定的变量一起执行。如果没有匹配，则什么也不发生，然后执行<code>match</code>之后的语句。<p>注意，与解包赋值(unpacking assignments)的方式类似，您可以使用圆括号、方括号或逗号分隔，它们含义相同。所以你可以写<code>case action, obj</code>或者<code>case (action, obj)</code>。上述任意形式都将匹配序列类型(例如<code>list</code>或<code>tuple</code>)。<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#928374;font-style:italic># 译者补充，下述case等效
</span><span>match [</span><span style=color:#d3869b>1</span><span>,</span><span style=color:#d3869b>2</span><span>,</span><span style=color:#d3869b>3</span><span>]: </span><span style=color:#928374;font-style:italic># match (1,2,3) 也一样
</span><span>    case a,b,c:
</span><span>        </span><span style=color:#d3869b>...
</span><span>    </span><span style=color:#fdf4c1>case (a,b,c)</span><span>:
</span><span>        </span><span style=color:#d3869b>...
</span><span>    case [a,b,c]:
</span><span>        </span><span style=color:#d3869b>...
</span></code></pre><h3 id=pi-pei-duo-ge-mo-shi>匹配多个模式</h3><p>即使大多数命令都是动作/对象形式，你也可能想要不同长度的用户命令。例如，你可能希望添加没有对象(如<code>look</code>或<code>quit</code>)的单个动词。一个<code>match</code>语句可以(而且很可能)有不止一种情况:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>match </span><span style=color:#fdf4c1>command.split()</span><span>:
</span><span>    case [action]:
</span><span>        </span><span style=color:#d3869b>... </span><span style=color:#928374;font-style:italic># interpret single-verb action
</span><span>    case [action, obj]:
</span><span>        </span><span style=color:#d3869b>... </span><span style=color:#928374;font-style:italic># interpret action, obj
</span></code></pre><p><code>match</code>语句将从上到下检查模式。如果模式与 subject 不匹配，将尝试下一个模式。但是，一旦找到第一个匹配的模式，就会执行该<code>case</code>的主体，并忽略所有后续的<code>case</code>。这类似于<code>if</code>/<code>elif</code>/<code>elif</code>/…语句的工作方式。<h3 id=pi-pei-te-ding-zhi>匹配特定值</h3><p>你的代码仍然需要查看特定的操作，并根据特定的操作有条件地执行不同的逻辑(例如，<code>quit</code>、<code>attack</code>或<code>buy</code>)。你可以使用<code>if</code>/<code>elif</code>/<code>elif</code>/…，或者使用函数字典，但是这里我们将利用模式匹配来解决这个任务。除了变量，你可以在模式中使用字面值(如<code>"quit"</code>、<code>42</code>或<code>None</code>)。这允许你这样写:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>match </span><span style=color:#fdf4c1>command.split()</span><span>:
</span><span>    case [</span><span style=color:#b8bb26>"quit"</span><span>]:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"Goodbye!"</span><span style=color:#fdf4c1>)
</span><span>        </span><span style=color:#fdf4c1>quit_game()
</span><span>    case [</span><span style=color:#b8bb26>"look"</span><span>]:
</span><span>        </span><span style=color:#fdf4c1>current_room.describe()
</span><span>    case [</span><span style=color:#b8bb26>"get"</span><span>, obj]:
</span><span>        </span><span style=color:#fdf4c1>character.get(obj, current_room)
</span><span>    case [</span><span style=color:#b8bb26>"go"</span><span>, direction]:
</span><span>        current_room </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>current_room.neighbor(direction)
</span><span>    </span><span style=color:#928374;font-style:italic># The rest of your commands go here
</span></code></pre><p>像<code>["get"， obj]</code>这样的模式将只匹配第一个元素等于<code>"get"</code>的2个元素的序列。它还将绑定<code>obj = subject[1]</code>。<p>正如您在上述代码的<code>go</code>模式中看到的，我们还可以在不同的模式中使用不同的变量名。<p>除了与<code>is</code>操作符比较的常量<code>True</code>、<code>False</code>和<code>None</code>之外，其他字面值是用<code>==</code>操作符比较的。<h3 id=pi-pei-duo-ge-zhi>匹配多个值</h3><p>玩家可以通过使用一系列的命令来投掷多个物品，如:<code>drop key</code>, <code>drop sword</code>, <code>drop cheese</code>。这个接口可能很麻烦，您可能希望允许在一个命令中添加多个项，比如<code>drop key sword cheese</code>。在这种情况下，你事先不知道命令中有多少个单词，但是你可以在模式中使用扩展解包(extended unpacking)，就像它们在解包赋值里的写法:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>match </span><span style=color:#fdf4c1>command.split()</span><span>:
</span><span>    case [</span><span style=color:#b8bb26>"drop"</span><span>, </span><span style=color:#fe8019>*</span><span>objects]:
</span><span>        </span><span style=color:#fa5c4b>for </span><span>obj </span><span style=color:#fa5c4b>in </span><span>objects:
</span><span>            </span><span style=color:#fdf4c1>character.drop(obj, current_room)
</span><span>    </span><span style=color:#928374;font-style:italic># The rest of your commands go here
</span></code></pre><p>这将匹配任何以<code>“drop”</code>作为第一个元素的序列。所有剩余的元素都将在一个列表对象中被捕获，该列表对象将绑定到<code>objects</code>变量。<p>这种语法与序列解包有类似的限制:在一个模式中不能有多个带星号的名称。<h3 id=tian-jia-tong-pei-fu>添加通配符</h3><p>您可能希望打印一条错误消息，说明当所有模式都失败时，无法识别该命令。您可以使用我们刚刚学习的特性，并将<code>case [*ignored_words]</code>作为您的最后一个模式。然而，有一个更简单的方法:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>match </span><span style=color:#fdf4c1>command.split()</span><span>:
</span><span>    case [</span><span style=color:#b8bb26>"quit"</span><span>]: </span><span style=color:#d3869b>... </span><span style=color:#928374;font-style:italic># Code omitted for brevity
</span><span>    case [</span><span style=color:#b8bb26>"go"</span><span>, direction]: </span><span style=color:#d3869b>...
</span><span>    case [</span><span style=color:#b8bb26>"drop"</span><span>, </span><span style=color:#fe8019>*</span><span>objects]: </span><span style=color:#d3869b>...
</span><span>    </span><span style=color:#d3869b>... </span><span style=color:#928374;font-style:italic># Other cases
</span><span>    case </span><span style=color:#fdf4c1>_</span><span>:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#fa5c4b>f</span><span style=color:#b8bb26>"Sorry, I couldn't understand </span><span style=color:#fdf4c1>{command</span><span style=color:#fa5c4b>!r</span><span style=color:#fdf4c1>}</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>)
</span></code></pre><p>这个特殊的模式被写成<code>_</code>(称为通配符)。不管 subject 是什么它总是能匹配到，但它不绑定任何变量。<p>注意，这将匹配任何对象，而不仅仅是序列。因此，只有将它单独作为最后一个模式才有意义(为了防止错误，Python会阻止您在其他<code>case</code>之前使用它)。<h3 id=mo-shi-zu-he>模式组合</h3><p>这是一个很好的时机，可以从示例中退后一步，了解您一直在使用的模式是如何构建的。模式可以相互嵌套，我们已经在上面的例子中隐式地这样做了。<p>我们已经看到了一些“简单”模式(这里的“简单”意味着它们不包含其他模式):<ul><li>捕获模式 Capture patterns (独立名称，如方向、动作、对象)。我们从未单独讨论过这些，而是将它们作为其他模式的一部分使用。<li>字面值模式 Literal patterns (字符串字面值、数字字面值、<code>True</code>、<code>False</code>和<code>None</code>)<li>通配符模式 Wildcard pattern <code>_</code></ul><p>到目前为止，我们实验过的唯一一个非简单模式是序列模式。序列模式中的每个元素实际上都可以是任何其他模式。这意味着您可以编写像<code>["first"， (left, right)， _， *rest]</code>这样的模式。匹配的 subject 是一个至少包含三个元素的序列，其中第一个元素等于<code>"first"</code>，第二个元素依次是两个元素的序列。它也会绑定<code>left=subject[1][0]</code>， <code>right=subject[1][1]</code>，<code>rest =subject[3:]</code><h3 id=or-mo-shi>or 模式</h3><p>回到冒险游戏的例子中，你可能会发现你想要一些导致相同结果的模式。例如，您可能希望命令<code>north</code>和<code>go north</code>相等。您可能还希望为<code>get X</code>可以有一些别名如<code>pick x up</code>和<code>pick up x</code>。<p>模式中的|符号将它们组合为可选项。你可以这样写:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>match </span><span style=color:#fdf4c1>command.split()</span><span>:
</span><span>    </span><span style=color:#d3869b>... </span><span style=color:#928374;font-style:italic># Other cases
</span><span>    case [</span><span style=color:#b8bb26>"north"</span><span>] </span><span style=color:#fe8019>| </span><span>[</span><span style=color:#b8bb26>"go"</span><span>, </span><span style=color:#b8bb26>"north"</span><span>]:
</span><span>        current_room </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>current_room.neighbor(</span><span style=color:#b8bb26>"north"</span><span style=color:#fdf4c1>)
</span><span>    case [</span><span style=color:#b8bb26>"get"</span><span>, obj] </span><span style=color:#fe8019>| </span><span>[</span><span style=color:#b8bb26>"pick"</span><span>, </span><span style=color:#b8bb26>"up"</span><span>, obj] </span><span style=color:#fe8019>| </span><span>[</span><span style=color:#b8bb26>"pick"</span><span>, obj, </span><span style=color:#b8bb26>"up"</span><span>]:
</span><span>        </span><span style=color:#d3869b>... </span><span style=color:#928374;font-style:italic># Code for picking up the given object
</span></code></pre><p>这被称为<strong>or模式</strong>，并将产生预期的结果。模式从左到右尝试；如果有多个可选匹配，通过从左至右这一规则可以知道是匹配到了哪个模式。在编写or模式时，一个重要的限制是所有备选项都应该绑定相同的变量。所以模式<code>[1,x] | [2, y]</code>是不允许的，因为它会使匹配成功后绑定哪个变量变得不清楚。<code>[1, x] | [2, x]</code>非常好，如果成功，将始终绑定<code>x</code>。<h3 id=bu-huo-pi-pei-de-zi-mo-shi>捕获匹配的子模式</h3><p>我们的<code>“go”</code>命令的第一个版本是用<code>[“go”，direction]</code>模式编写的。我们在上一个版本中使用模式<code>["north"] | ["go"， "north"]</code>所做的改变有一些好处，但也有一些缺点:最新版本允许别名，但也有硬编码的方向别名<code>"north"</code>，这将迫使我们实际上有独立的模式，<code>north</code>/<code>south</code>/<code>east</code>/<code>west</code>。这将导致一些代码重复，但同时我们得到了更好的输入验证，并且如果用户输入的命令是<code>“go figure!”</code>而不是方向，我们将不会进入那个分支。<p>我们可以试着在两个方面都做到最好(为了简洁，我省略了不使用<code>“go”</code>的别名版本):<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>match </span><span style=color:#fdf4c1>command.split()</span><span>:
</span><span>    case [</span><span style=color:#b8bb26>"go"</span><span>, (</span><span style=color:#b8bb26>"north" </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>"south" </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>"east" </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>"west"</span><span>)]:
</span><span>        current_room </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>current_room.neighbor(</span><span style=color:#d3869b>...</span><span style=color:#fdf4c1>)
</span><span>        </span><span style=color:#928374;font-style:italic># how do I know which direction to go?
</span></code></pre><p>这段代码是一个单独的分支，它验证<code>“go”</code>之后的单词是否确实是一个方向。但移动玩家的代码需要知道选择了哪一个，但却无法做到这一点。我们需要的是一个行为类似于or模式但同时进行捕获的模式。我们可以使用<strong>as模式</strong>:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>match </span><span style=color:#fdf4c1>command.split()</span><span>:
</span><span>    case [</span><span style=color:#b8bb26>"go"</span><span>, (</span><span style=color:#b8bb26>"north" </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>"south" </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>"east" </span><span style=color:#fe8019>| </span><span style=color:#b8bb26>"west"</span><span>) </span><span style=color:#fdf4c1;background-color:#932b1e>as</span><span> direction]:
</span><span>        current_room </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>current_room.neighbor(direction)
</span></code></pre><p>as模式匹配左边的任何模式，同时也将值绑定到名称。<h3 id=tian-jia-tiao-jian-dao-mo-shi>添加条件到模式</h3><p>我们上面探讨的模式可以做一些强大的数据过滤，但有时您可能希望得到布尔表达式的全部功能。假设您实际上希望只允许<code>“go”</code>命令出现在基于从<code>current_room</code>的可能出口的受限方向集合中。我们可以通过在我们的案例中增加一个 <strong>guard</strong> 来实现这一点。guard 由 if 关键字后跟任意表达式组成:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>match </span><span style=color:#fdf4c1>command.split()</span><span>:
</span><span>    case [</span><span style=color:#b8bb26>"go"</span><span>, direction] </span><span style=color:#fa5c4b>if </span><span>direction </span><span style=color:#fe8019>in </span><span>current_room.exits:
</span><span>        current_room </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>current_room.neighbor(direction)
</span><span>    case [</span><span style=color:#b8bb26>"go"</span><span>, </span><span style=color:#fdf4c1>_</span><span>]:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"Sorry, you can't go that way"</span><span style=color:#fdf4c1>)
</span></code></pre><p>guard 不是模式的一部分，而是 case 的一部分。它只在模式匹配，并且所有模式变量都被绑定之后检查(这就是为什么条件可以在上面的例子中使用<code>direction</code>变量)。如果模式匹配且条件为真，则 case body 正常执行。如果模式匹配，但条件为假，<code>match</code>语句继续检查下一个条件，就好像模式没有匹配一样(可能的副作用是已经绑定了一些变量)。<h3 id=tian-jia-ui-pi-pei-dui-xiang>添加UI: 匹配对象</h3><p>你的冒险游戏正走向成功，你被请求为游戏实现一个图形界面。您所选择的UI工具包允许您编写一个事件循环，您可以通过调用<code>event.get()</code>来获取一个新的事件对象。根据用户的动作，结果对象可以有不同的类型和属性，例如:<ul><li>当用户按下某个键时，将生成<code>KeyPress</code>对象。它有一个<code>key_name</code>属性，其中包含所按键的名称，以及一些有关修饰符的其他属性。<li>当用户单击鼠标时，将生成一个<code>Click</code>对象。它有一个指针坐标的属性<code>position</code>。<li>当用户点击游戏窗口的关闭按钮时，会生成一个<code>Quit</code>对象。</ul><p>与其编写多个<code>isinstance()</code>检查，你可以使用模式来识别不同类型的对象，也可以将模式应用到其属性上:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>match </span><span style=color:#fdf4c1>event.get()</span><span>:
</span><span>    case </span><span style=color:#fdf4c1>Click(position</span><span style=color:#fe8019>=</span><span style=color:#fdf4c1>(x, y))</span><span>:
</span><span>        </span><span style=color:#fdf4c1>handle_click_at(x, y)
</span><span>    case </span><span style=color:#fdf4c1>KeyPress(key_name</span><span style=color:#fe8019>=</span><span style=color:#b8bb26>"Q"</span><span style=color:#fdf4c1>) </span><span style=color:#fe8019>| </span><span style=color:#fdf4c1>Quit()</span><span>:
</span><span>        </span><span style=color:#fdf4c1>game.quit()
</span><span>    case </span><span style=color:#fdf4c1>KeyPress(key_name</span><span style=color:#fe8019>=</span><span style=color:#b8bb26>"up arrow"</span><span style=color:#fdf4c1>)</span><span>:
</span><span>        </span><span style=color:#fdf4c1>game.go_north()
</span><span>    </span><span style=color:#d3869b>...
</span><span>    case </span><span style=color:#fdf4c1>KeyPress()</span><span>:
</span><span>        </span><span style=color:#fa5c4b>pass </span><span style=color:#928374;font-style:italic># Ignore other keystrokes
</span><span>    case other_event:
</span><span>        </span><span style=color:#fa5c4b>raise </span><span style=color:#fabd2f>ValueError</span><span style=color:#fdf4c1>(</span><span style=color:#fa5c4b>f</span><span style=color:#b8bb26>"Unrecognized event: </span><span style=color:#fdf4c1>{other_event}</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>)
</span></code></pre><p>像<code>Click(position=(x, y))</code>这样的模式仅在事件类型是<code>Click</code>类的子类时才匹配。它还要求事件具有一个与<code>(x, y)</code>模式匹配的位置属性。如果匹配，则局部变量<code>x</code>和<code>y</code>将得到期望的值。<p>像<code>KeyPress()</code>这样不带参数的模式将匹配任何<code>KeyPress</code>类实例的对象。只有在模式中指定的属性才会匹配，其他任何属性都将被忽略。<h3 id=pi-pei-wei-zhi-shu-xing>匹配位置属性</h3><p>前一节描述了在进行对象匹配时如何匹配命名属性。对于某些对象，可以方便地根据位置描述匹配的参数(特别是当只有几个属性并且它们有“标准”排序时)。如果您正在使用的类是命名元组 <code>namedtuple</code> 或数据类 <code>dataclass</code>，那么您可以按照构造对象时使用的相同顺序来实现这一点。例如，如果上面的UI框架像这样定义它们的类:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fa5c4b>from </span><span>dataclasses </span><span style=color:#fa5c4b>import </span><span>dataclass
</span><span>
</span><span>@</span><span style=color:#fdf4c1>dataclass
</span><span style=color:#fa5c4b>class </span><span style=color:#8ec07c>Click</span><span>:
</span><span>    position: </span><span style=color:#fabd2f>tuple
</span><span>    button: Button
</span></code></pre><p>然后你可以重写你的匹配语句来匹配上面的 subject:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>match </span><span style=color:#fdf4c1>event.get()</span><span>:
</span><span>    case </span><span style=color:#fdf4c1>Click((x, y))</span><span>:
</span><span>        </span><span style=color:#fdf4c1>handle_click_at(x, y)
</span></code></pre><p><code>(x, y)</code>模式将自动匹配<code>position</code>属性，因为模式中的第一个参数对应于数据类定义中的第一个属性。<p>其他类的属性没有自然的顺序，因此需要在模式中使用显式名称来匹配它们的属性。但是，也可以手动指定属性的顺序，允许位置匹配，就像下面这个替代定义:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fa5c4b>class </span><span style=color:#8ec07c>Click</span><span>:
</span><span>    __match_args__ </span><span style=color:#fe8019>= </span><span>[</span><span style=color:#b8bb26>"position"</span><span>, </span><span style=color:#b8bb26>"button"</span><span>]
</span><span>    </span><span style=color:#fa5c4b>def </span><span style=color:#fabd2f>__init__</span><span>(</span><span style=color:#fdf4c1>self</span><span>, </span><span style=color:#fdf4c1>position</span><span>, </span><span style=color:#fdf4c1>button</span><span>):
</span><span>        </span><span style=color:#d3869b>...
</span></code></pre><p><code>__match_args__</code>特殊属性定义了可以在<code>case Click((x,y))</code>等模式中使用的属性的显式顺序。<h3 id=pi-pei-chang-liang-he-mei-ju>匹配常量和枚举</h3><p>上面的模式对所有鼠标按钮都一视同仁，但您已经决定只接受鼠标左键单击事件，而忽略其他鼠标按键。在做这一修改时，您注意到<code>button</code>属性被定义为一个<code>Button</code>，这是一个用<code>enum.Enum</code>构建的枚举。实际上，你可以像这样匹配枚举值:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>match </span><span style=color:#fdf4c1>event.get()</span><span>:
</span><span>    case </span><span style=color:#fdf4c1>Click((x, y), button</span><span style=color:#fe8019>=</span><span style=color:#fdf4c1>Button.LEFT)</span><span>:  </span><span style=color:#928374;font-style:italic># This is a left click
</span><span>        </span><span style=color:#fdf4c1>handle_click_at(x, y)
</span><span>    case </span><span style=color:#fdf4c1>Click()</span><span>:
</span><span>        </span><span style=color:#fa5c4b>pass  </span><span style=color:#928374;font-style:italic># ignore other clicks
</span></code></pre><p>这将适用于任何带点的名称(如<code>math.pi</code>)。然而，非限定名称(即没有点的裸名称)将总是被解释为捕获模式，因此在模式中始终使用限定常量可以避免这种歧义。<h3 id=zou-jin-yun-fu-wu-pi-pei-zi-dian>走进云服务：匹配字典</h3><p>你决定制作游戏的在线版本。您的所有逻辑都将在服务器中，而客户端中的UI将使用JSON消息进行通信。通过json模块，这些将被映射到Python字典、列表和其他内置对象。<p>我们的客户端将收到一个字典列表(从JSON解析)，包含了要采取的动作，每个元素的查找示例如下:<ul><li><code>{"text": "The shop keeper says 'Ah! We have Camembert, yes sir'", "color": "blue"}</code><li>如果客户端应该暂停<code>{"sleep": 3}</code><li>播放声音 <code>{"sound": "filename.ogg", "format": "ogg"}</code></ul><p>到目前为止，我们的模式已经处理了序列，但是也有一些模式可以根据它们当前的键匹配映射。在这种情况下，你可以使用:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fa5c4b>for </span><span>action </span><span style=color:#fa5c4b>in </span><span>actions:
</span><span>    match action:
</span><span>        case {</span><span style=color:#b8bb26>"text"</span><span>: message, </span><span style=color:#b8bb26>"color"</span><span>: c}:
</span><span>            </span><span style=color:#fdf4c1>ui.set_text_color(c)
</span><span>            </span><span style=color:#fdf4c1>ui.display(message)
</span><span>        case {</span><span style=color:#b8bb26>"sleep"</span><span>: duration}:
</span><span>            </span><span style=color:#fdf4c1>ui.wait(duration)
</span><span>        case {</span><span style=color:#b8bb26>"sound"</span><span>: url, </span><span style=color:#b8bb26>"format"</span><span>: </span><span style=color:#b8bb26>"ogg"</span><span>}:
</span><span>            </span><span style=color:#fdf4c1>ui.play(url)
</span><span>        case {</span><span style=color:#b8bb26>"sound"</span><span>: </span><span style=color:#fdf4c1>_</span><span>, </span><span style=color:#b8bb26>"format"</span><span>: </span><span style=color:#fdf4c1>_</span><span>}:
</span><span>            </span><span style=color:#fdf4c1>warning(</span><span style=color:#b8bb26>"Unsupported audio format"</span><span style=color:#fdf4c1>)
</span></code></pre><p>映射模式中的键需要是字面值，但是值可以是任何模式。与序列模式一样，所有子模式都必须匹配通用模式才能匹配。<p>您可以在映射模式中使用<code>**rest</code>来捕获 subject 中的附加键。请注意，如果你忽略了这一点，在匹配时，主题中的额外键将被忽略，例如，消息<code>{"text": "foo"， "color": "red"， "style": "bold"}</code>将匹配上面例子中的第一个模式。<h3 id=pi-pei-nei-jian-lei-builtin-classes>匹配内建类 builtin classes</h3><p>上面的代码可以需要一些验证。如果消息来自外部源，则字段的类型可能是错误的，从而导致错误或安全问题。<p>任何类都是有效的匹配目标，其中包括<code>bool</code>、<code>str</code>或<code>int</code>等内置类，这允许我们将上面的代码与类模式结合起来。因此，我们可以使用 <code>{"text": str() as message, "color": str() as c}</code>来代替<code>{"text": message, "color": c}</code>来确保<code>message</code>和<code>c</code>都是字符串。对于许多内置类(参见PEP-634了解整个列表)，可以使用位置参数作为简写，写成<code>str(c)</code>而不是<code>str() as c</code>。完全重写的版本如下所示:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fa5c4b>for </span><span>action </span><span style=color:#fa5c4b>in </span><span>actions:
</span><span>    match action:
</span><span>        case {</span><span style=color:#b8bb26>"text"</span><span>: </span><span style=color:#fabd2f>str</span><span style=color:#fdf4c1>(message)</span><span>, </span><span style=color:#b8bb26>"color"</span><span>: </span><span style=color:#fabd2f>str</span><span style=color:#fdf4c1>(c)</span><span>}:
</span><span>            </span><span style=color:#fdf4c1>ui.set_text_color(c)
</span><span>            </span><span style=color:#fdf4c1>ui.display(message)
</span><span>        case {</span><span style=color:#b8bb26>"sleep"</span><span>: </span><span style=color:#fabd2f>float</span><span style=color:#fdf4c1>(duration)</span><span>}:
</span><span>            </span><span style=color:#fdf4c1>ui.wait(duration)
</span><span>        case {</span><span style=color:#b8bb26>"sound"</span><span>: </span><span style=color:#fabd2f>str</span><span style=color:#fdf4c1>(url)</span><span>, </span><span style=color:#b8bb26>"format"</span><span>: </span><span style=color:#b8bb26>"ogg"</span><span>}:
</span><span>            </span><span style=color:#fdf4c1>ui.play(url)
</span><span>        case {</span><span style=color:#b8bb26>"sound"</span><span>: </span><span style=color:#fdf4c1>_</span><span>, </span><span style=color:#b8bb26>"format"</span><span>: </span><span style=color:#fdf4c1>_</span><span>}:
</span><span>            </span><span style=color:#fdf4c1>warning(</span><span style=color:#b8bb26>"Unsupported audio format"</span><span style=color:#fdf4c1>)
</span></code></pre><h2 id=fu-lu-a-kuai-su-ru-men>附录A -- 快速入门</h2><p><code>match</code>语句接受一个表达式，并将其值与作为一个或多个<code>case</code>块给出的模式进行比较。这看起来类似于C、Java或JavaScript(以及许多其他语言)中的<code>switch</code>语句，但功能要强大得多。<p>最简单的形式是将一个 subject 值与一个或多个字面值进行比较:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>http_error</span><span>(</span><span style=color:#fdf4c1>status</span><span>):
</span><span>    match status:
</span><span>        case </span><span style=color:#d3869b>400</span><span>:
</span><span>            </span><span style=color:#fa5c4b>return </span><span style=color:#b8bb26>"Bad request"
</span><span>        case </span><span style=color:#d3869b>404</span><span>:
</span><span>            </span><span style=color:#fa5c4b>return </span><span style=color:#b8bb26>"Not found"
</span><span>        case </span><span style=color:#d3869b>418</span><span>:
</span><span>            </span><span style=color:#fa5c4b>return </span><span style=color:#b8bb26>"I'm a teapot"
</span><span>        case </span><span style=color:#fdf4c1>_</span><span>:
</span><span>            </span><span style=color:#fa5c4b>return </span><span style=color:#b8bb26>"Something's wrong with the Internet"
</span></code></pre><p>注意最后一块:“变量名”<code>_</code>充当通配符，永远不会失败。<p>你可以使用<code>|</code> ("or")将几个字面值组合在一个模式中:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>case </span><span style=color:#d3869b>401 </span><span style=color:#fe8019>| </span><span style=color:#d3869b>403 </span><span style=color:#fe8019>| </span><span style=color:#d3869b>404</span><span>:
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#b8bb26>"Not allowed"
</span></code></pre><p>模式看起来就像解包赋值，可以用来绑定变量:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#928374;font-style:italic># point is an (x, y) tuple
</span><span>match point:
</span><span>    </span><span style=color:#fdf4c1>case (</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, </span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>)</span><span>:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"Origin"</span><span style=color:#fdf4c1>)
</span><span>    </span><span style=color:#fdf4c1>case (</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, y)</span><span>:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#fa5c4b>f</span><span style=color:#b8bb26>"Y=</span><span style=color:#fdf4c1>{y}</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>)
</span><span>    </span><span style=color:#fdf4c1>case (x, </span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>)</span><span>:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#fa5c4b>f</span><span style=color:#b8bb26>"X=</span><span style=color:#fdf4c1>{x}</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>)
</span><span>    </span><span style=color:#fdf4c1>case (x, y)</span><span>:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#fa5c4b>f</span><span style=color:#b8bb26>"X=</span><span style=color:#fdf4c1>{x}</span><span style=color:#b8bb26>, Y=</span><span style=color:#fdf4c1>{y}</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>)
</span><span>    case </span><span style=color:#fdf4c1>_</span><span>:
</span><span>        </span><span style=color:#fa5c4b>raise </span><span style=color:#fabd2f>ValueError</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"Not a point"</span><span style=color:#fdf4c1>)
</span></code></pre><p>仔细研究一下那个!第一个模式有两个字面量，可以认为是上面所示字面量模式的扩展。但是接下来的两个模式组合了一个字面量和一个变量，变量绑定来自 subject (<code>point</code>)的值。第四个模式捕获两个值，这使得它在概念上类似于解包赋值<code>(x, y) = point</code>。<p>如果你使用类来构造数据，你可以使用类名后跟一个类似构造函数的参数列表，但是可以将属性捕获到变量中:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fa5c4b>class </span><span style=color:#8ec07c>Point</span><span>:
</span><span>    x: </span><span style=color:#fabd2f>int
</span><span>    y: </span><span style=color:#fabd2f>int
</span><span>
</span><span style=color:#fa5c4b>def </span><span style=color:#8ec07c>where_is</span><span>(</span><span style=color:#fdf4c1>point</span><span>):
</span><span>    match point:
</span><span>        case </span><span style=color:#fdf4c1>Point(x</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, y</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>)</span><span>:
</span><span>            </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"Origin"</span><span style=color:#fdf4c1>)
</span><span>        case </span><span style=color:#fdf4c1>Point(x</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, y</span><span style=color:#fe8019>=</span><span style=color:#fdf4c1>y)</span><span>:
</span><span>            </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#fa5c4b>f</span><span style=color:#b8bb26>"Y=</span><span style=color:#fdf4c1>{y}</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>)
</span><span>        case </span><span style=color:#fdf4c1>Point(x</span><span style=color:#fe8019>=</span><span style=color:#fdf4c1>x, y</span><span style=color:#fe8019>=</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>)</span><span>:
</span><span>            </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#fa5c4b>f</span><span style=color:#b8bb26>"X=</span><span style=color:#fdf4c1>{x}</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>)
</span><span>        case </span><span style=color:#fdf4c1>Point()</span><span>:
</span><span>            </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"Somewhere else"</span><span style=color:#fdf4c1>)
</span><span>        case </span><span style=color:#fdf4c1>_</span><span>:
</span><span>            </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"Not a point"</span><span style=color:#fdf4c1>)
</span></code></pre><p>你可以在一些内置类中使用位置参数，这些类为它们的属性(例如数据类)提供排序。你也可以通过在你的类中设置<code>__match_args__</code>特殊属性来定义模式中属性的特定位置。如果它被设置为<code>("x"， "y")</code>，以下模式都是等价的(并且都将<code>y</code>属性绑定到<code>var</code>变量):<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fdf4c1>Point(</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>, var)
</span><span style=color:#fdf4c1>Point(</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>, y</span><span style=color:#fe8019>=</span><span style=color:#fdf4c1>var)
</span><span style=color:#fdf4c1>Point(x</span><span style=color:#fe8019>=</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>, y</span><span style=color:#fe8019>=</span><span style=color:#fdf4c1>var)
</span><span style=color:#fdf4c1>Point(y</span><span style=color:#fe8019>=</span><span style=color:#fdf4c1>var, x</span><span style=color:#fe8019>=</span><span style=color:#d3869b>1</span><span style=color:#fdf4c1>)
</span></code></pre><p>模式可以任意嵌套。例如，如果我们有一个简短的点列表，我们可以这样匹配:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>match points:
</span><span>    case []:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"No points"</span><span style=color:#fdf4c1>)
</span><span>    case [</span><span style=color:#fdf4c1>Point(</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, </span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>)</span><span>]:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"The origin"</span><span style=color:#fdf4c1>)
</span><span>    case [</span><span style=color:#fdf4c1>Point(x, y)</span><span>]:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#fa5c4b>f</span><span style=color:#b8bb26>"Single point </span><span style=color:#fdf4c1>{x}</span><span style=color:#b8bb26>, </span><span style=color:#fdf4c1>{y}</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>)
</span><span>    case [</span><span style=color:#fdf4c1>Point(</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, y1)</span><span>, </span><span style=color:#fdf4c1>Point(</span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>, y2)</span><span>]:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#fa5c4b>f</span><span style=color:#b8bb26>"Two on the Y axis at </span><span style=color:#fdf4c1>{y1}</span><span style=color:#b8bb26>, </span><span style=color:#fdf4c1>{y2}</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>)
</span><span>    case </span><span style=color:#fdf4c1>_</span><span>:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"Something else"</span><span style=color:#fdf4c1>)
</span></code></pre><p>我们可以向模式添加一个<code>if</code>子句，称为“guard”。如果 guard 为假，<code>match</code> 继续尝试下一个<code>case</code>块。注意，值捕获发生在guard求值之前:<pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span>match point:
</span><span>    case </span><span style=color:#fdf4c1>Point(x, y) </span><span style=color:#fa5c4b>if </span><span>x </span><span style=color:#fe8019>== </span><span>y:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#fa5c4b>f</span><span style=color:#b8bb26>"Y=X at </span><span style=color:#fdf4c1>{x}</span><span style=color:#b8bb26>"</span><span style=color:#fdf4c1>)
</span><span>    case </span><span style=color:#fdf4c1>Point(x, y)</span><span>:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#fa5c4b>f</span><span style=color:#b8bb26>"Not on the diagonal"</span><span style=color:#fdf4c1>)
</span></code></pre><p>其他几个关键功能:<ul><li><p>与解包赋值一样，元组和列表模式具有完全相同的含义，并且实际上匹配任意序列。一个重要的异常是它们<strong>不匹配</strong>迭代器或字符串。(技术上讲，subject 必须是<code>collections.abc.Sequence</code>的一个实例。)</p><li><p>序列模式支持通配符:<code>[x, y， *rest]</code>和<code>(x, y， *rest)</code>在解包赋值时的工作类似于通配符。*后面的名称也可以是<code>_</code>，所以<code>(x, y， *_)</code>匹配至少有两个项的序列，而不绑定其余的项。</p><li><p>映射模式:<code>{"bandwidth": b， "latency": l}</code>从字典中捕获<code>"bandwidth"</code>和<code>"latency"</code>值。与序列模式不同，额外的键被忽略。还支持通配符<code>**rest</code>。(但是<code>**_</code>是多余的，所以不允许。)</p><li><p>可以使用as关键字捕获子模式:</p> <pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fdf4c1>case (Point(x1, y1), Point(x2, y2) </span><span style=color:#fdf4c1;background-color:#932b1e>as</span><span> p2</span><span style=color:#fdf4c1;background-color:#932b1e>)</span><span>: </span><span style=color:#d3869b>...
</span></code></pre><li><p>大多数字面值的比较是<code>==</code>的，但是单例的<code>True</code>、<code>False</code>和<code>None</code>是通过<code>id</code>进行比较的。</p><li><p>模式可以使用命名的常量。这些必须用点命名，以防止它们被解释为捕获变量:</p> <pre class=language-python data-lang=python style=color:#fdf4c1aa;background-color:#282828><code class=language-python data-lang=python><span style=color:#fa5c4b>from </span><span>enum </span><span style=color:#fa5c4b>import </span><span>Enum
</span><span style=color:#fa5c4b>class </span><span style=color:#8ec07c>Color</span><span>(</span><span style=color:#8ec07c>Enum</span><span>):
</span><span>    </span><span style=color:#fdf4c1>RED </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0
</span><span>    </span><span style=color:#fdf4c1>GREEN </span><span style=color:#fe8019>= </span><span style=color:#d3869b>1
</span><span>    </span><span style=color:#fdf4c1>BLUE </span><span style=color:#fe8019>= </span><span style=color:#d3869b>2
</span><span>
</span><span>match color:
</span><span>    case Color.</span><span style=color:#fdf4c1>RED</span><span>:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"I see red!"</span><span style=color:#fdf4c1>)
</span><span>    case Color.</span><span style=color:#fdf4c1>GREEN</span><span>:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"Grass is green"</span><span style=color:#fdf4c1>)
</span><span>    case Color.</span><span style=color:#fdf4c1>BLUE</span><span>:
</span><span>        </span><span style=color:#fabd2f>print</span><span style=color:#fdf4c1>(</span><span style=color:#b8bb26>"I'm feeling the blues :("</span><span style=color:#fdf4c1>)
</span></code></pre></ul><h2 id=yuan-wen-dang-ban-quan-sheng-ming>原文档版权声明</h2><p>This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.<p>Source: https://github.com/python/peps/blob/master/pep-0636.rst</article><p class=tags-data><a href=/tags/python>/python/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>