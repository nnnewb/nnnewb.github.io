<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>MySQL 24小时入门笔记 - 2</title><meta content="MySQL 24小时入门笔记 - 2" name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2018/2018-06-23-mysqlru-men-2/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content="MySQL 24小时入门笔记 - 2" property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2018/2018-06-23-mysqlru-men-2/ property=twitter:url><meta content="MySQL 24小时入门笔记 - 2" property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2018/2018-06-23-mysqlru-men-2/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>MySQL 24小时入门笔记 - 2</h1><p class=author-line>作于：2018-06-23 15:41 ，预计阅读时间 11 分钟<article><h2 id=cha-xun>查询</h2><h3 id=select>SELECT</h3><p><code>SELECT</code>是一个特殊的关键字，它的语义是查询，取出结果。<blockquote><p><strong>注意</strong>：仅为个人理解。</blockquote><h3 id=from>FROM</h3><p><code>FROM</code>子句，标识要查询的对象的来源，来源可能是多个的。在查询有多个来源表的情况下，称之为联结查询（<code>Join query</code>）。<p>最常见的常规写法是<code>SELECT column FROM table</code>，表示从特定表取出所有行的特定列。<h3 id=where>WHERE</h3><p><code>WHERE</code>子句用于过滤查询的行，只有满足条件的行会被查询出来。<p>常见的用法有<code>SELECT column FROM table WHERE column &lt;> 0</code>，表示在<code>table</code>表中查询<code>column</code>非空的行，返回这些行的<code>column</code>。<p>其中的二元关系运算符<code>&lt;></code>表示不等于，其他常见的关系运算符还有这些。<table><thead><tr><th>运算符<th>含义<tbody><tr><td><code>=</code><td>相等<tr><td><code>></code><td>大于<tr><td><code>&lt;</code><td>小于<tr><td><code>>=</code><td>大于等于<tr><td><code>&lt;=</code><td>小于等于<tr><td><code>!=</code><td>不等于<tr><td><code>&lt;></code><td>不等于</table><p>此外还有一些<code>SQL</code>关键字可以辅助编写判断逻辑。<p><code>SQL</code>关键字<code>IN</code>可以用于判断元素是否在集合中。举例，<code>SELECT 1 IN (1,2,3)</code>，查询<code>1</code>是否在<code>1,2,3</code>这个集合中。被判断的集合需要被小括号包围，并且以逗号分隔元素。<p><code>SQL</code>关键字<code>BETWEEN</code>可以判断元素是否在一定区间中。举例，<code>SELECT 1 BETWEEN 0 and 10</code>，查询<code>1</code>是否在<code>0</code>到<code>10</code>的区间内。语法是<code>BETWEEN [low] AND [high]</code>，区间较小的一端必须在左侧，较大的一端必须在右侧。<p><code>SQL</code>关键字<code>LIKE</code>可以用非常简单的通配符来判断元素是否匹配一定的规则。举例，<code>SELECT 'abcabcabc' LIKE '%CAB%'</code>，判断字符串<code>abcabcabc</code>是否匹配<code>%CAB%</code>。值得注意的是，模式串中的<code>%</code>代表的是匹配 0 或任意多个字符，就像是正则表达式中的<code>*</code>一样。此外还有<code>_</code>，下划线，匹配 1 个任意字符。<p><code>MySQL</code>扩展的<code>REGEXP</code>可以用正则表达式来匹配元素是否符合模式串。举例，<code>SELECT 'abcabcabc' REGEXP '.*cab.*'</code>，正则表达式不做赘述，简单的模式串大家都会写。<h3 id=order-by>ORDER BY</h3><p><code>ORDER BY</code>就像字面意义上说的那样，按照某个列来进行排序。举例来说，我有一个学生表，记录了学号和姓名，我可以按照学号排序。<pre class=language-SQL data-lang=SQL style=color:#fdf4c1aa;background-color:#282828><code class=language-SQL data-lang=SQL><span style=color:#fa5c4b>SELECT </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>FROM</span><span> students </span><span style=color:#fa5c4b>ORDER BY</span><span> id;
</span></code></pre><p>默认排序是升序，也可以通过指定<code>DESC</code>或者<code>ASC</code>来决定怎么排。<code>ASC</code>是升序，<code>DESC</code>是降序。<pre class=language-SQL data-lang=SQL style=color:#fdf4c1aa;background-color:#282828><code class=language-SQL data-lang=SQL><span style=color:#fa5c4b>SELECT </span><span style=color:#fdf4c1>* </span><span style=color:#fa5c4b>FROM</span><span> students </span><span style=color:#fa5c4b>ORDER BY</span><span> id </span><span style=color:#fa5c4b>DESC</span><span>;
</span></code></pre><h3 id=as>AS</h3><p><code>AS</code>常见的用法是建立别名。<pre class=language-SQL data-lang=SQL style=color:#fdf4c1aa;background-color:#282828><code class=language-SQL data-lang=SQL><span style=color:#fa5c4b>SELECT</span><span> column </span><span style=color:#fe8019>AS</span><span> id_alias </span><span style=color:#fa5c4b>FROM</span><span> my_table </span><span style=color:#fe8019>AS</span><span> table_alias </span><span style=color:#fa5c4b>WHERE </span><span style=color:#b8bb26>table_alias</span><span>.</span><span style=color:#b8bb26>column </span><span style=color:#fe8019>&lt;> </span><span style=color:#d3869b>1</span><span>;
</span></code></pre><p>这里出现了一个新的语法细节，<code>table_alias.column</code>。用点<code>.</code>连接表名和列名的行为类似于 C++中的<pre class=language-C++ data-lang=C++ style=color:#fdf4c1aa;background-color:#282828><code class=language-C++ data-lang=C++><span style=color:#fa5c4b>typedef</span><span> table_alias </span><span style=color:#fe8019>= </span><span style=color:#8ec07c>my_table</span><span>;
</span><span style=color:#fa5c4b>auto</span><span> id_alias </span><span style=color:#fe8019>= </span><span style=color:#fdf4c1>SELECT(table_alias::column, table_alias::column </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>0</span><span style=color:#fdf4c1>)</span><span>;
</span></code></pre><p>看得出来，<code>table_alias.column</code>是完全限定了<code>column</code>是哪个<code>column</code>，之所以有这种语法，是因为<code>FROM</code>子句需要支持多个表作为查询来源。到时候可能就会用到<code>table1.column &lt;> 1 AND table2.column &lt;> 2</code>这样的写法了。<p>而查询开头的<code>column AS id_alias</code>则是标识查询结果列叫做<code>id_alias</code>，举例如子查询的情况下，便于引用。<h3 id=join>JOIN</h3><p><code>JOIN</code>的术语叫做<strong>联结</strong>，使用了<code>JOIN</code>关键字的查询叫做<strong>联结查询</strong>。<p>联结查询和一般的查询不同的地方是，联结查询的数据来源是多个表。<p>最简单的联结查询是内联结查询。<p>举例来说，我现在有表<code>students</code>如下，所有学生根据超能力开发等级分配到多个班级。<table><thead><tr><th>id<th>name<th>class<tbody><tr><td>1<td>stu1<td>1<tr><td>2<td>stu2<td>2<tr><td>3<td>stu3<td>3<tr><td>4<td>stu4<td>4</table><p>又有表<code>top_class</code>，收录了所有接收高等级超能力者的班级，能进入这些班级的学生都是如同能考上<code>985</code>、<code>211</code>般恐怖如斯的存在。<table><thead><tr><th>id<th>name<tbody><tr><td>1<td>Lv 5<tr><td>2<td>Lv 4<tr><td>3<td>Lv 3</table><p>现在我们要查询出学生中那些恐怖如斯的存在有哪些。<pre class=language-SQL data-lang=SQL style=color:#fdf4c1aa;background-color:#282828><code class=language-SQL data-lang=SQL><span style=color:#fa5c4b>SELECT </span><span style=color:#b8bb26>students</span><span>.</span><span style=color:#b8bb26>name </span><span style=color:#fe8019>AS</span><span> name </span><span style=color:#fa5c4b>FROM</span><span> students </span><span style=color:#fa5c4b>INNER JOIN</span><span> top_class ON </span><span style=color:#b8bb26>top_class</span><span>.</span><span style=color:#b8bb26>id </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>students</span><span>.</span><span style=color:#b8bb26>class</span><span>;
</span></code></pre><p>语法<code>JOIN [表] ON [条件]</code>也很简单啦。在例子中，<code>JOIN</code>表示要联结表<code>top_class</code>，<code>ON</code>表示查询的对象要符合条件<code>top_class.id = students.class</code>。不好理解？看看伪代码。<pre class=language-C++ data-lang=C++ style=color:#fdf4c1aa;background-color:#282828><code class=language-C++ data-lang=C++><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>auto</span><span> student </span><span style=color:#fe8019>:</span><span> students) { </span><span style=color:#928374;font-style:italic>// 先过滤 students 表本身，这个过滤应该由 WHERE 子句完成
</span><span>  </span><span style=color:#fa5c4b>for</span><span>(</span><span style=color:#fa5c4b>auto</span><span> cls </span><span style=color:#fe8019>:</span><span> top_class) { </span><span style=color:#928374;font-style:italic>// 然后联结表 top_class
</span><span>    </span><span style=color:#fa5c4b>if</span><span>(student.</span><span style=color:#fdf4c1>cls </span><span style=color:#fe8019>=</span><span> cls.</span><span style=color:#fdf4c1>id</span><span>) </span><span style=color:#928374;font-style:italic>// 判断 ON students.class = top_class.id
</span><span>      results.</span><span style=color:#fdf4c1>push</span><span>(student); </span><span style=color:#928374;font-style:italic>// 得出结果
</span><span>  }
</span><span>}
</span></code></pre><blockquote><p>注意，伪代码的查询过程是错误的，为了方便理解 students.class = top_class.id 才这么写。真实数据库实现联结查询的方法应当查阅对应<code>DBMS</code>的文档。</blockquote><p>注意的关键点有<code>ON</code>很像但不同于<code>WHERE</code>，在了解<code>LEFT JOIN</code>和<code>RIGHT JOIN</code>时会区分。<h3 id=left-join>LEFT JOIN</h3><p><code>LEFT JOIN</code>又叫<strong>左联结</strong>，基本思路是写在<code>LEFT JOIN</code>左边的表满足条件即可作为结果，即使右边的表没有满足条件的条目。<p>还是以上文的学园都市数据库为例（我 tm 写了什么...）<p>学生表 <code>students</code><table><thead><tr><th>id<th>name<th>class<tbody><tr><td>1<td>stu1<td>1<tr><td>2<td>stu2<td>2<tr><td>3<td>stu3<td>3<tr><td>4<td>stu4<td>4</table><p>班级表 <code>top_class</code><table><thead><tr><th>id<th>name<tbody><tr><td>1<td>Lv 5<tr><td>2<td>Lv 4<tr><td>3<td>Lv 3</table><p>现在我们查询学生都处在哪些班级，得到班级的名字。<pre class=language-SQL data-lang=SQL style=color:#fdf4c1aa;background-color:#282828><code class=language-SQL data-lang=SQL><span style=color:#fa5c4b>SELECT </span><span style=color:#b8bb26>students</span><span>.</span><span style=color:#b8bb26>name </span><span style=color:#fe8019>as</span><span> name, </span><span style=color:#b8bb26>top_class</span><span>.</span><span style=color:#b8bb26>name </span><span style=color:#fe8019>as</span><span> cls
</span><span>       </span><span style=color:#fa5c4b>FROM</span><span> students </span><span style=color:#fa5c4b>LEFT JOIN</span><span> top_class
</span><span>            ON </span><span style=color:#b8bb26>top_class</span><span>.</span><span style=color:#b8bb26>id </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>students</span><span>.</span><span style=color:#b8bb26>class</span><span>;
</span></code></pre><p>查询结果应该是这样子的。<table><thead><tr><th>name<th>cls<tbody><tr><td>stu1<td>Lv 5<tr><td>stu2<td>Lv 4<tr><td>stu3<td>Lv 3<tr><td>stu4<td><code>NULL</code></table><p>注意到了吗？<code>stu4</code>虽然不是<code>top_class</code>的学生，但是还是被查询出来了。<h3 id=right-join>RIGHT JOIN</h3><p>继续拿学园都市做例子......<p>其实是和左联结一个鸟样。<pre class=language-SQL data-lang=SQL style=color:#fdf4c1aa;background-color:#282828><code class=language-SQL data-lang=SQL><span style=color:#fa5c4b>SELECT </span><span style=color:#b8bb26>students</span><span>.</span><span style=color:#b8bb26>name </span><span style=color:#fe8019>as</span><span> name, </span><span style=color:#b8bb26>top_class</span><span>.</span><span style=color:#b8bb26>name </span><span style=color:#fe8019>as</span><span> cls
</span><span>       </span><span style=color:#fa5c4b>FROM</span><span> top_class </span><span style=color:#fa5c4b>RIGHT JOIN</span><span> students
</span><span>            ON </span><span style=color:#b8bb26>top_class</span><span>.</span><span style=color:#b8bb26>id </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>students</span><span>.</span><span style=color:#b8bb26>class</span><span>;
</span></code></pre><p>我们注意到......我就是把 <code>students</code>和 <code>top_class</code>换了个位置。查询结果其实是一样的。<table><thead><tr><th>name<th>cls<tbody><tr><td>stu1<td>Lv 5<tr><td>stu2<td>Lv 4<tr><td>stu3<td>Lv 3<tr><td>stu4<td><code>NULL</code></table><h3 id=cross-join>CROSS JOIN</h3><p>交叉联结，查询结果是联结的表和<code>FROM</code>的表的笛卡尔积，这么说听的明白不？听不明白就算了，因为交叉联结基本用不到。<p>其实就是把两个表的每个行都排列组合一下：<ul><li>表 A 行 1-表 B 行 1<li>表 A 行 1-表 B 行 2<li>......<li>表 A 行 10-表 B 行 1<li>表 A 行 10-表 B 行 2<li>表 A 行 10-表 B 行 3<li>......</ul><h3 id=join-zi-ji>JOIN 自己？</h3><p>术语叫自联结，其实也挺好理解的，直接举个例子看看。<table><thead><tr><th>id<th>name<th>class<tbody><tr><td>1<td>stu1<td>1<tr><td>2<td>stu2<td>1<tr><td>3<td>stu3<td>2<tr><td>4<td>stu4<td>2</table><blockquote><p>注意我数据改了哈。</blockquote><p>现在要查询出所有和<code>stu1</code>同一个班级的学生。<p>一般我们想怎么查？先查出<code>stu1</code>是哪个班级的：<code>SELECT class FROM students WHERE name = 'stu1'</code>，然后查出所有属于这个班级的学生：<code>SELECT name FROM students WHERE class = [上次查出来的班级]</code>。<p>那么...怎么写成一句话呢？<p>这时候自联结就可以上场了。<pre class=language-SQL data-lang=SQL style=color:#fdf4c1aa;background-color:#282828><code class=language-SQL data-lang=SQL><span style=color:#fa5c4b>SELECT </span><span style=color:#b8bb26>s1</span><span>.</span><span style=color:#b8bb26>id</span><span>, </span><span style=color:#b8bb26>s1</span><span>.</span><span style=color:#b8bb26>name</span><span>, </span><span style=color:#b8bb26>s1</span><span>.</span><span style=color:#b8bb26>class
</span><span style=color:#fa5c4b>FROM</span><span> students </span><span style=color:#fe8019>AS</span><span> s1 </span><span style=color:#fa5c4b>INNER JOIN</span><span> students </span><span style=color:#fe8019>AS</span><span> s2
</span><span style=color:#fa5c4b>WHERE </span><span style=color:#b8bb26>s1</span><span>.</span><span style=color:#b8bb26>class </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>s2</span><span>.</span><span style=color:#b8bb26>class
</span><span>	</span><span style=color:#fe8019>AND </span><span style=color:#b8bb26>s2</span><span>.</span><span style=color:#b8bb26>name </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>'stu1'</span><span>;
</span></code></pre><p>查询结果是<table><thead><tr><th>id<th>name<th>class<tbody><tr><td>1<td>stu1<td>1<tr><td>2<td>stu2<td>1</table><p>基本思路是这样的：<code>FROM</code>的表是<code>s1</code>，因此<code>INNER JOIN</code>查询结果来自<code>s1</code>而不是<code>s2</code>。查找<code>s1</code>表中每个行的<code>class</code>在<code>s2</code>表里有没有行具有同样的<code>class</code>属性，同时，<code>s2</code>具有和<code>s1</code>同样<code>class</code>属性的行还必须有个<code>stu1</code>的<code>name</code>。<p>分析得知，<code>s2</code>中有<code>stu1</code>这个<code>name</code>的行只有<code>1</code>，所以<code>s2</code>表其实长这样。<table><thead><tr><th>id<th>name<th>class<tbody><tr><td>1<td>stu1<td>1</table><p>这时候再去看<code>s1</code>表，<code>s1</code>表的<code>class</code>同时存在于<code>s2</code>表的行只有<code>1</code>和<code>2</code>了。<h3 id=outer-join>OUTER JOIN</h3><p>其实<code>OUTER JOIN</code>上面的<code>LEFT JOIN</code>和<code>RIGHT JOIN</code>已经讲过了，<code>LEFT JOIN</code>的完整写法就是<code>LEFT OUTER JOIN</code>，<code>RIGHT JOIN</code>就是<code>RIGHT OUTER JOIN</code>，和<code>INNER JOIN</code>的区别在于<code>OUTER JOIN</code>包含了指定表里不满足<code>ON</code>条件的行。<p>这有个知识点，就是<code>ON</code>条件不过滤指定<code>OUTER JOIN</code>的表的不满足条件的行，但是<code>WHERE</code>会过滤。<h3 id=union>UNION</h3><p><code>UNION</code>关键字的术语是<strong>联合查询</strong>。<p>作用是将多个<code>SELECT</code>的结果放在一起并返回。<p>举个例子......我们要查询全美最好的大学<code>american_top_college</code>和中国最好的大学<code>chinese_top_college</code>数据，来决定报考哪个大学（反正都考不上），如果不想写成两句<code>SELECT</code>，然后手工合并成一个表格的话，那么就用<code>UNION</code>查询吧。<pre class=language-SQL data-lang=SQL style=color:#fdf4c1aa;background-color:#282828><code class=language-SQL data-lang=SQL><span style=color:#fa5c4b>SELECT </span><span style=color:#b8bb26>'american' </span><span style=color:#fe8019>AS</span><span> nation, </span><span style=color:#b8bb26>american_top_college</span><span>.</span><span style=color:#b8bb26>name </span><span style=color:#fe8019>AS</span><span> college_name, </span><span style=color:#b8bb26>american_top_college</span><span>.</span><span style=color:#b8bb26>score_line </span><span style=color:#fe8019>AS</span><span> score_line
</span><span style=color:#fa5c4b>FROM</span><span> american_top_college
</span><span style=color:#fa5c4b>UNION
</span><span style=color:#fa5c4b>SELECT </span><span style=color:#b8bb26>'china' </span><span style=color:#fe8019>AS</span><span> nation, </span><span style=color:#b8bb26>chinese_top_college</span><span>.</span><span style=color:#b8bb26>name </span><span style=color:#fe8019>AS</span><span> college_name, </span><span style=color:#b8bb26>chinese_top_college</span><span>.</span><span style=color:#b8bb26>score_line </span><span style=color:#fe8019>AS</span><span> score_line;
</span></code></pre><p>查询结果...不展示了。<p>还有个细节可能要注意，如果有大学同时是美国大学和中国大学的话，那么为了在联合查询中排除相同的项目，可以使用<code>UNION ALL</code>而不是<code>UNION</code>。<h3 id=fulltext>FULLTEXT</h3><p><code>MySQL</code>支持一种实用的文本索引方式，叫做<strong>全文本搜索</strong>。大家都知道，正则表达式和简单通配符来查找文本是非常消耗性能的操作，而且难以优化（反正我想不出任何减少查询的优化思路）。<code>MySQL</code>提供了全文本搜索的属性来帮助索引文本（但是想到中文支持我觉得已经凉的差不多了），快速查询出包含特定词汇之类的行。<blockquote><p>抱歉我觉得不行。不说别的，中文分词就......</blockquote><p>跳过了跳过了。</article><p class=tags-data><a href=/tags/mysql>/mysql/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>