<!doctype html><html lang=zh><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>定点数开根号算法（1）</title><meta content=定点数开根号算法（1） name=title><meta content=一点点从这个世界上消失。 name=description><meta content=website property=og:type><meta content=https://nnnewb.github.io/posts/2025/fixed-point-sqrt-algorithm-part-1/ property=og:url><meta content="weakptr's blog" property=og:site_name><meta content=定点数开根号算法（1） property=og:title><meta content=一点点从这个世界上消失。 property=og:description><meta content=https://nnnewb.github.io/image/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nnnewb.github.io/posts/2025/fixed-point-sqrt-algorithm-part-1/ property=twitter:url><meta content=定点数开根号算法（1） property=twitter:title><meta content=一点点从这个世界上消失。 property=twitter:description><meta content=https://nnnewb.github.io/image/favicon.ico property=twitter:image><link href=https://nnnewb.github.io/posts/2025/fixed-point-sqrt-algorithm-part-1/ rel=canonical><link rel="shortcut icon" href=https://nnnewb.github.io/image/favicon.ico type=image/x-icon><link href=https://nnnewb.github.io/css/reset.css rel=stylesheet><link href=https://nnnewb.github.io/css/pallete.css rel=stylesheet><link href=https://nnnewb.github.io/css/suCSS.css rel=stylesheet><link href=https://nnnewb.github.io/archive.css rel=stylesheet><link href=https://nnnewb.github.io/style.css rel=stylesheet><script defer src=https://nnnewb.github.io/js/script.js></script><link crossorigin href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y rel=stylesheet><script crossorigin defer integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js></script><script crossorigin defer integrity=sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js></script><script crossorigin defer integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            // customised options
            // • auto-render specific keys, e.g.:
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: false }
            ],
            // • rendering keys, e.g.:
            throwOnError: true
        });
    });</script><script src=https://cdn.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js></script><script>document.addEventListener('DOMContentLoaded', function () {
        // 查找所有具有 'pre' 标签且类名为 'language-mermaid' 的元素
        const mermaidElements = document.getElementsByClassName('language-mermaid');
        for (let i = 0; i < mermaidElements.length; i++) {
            const el = mermaidElements.item(i);
            if (el.tagName === "PRE" && !el.classList.contains('mermaid')) {
                el.innerHTML = el.textContent;
                el.classList.add('mermaid');
            }
        }

        mermaid.initialize({ startOnLoad: true, theme: 'dark', });
    })</script><script>if (window.location.hostname.toLowerCase() !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?dbb9df33a2de52aede8bccd84a7493ad";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    }</script><link href=https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Medium/result.css rel=stylesheet><link href=https://chinese-fonts-cdn.deno.dev/packages/maple-mono-cn/dist/MapleMono-CN-Regular/result.css rel=stylesheet><body><header><nav id=nav-bar><a href=/> 首页 </a>  /  <a href=/posts/> 文章 </a>  /  <a href=/categories/> 分类 </a>  /  <a href=/tags/> 标签 </a>  /  <a href=/search/> 搜索 </a>  /  <div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://nnnewb.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://nnnewb.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>定点数开根号算法（1）</h1><p class=author-line>作于：2025-08-12 17:20 ，预计阅读时间 10 分钟<article><h2 id=qian-yan>前言</h2><p>把第一份工作后写的定点数运动-碰撞检测库重新拿出来看了下，打算手搓个 go 的定点数。<p>搓完四则运算就来到了第一个坑点，开方。<p>手动开方法常用的有两种：<ul><li>牛顿-拉弗森法<li>逐比特确认法</ul><p>完成这篇博客花费的时间长过我的预期，所以分成两部分完成。<h2 id=niu-dun-la-fu-sen-fa>牛顿-拉弗森法</h2><p>我们求一个数 $a$ 的平方根，可以看作求解方程 $x^2-a=0$ 的正根。我们可以画出函数 图像 $f(x)=x^2-a$ 。<p>牛顿-拉弗森法的基本思路是可以任取一点 $x_1$ 作为初始值，当 $f(x_1)=0$ 时 $x_1$ 就是 $a$ 的根，如果不是，那么从 $f(x)=x^2-a$ 上这一点做切线，切线与 x 轴的交点会更接近 $a$ 的根。<p>我们先列出这个函数的导函数：$f'(x)=2x$<p>还有切线方程：$m(x-x_n)=y-y_n$ ，其中 n 是迭代轮数，$x_n$ 表示第 n 轮迭代的 x 。 $m$ 是原函数在 $x_n$ 的导数。<p>变形可以得到求切线零点的方程：$m(x-x_n)+y_n=0$<p>同时，我们知道这个方程中 $x$ 、 $m$ 、 $y_n$ 的的含义：<ul><li>$x$ 是我们下一轮迭代的取值，即 $x_{n+1}$<li>$m$ 是 $f'(x_n)$<li>$y_n$ 是 $f(x_n)$</ul><p>替换进方程后可得到：<p>$$ f'(x_n)(x-x_n)+f(x_n)=0 $$<p>接下来整理下这个方程：<p>$$ \begin{aligned} f'(x_n)(x_{n+1}-x_n)+f(x_n)&=0 \\ x_{n+1}-x_n &= -\frac{f(x_n)}{f'(x_n)} \\ x_{n+1} &= x_n - \frac{f(x_n)}{f'(x_n)} \end{aligned} $$<p>就得到了牛顿-拉弗森迭代法公式。<p>求给定数字 $a$ 的平方根根的场景，我们有：<p>$$ \begin{aligned} f(x) &= x_n^2-a \\ f'(x) &= 2x_n \\ \end{aligned} $$<p>可以进一步代入并化简这条公式<p>$$ \begin{aligned} x_{n+1} &= x_n - \frac{f(x_n)}{f'(x_n)} \\ &= x_n - \frac{x_n^2-a}{2x_n} \\ &= \frac{2x_n^2 - (x_n^2-a)}{2x_n} \\ &= \frac{x_n^2+a}{2x_n} \\ &= \frac{1}{2}\frac{x_n^2+a}{x_n} \\ &= \frac{1}{2}(x_n+\frac{a}{x_n}) \\ \end{aligned} $$<p>在迭代结束后，我们就有了$x_n\approx\sqrt{a}$ 。<blockquote><p><strong>NOTE</strong>：对于开根号的这个特定场景，$x^2-a=0$ 函数图像的顶点一定在 $x=0$ 只要避开 $x=0$ 的 猜测值，牛顿法就不会发散。不过选择良好的初始值还是有益的，可以加快收敛速度。</blockquote><h2 id=niu-dun-la-fu-sen-fa-qiu-shang>牛顿-拉弗森法求商</h2><p>牛顿-拉弗森法可以用于实现快速除法运算。<p>对于除法我们可以列出这样的方程：$q=\frac{n}{d}$<p>其中：<ul><li>q 是商<li>n 是被除数<li>d 是除数</ul><p>我们知道除法可以表示为被除数和除数的倒数的乘积，由此得到方程：$q=n\frac{1}{d}$<p>只要能求得 $\frac{1}{d}$ 的近似值，就可以用乘法运算求得 $q$ 的近似值。<p>我们设 $x=\frac{1}{d}$ 可以得到 $d=\frac{1}{x}$ ，写成关于 $x$ 的函数就是：$f(x)=d-\frac{1}{x}$ ，我们求函数的零点，即 $d-\frac{1}{x}=0$<p>这个函数的导函数是 $f'(x)=\frac{1}{x^2}$<p>如果直接使用牛顿-拉弗森迭代法，会发现存在一个递归定义：$\frac{1}{x}$ 依然是除法。<p>这里需要将牛顿-拉弗森迭代公式展开化简：<p>$$ \begin{aligned} x_{n+1} &= x_n-\frac{f(x_n)}{f'(x_n)} \\ x_{n+1} &= x_n-\frac{d-\frac{1}{x_n}}{\frac{1}{x_n^2}} \\ x_{n+1} &= x_n-(d-\frac{1}{x_n})x_n^2 \\ x_{n+1} &= x_n-x_n^2d+x_n \\ x_{n+1} &= 2x_n-x_n^2d \\ x_{n+1} &= x_n(2-dx_n) \end{aligned} $$<p>化简后的牛顿-拉弗森求商迭代公式就没有除法了。<p>我们得到迭代后的 $x_n$ 是原除数的倒数 $\frac{1}{d}$ 的近似，此时就可以用乘法计算 出原除法的商了：<p>$$ \begin{aligned} q&=n\frac{1}{d} \\ &=nx_n \end{aligned} $$<h2 id=zhu-bi-te-que-ren-fa>逐比特确认法</h2><p>逐比特确认法是一种类似长除法(竖式除法开根号)的思路，从高位开始逐个比特确认。<p>例如，设被开方数为 $N$ ，$N$ 的比特数 $B_N=8$ ，也就是 $N$ 的最高位是 8 比特。<p>从根的最高位第4个比特开始判断是否为1，当第4个比特为是1时，根是 $2^3=8$ 。 如果 $N>2^3$ ，那么根的第4个比特位就是 $1$ ，反之则是 $0$ 。<h3 id=que-ren-gen-de-bi-te-shu>确认根的比特数</h3><p>那么根的最高位怎么确认呢？最直觉告诉我们，正整数的根肯定小于原数，我们从 $N$ 的最高位开始肯定没问题，但这样会引入无效计算。<p>我们定义任意正整数最小需要 $B_X$ 位表示，可得<p>$$ B_X=\lfloor{\log_{2}{X}}\rfloor+1 $$<p>可设 $B_r$ 为 $N$ 的根的比特数：<p>$$ \begin{aligned} B_r&=\lfloor\log_{2}{\sqrt{N}}\rfloor+1 \\ &=\lfloor\log_{2}{N^{\frac{1}{2}}}\rfloor+1 \\ &=\lfloor\frac{1}{2}\log_{2}{N}\rfloor+1 \\ \end{aligned} $$<p>$N$ 的最高位是 $B_N$ 位时，$N$ 满足：<p>$$ 2^{B_N-1}\le{N}\lt{2^{B_N}} $$<p>将不等式的每一项都求2为底的对数，得到：<p>$$ B_N-1\le{\log_{2}{N}}\lt{B_N} $$<p>所有项全部除以2，得到：<p>$$ \frac{B_N-1}{2}\le{\frac{1}{2}\log_{2}{N}}\lt{\frac{B_N}{2}} $$<p>由于 $B_r$ 的定义不能直接代入，我们先设 $x=\frac{1}{2}\log_{2}{N}$ 代入不等式考察。<p>$$ \frac{B_N-1}{2}\le{x}\lt{\frac{B_N}{2}} $$<p>现在我们开始考虑 $B_N$：<p><strong>偶数</strong>：<p>如果 $B_N$ 是偶数，我们可以定义 $B_N=2k$<p>$$ \frac{2k-1}{2}\le{x}\lt{\frac{2k}{2}} $$<p>化简得到<p>$$ k-\frac{1}{2}\le{x}\lt{k} $$<p>基于 $x$ 的范围我们向下取整，得到 $\lfloor{x}\rfloor=k-1$ ，代入 $B_r$ 定义可得 $B_r=k-1+1=k$<p><strong>奇数</strong>：<p>如果 $B_N$ 是奇数，我们定义 $B_N=2k+1$<p>$$ \frac{2k+1-1}{2}\le{x}\lt{\frac{2k+1}{2}} $$<p>化简得到<p>$$ k\le{x}\lt{k+\frac{1}{2}} $$<p>我们向下取整，得到 $\lfloor{x}\rfloor=k$ 。 代入 $B_r$ 定义可得，当 $B_N$ 是奇数时， $B_r=k+1$ ，代回推导 $B_r$ 和 $B_N$ 的关系：<p>$$ \begin{aligned} 2k+1&=B_N \\ 2k &=B_N-1 \\ k &=\frac{B_N-1}{2} \\ k+1 &=\frac{B_N-1}{2}+1 \\ B_r &=\frac{B_N-1+2}{2} \\ B_r &=\frac{B_N+1}{2} \end{aligned} $$<p>得出结论：<p>$$ \begin{cases} B_r = \frac{B_N}{2} &\text{if } B_N=2k, k\in \mathbb{Z} \\ B_r = \frac{B_N+1}{2} &\text{if } B_N=2k+1, k \in \mathbb{Z} \end{cases} $$<h3 id=zhu-bi-te-die-dai>逐比特迭代</h3><p>定义根的第 $n$ 个比特位为 $r_n$，$n\ge{0}$，每一轮迭代确认未被确认的最高位。 $R_n$ 为已经确认的根。<p>$$ \begin{cases} r_{n-1} = 1 &\text{if } N\ge{(R_n+2^{n-1})^2} \\ r_{n-1} = 0 &\text{if } N\lt{(R_n+2^{n-1})^2} \end{cases} $$<p>确认 $r_n$ 后加入已确认的根 $R_n$ ： $R_{n-1} = R_{n} + r_{n-1}2^{n-1}$<p>然后开始下一轮迭代。<h3 id=zhu-bi-te-die-dai-yu-shu>逐比特迭代（余数）</h3><p>我们也可以使用余数迭代，避免重复计算 $(R_n+2^{n-1})^2$，我们定义余数 $X_n$ 替换原式子中的 $N$。<p>$$ \begin{cases} r_{n-1} = 1 &\text{if } R_n^2+X_n\ge{(R_n+2^{n-1})^2} \\ r_{n-1} = 0 &\text{if } R_n^2+X_n\lt{(R_n+2^{n-1})^2} \end{cases} $$<p>将 $(R_n+2^{n-1})^2$ 展开：<p>$$ \begin{aligned} (R_n+2^{n-1})^2 &= R_n^2 + 2R_n2^{n-1} + 2^{2n-2} \end{aligned} $$<p>代回原不等式，将不等式化简：<p>$$ \begin{aligned} R_n^2+X_n &\ge{(R_n+2^{n-1})^2} \\ R_n^2+X_n &\ge{R_n^2 + 2R_n2^{n-1} + 2^{2n-2}} \\ X_n &\ge{2R_n2^{n-1} + 2^{2n-2}} \\ X_n &\ge{R_n2^{n} + 2^{2n-2}} \end{aligned} $$<p>余数更新公式的定义同理。<p>确认到第 $n$ 比特位时，余数 $X_n$ 的定义是：$X_n = N-R_n^2$ 。<p>我们把 $N$ 替换为 $R_n^2+X_n$ 再考虑新迭代出的比特位，得到余数的迭代公式。<p>$$ \begin{aligned} X_{n-1} &= N-(R_n+r_{n-1}2^{n-1})^2 \\ X_{n-1} &= R_n^2+X_n-(R_n+r_{n-1}2^{n-1})^2 \\ X_{n-1} &= R_n^2+X_n-(R_n^2 + 2 \cdot R_n \cdot r_{n-1} \cdot 2^{n-1} + r_{n-1}^2\cdot2^{2n-2}) \\ X_{n-1} &= R_n^2+X_n-R_n^2 - 2R_n\cdot r_{n-1} \cdot 2^{n-1} - r_{n-1}^2 \cdot 2^{2n-2} \\ X_{n-1} &= X_n - 2R_n\cdot r_{n-1} \cdot 2^{n-1} - r_{n-1}^2 \cdot 2^{2n-2} \\ \end{aligned} $$<p>根的迭代公式则没有变化。<p>$$ \begin{aligned} R_{n-1} &= R_{n} + r_{n-1}2^{n-1} \end{aligned} $$</article><p class=tags-data><a href=/tags/ding-dian-shu>/定点数/</a> <a href=/tags/suan-fa>/算法/</a> <a href=/tags/shu-xue>/数学/</a></p><script data-repo-id="MDEwOlJlcG9zaXRvcnkzOTg0ODYyMTg=" async crossorigin data-category=Announcements data-category-id=DIC_kwDOF8Bqys4Cegmn data-emit-metadata=0 data-input-position=bottom data-lang=zh-CN data-mapping=pathname data-reactions-enabled=1 data-repo=nnnewb/nnnewb.github.io data-strict=0 data-theme=noborder_light id=giscus_script src=https://giscus.app/client.js></script></main><footer><hr><div id=footer-container><div><p style=text-align:center>Copyright © 2018-2024 weakptr <a href=mailto:weak_ptr@outlook.com>&lt;weak_ptr@outlook.com></a><p style=text-align:center>Built with <a rel="noopener noreferrer" href=https://www.getzola.org target=_blank>Zola</a> using <a rel="noopener noreferrer" href=https://github.com/Speyll/anemone target=_blank>anemone</a> theme, <a rel="noopener noreferrer" href=https://speyll.github.io/suCSS/ target=_blank>suCSS</a> framework & <a rel="noopener noreferrer" href=https://github.com/Speyll/veqev target=_blank>veqev</a>, modified by <a rel="noopener noreferrer" href=https://github.com/nnnewb/ target=_blank>nnnewb</a>.<p style=text-align:center>Theme and color theme licensed under <a rel="noopener noreferrer" href=https://en.wikipedia.org/wiki/Licence_MIT target=_blank>MIT</a>.</div></div></footer>